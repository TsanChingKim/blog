---
title: Chapter-2-算法分析
date: 2025-11-10
categories: ["DataStructure"]
robots: all
summary: 评估一个成功完成某项指定目的的算法的好坏
featureimage: images/data-structure/chapter2back.jpg
tags:
---

{{< katex >}}

**算法**（algorithm）是为求解一个问题需要遵循的、被清楚指定的简单的指令的集合。
那么判断这个算法的好坏就很重要了，本章要学习的东西如下：
- 如何估计一个程序所需要的时间
- 如何将一个程序的运行时间从天活年降低到秒甚至更少
- 粗心使用递归的后果
- 讲一个数字乘得到其幂，以及计算两个数的最大公因数的非常有效的算法
# 2.1 数学基础
**定义2.1**     如果存在正常数 \(c\) 和 \(n_0\) 使得当 \(N\leq n_0\) 时 \(T(N) \leq cf(N)\) ，则记为 \(T(N)=O(f(N))\) 。

**定义2.2**    如果存在正常数 \(c\) 和 \(n_0\) 使得当 \(N \geq n_0\) 时 \(T(N) \geq cf(N)\) ，则记为 \(T(N)=\Omega (f(N))\) 。

**定义2.3**    \(T(N)=\Theta (h(N))\) 当且仅当 \(T(N)=O(h(N))\) 和 \(T(N)= \Omega (h(N))\)。

**定义2.4**   如果对每一正常数 \(c\) 和 \(n_0\) 使得当 \(N>n_0\) 时 \(T(N)<cp(N)\)，则 \(T(N)=o(p(N))\)。有时也可以说，如果\(T(N)=O(p(N))\) 且 \(T(N)\neq O(h(N))\)，则 \(T(N)=o(p(N))\) 。

给定两个函数，通常存在一些点，在这些点上一个函数的值小于另一个函数的值，因此，一般地宣称，比如 \(f(N)<g(N)\) ，但是这并没有什么意义。于是，我们比较它们的**相对增长率**（relative rate of growth）。

虽然对于较小的 \(N\) 值 \(1000N\) 要比 \(N^2\) 要大，但 \(N^2\) 以更快的速度增粘，因此 \(N^2\) 最终将是更大的函数。**定义2.1**是说，对后总会在某个点 \(n_0\) 从它以后 \(c·f(N)\) 总是至少与 \(T(N)\) 一样大，从而忽略常数因子，则 \(f(N)\) 至少与 \(T(N)\) 一样大，从而忽略常数因子，则 \(f(N)\) 至少与 \(T(N)\) 一样大。可以说\(1000N=O(N^2)\) (N平方级)。这种标记方法称为**大O标记法**。

说白话就是：
- 如果 \(T(N)\) 的增长率小于等于 \(f(N)\) 的增长率，则 \(T(N) = f(N)\)
- 如果 \(T(N)\) 的增长率大于等于 \(f(N)\) 的增长率，则 \(T(N)=\Omega (f(N))\)
- 如果 \(T(N)\) 的增长率等于 \(f(N)\) ，则 \(T(N)=\Theta (f(N))\)
- 如果 \(T(N)\) 的增长率小于 \(f(N)\)，则 \(T(N)=o(f(N))\)
如果 \(T(N)=O(f(N))\) 时，则 \(f(N)\) 是 \(T(N)\) 的一个**上界**，同时 \(T(N)\) 也是 \(f(N)\) 的**下界**
## 法则1
如果 \(T_1(N)=O(f(N))\) 且 \(T_2(N)=O(g(N))\) ，那么
- \(T_1(N)+T_2(N)=O(f(N)+g(N)\) 
- \(T_1(N)*T_2(N)=O(f(N)*g(N))\)
## 法则2
如果 \(T(N)\) 是一个 \(k\) 次多项式，则 \(T(N)=\Theta (N^k)\)。
## 法则3
对任意常数 \(k\)，\({log^k{N}}=O(N)\) 。它告诉我们对数增长的非常缓慢。

|    函数    |  名称   |
| :------: | :---: |
|   \(c\)    |  常数   |
|  \(logN\)  |  对数   |
| \(log^2N\) | 对数平方的 |
|   \(N\)    |  线性的  |
| \(NlogN\)  |       |
|  \(N^2\)   |  二次   |
|  \(N^3\)   |  三次   |
|  \(2^N\)   |  指数   |

{{< alert "info" >}}
注意
- 将常数或低阶项放进大O是非常坏的习惯，如 \(T(N)=O(2N^2)\) 可以简化成 \(T(N)=O(N^2)\)
- 我们能够通过计算极限来确定两个函数的相对增长率：\(\lim_{N \to \infty}  \frac{f(N)}{g(N)}\)
	- 极限是 \(0\)：这意味着 \(f(N)=o(g(N))\)
	- 极限是 \(c \neq 0\) ：这意味着 \(f(N)=\Theta(g(N))\)
	- 极限是 \(\infty\) ：这意味着 \(g(N)=o(f(N))\)
	- 极限摆动：二者无关
- 不要写成不等式，因为定义中已经隐含不等式了
{{< /alert >}}

{{< alert "danger" >}}
注意
有些计算是线性的，如根据文件大小判断下载时间，在网络稳定且理想的情况下，两者的关系是线性的，但是如排序问题，当输入量增加到两倍的时候，则对大量输入的运行时间增加到4倍，这就不是线性的，当讨论排序时，普通的排序算法是 \(O(N^2)\)
{{< /alert >}}

# 2.2 模型
在正式的架构中分析算法时，我们需要一个计算模型。如一台标准的计算机，一个标准的计算系统，能够运行标准的指令，在理想化的单位时间内完成相同的工作。
# 2.3 要分析的问题
通常，要分析的最重要的资源就是运行时间。
典型的情况是，输入的大小时主要的考虑方面。定义两个函数 \(T_{avg}(N)\) 和 \(T_{worst}(N)\)，分别为算法对于输入量N所花费的平均运行时间和最坏情况的运行时间，显然\(T_{avg}(N) \leq T_{worst}(N)\)
偶尔也分析一下一个算法最好情形的性能。不过，通常没什么意义。
一般来说若无相反的指定，则所需要的量时最坏情况的运行时间。其原因之一是它对所有输入提供了一个界限，包括特别坏的输入，二平均情况分析不提供这样的界。另一个原因是平均情况的界计算起来通常要困难的多。在某些情况下，“平均”的定义可能影响分析的结果。
## 最大子序列问题
给定（可能有负的）整数 \(A_1,A_2,···,A_N\) ，求 \(\sum_{k=i}^{j}A_k\) 的最大值。（为方便起见，如果所有整数均为负数，则最大子序列和为0）。
![16fb3b0c2db7f596853db4d9d7409aa2_MD5](https://raw.githubusercontent.com/TsanChingKim/picGo/main/pic/202511131149122.jpeg)

在输入量很小的情况下，这些算法都是在眨眼之间完成，因此如果只是销量输入的情形，那么话费大量的努力去设计聪明的算法就不值得了。

在上面的表格当中，我们可以看到，线性算法4的表现最好，当问题的规模增长了十倍的时候，其运行时间也增长了十倍。而具有平法复杂度的算法2就不行了，十倍的规模增长就会导致运行时间有百倍（\(10^2\)) 的增长。而立方则有千倍的增长，后面的算法也以此类推。这些都是在理想情况下，但是在现实计算机的内存存取 \(N=1\,000\,000\) 可能比处理 \(N = 100\,000\) 要慢，这取决于内存缓存的大小。
# 2.4 运行时间计算
确定哪个程序更快的最好方法就是将它们编码并运行。
为了简化分析，我们将采纳如下的约定：不存在特定的时间单位。因此，我们抛弃一次额前导的常数。还要抛弃低阶项，从而要做的就是计算大O的运行时间。
## 2.4.1 一个简单的例子
计算下列累加算式
$$
\sum_{i=1}^{N}i^3
$$

```java
public static int sum(int n){
	int partialSum;
	
	partialSum = 0;
	for(int i = 1; i <= n; i++)
		partialSum += i * i * i;
	return partialSum;
}
```

第2行和第7行个占一个时间单元，变量`i`的初始化占1个单元时间，比较大小的总时间为 \(N+1\) ,所有自增运算为 \(N\) 个单元时间，则总共为\(2N+2\) 个单元时间，如果忽略调用方法和返回值的开销，得到的总量就是 \(6N+4\) 个时间单元。因此该方法就是 \(O(N)\) 。由此我们可以总结出下一章的一般法则。
## 2.4.2 一般法则
### 法则1——for 循环
一个for循环的运行时间至多是该for循环内部那些语句（包括测试）的运行时间乘以迭代的次数。
### 法则2——嵌套的 for 循环
从里向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有的 for 循环的大小的乘积。
### 法则3——顺序语句
将各个语句的运行时间求和即可（这意味着，其中的最大值就是所得的运行时间）
### 法则4——if/else 语句
对于程序片段
```java
if(condition)
	S1
else
	S2
```
一个`if/else`语句的运行时间从不超过判断的运行时间再加上 `S1`和`S2`中运行时间长者的总的运行时间。

当涉及到递归的时候，算法分析会变得非常困难
```java
public static long fib(int n){
	if(n <= 1)
		return 1;
	else
		return fib(n-1) + fib(n-2);
}
```
当\(N=0\)或\(N=1\)的时候，运行时间是某个常数值，即第一行上做判断以及返回所用的时间。因为常数并不重要，所以可以说\(T(0)=T(1)=1\)。对于\(N\)的其他运行时间则是\(T(N-1)+T(N-2)\)。再加上第二行的判断以及第五行的加法，可得：
$$
T(N)=T(N-1)+T(N-2)+2
$$

由归纳法可得 \(fib(N)<(5/3)^3\) ，类似的极端可以证明（对于 \(N>4\) )\(fib(N)>(\frac{3}{2})^N\) ，从而这个程序运行的时间以**指数**的速度增长。

这个递归其实存在一个问题就是有大量多余的工作要做，违反了在1.3节中叙述的递归的第四条主要法则（合成效益法则）。当我们调用`fib(n-1)`其实在某处已经计算了`fib(n-2)`，但是这个信息被抛弃了。
## 2.4.3 最大子序列和问题的求解
当前有一个数组，我们要求出它的最大子序列，介绍四种方法
### 暴力破解
```java
public static int maxSubSum1(int[] a){
	int maxSum = 0;
	for(int i = 0; i < a.length; i++){
		for(int j = 0; j < a.length; j++){
			int perSum = 0;
			for(int k = i; k <= j: k++){
				perSum += a[k];
			}
			if(perSum > maxSum)
				maxSum = perSum;
		}
	}
	return maxSum;
}
```

这个算法肯定会正确运行。运行时间为\(O(N^3)\)
我们下面开始分析这个算法的时间复杂度：
第5行占1个单位时间，而三个循环最坏的情况都是 \(N\) 个单位时间，因此总数为 \(O(1·N·N·N)\)
所以时间复杂度为 \(O(N^3)\)
但是如果进行更精确的分析：
$$\begin{flalign*}
\sum_{i=0}^{N-1}\frac{(N-i+1)(N-i)}{2}&=\sum_{i=1}^{N}\frac{(N-i+1)(N-i+2)}{2} \\ \\
&=\frac12\sum_{i=1}^{N}i^2-(N+\frac32)\sum_{i=1}^Ni+\frac12(N^2+3N+2)\sum_{i=1}^N1 \\ \\
&=\frac12\frac{N(N+1)(2N+1)}6-(N+\frac32)\frac{N(N+1)}2+\frac{N^2+3N+2}2N\\ \\
&=\frac{N^3+3N^2+2N}6
\end{flalign*}$$
### 算法优化
我们可以通过撤除一个for循环来提高运行时间
```java
public static int maxSubSum1(int[] a){
	int maxSum = 0;
	for(int i = 0; i < a.length; i++){
		int perSum = 0;
		for(int j = i; j < a.length; j++){
			perSum += a[i];
			if(perSum > maxSum){
				maxSum = perSum;
			}
		}
	}
	return maxSum;
}
```

对这个问题有一个递归和相对复杂的 \(O(NlogN)\) 解法，要是没出现 \(O(N)\) ,这个算法就会是提现递归威力的极好范例。

该方法采用“分治（divide-and-conquer)”策略，其想法就是将问题分为两个大致相等的子问题，然后递归地对他们求解，这是“分”的部分。“治”阶段将两个子问题的解修补到一起并可能再做些少量的附加工作，最后得到整个问题的解。

在当前这个问题中，最大子序列要么出现在数组的左半部分，要么出现在数组的右半部分，要么出现在数组的中间部分，我们举个例子：
![img_v3_02rv_a532675c-7b99-49ae-8271-9663d47d18bg](https://raw.githubusercontent.com/TsanChingKim/picGo/main/pic/img_v3_02rv_a532675c-7b99-49ae-8271-9663d47d18bg.jpg)
前半部分最大子序列的和为6，后半部分最大子序列和为8；前半部分包含最后一个元素（\(-2\)）的最大子序列和是4，而后半部分包含第一个元素（\(-1\)）的最大子序列和为7，因此横跨这两部分且通过中间的最大和是 \(4+7=11\)
```java
private static int maxSumRec(int[] a,int left, int right){
	// 如果数组的第一个下标和最后一个一样，就代表数组只有一个元素
	if(left == right)
		if(a[left] > 0)
			return a[left];
		else
			return 0;
			
	int center = (left + right) / 2; //计算中间元素的下标
	int maxleftSum = maxSumRec(a, left, center); // 递归计算左边的最大子序列和
	int maxRightSum = maxSumRec(a, center, right);  // 递归计算右半部分的最大子序列和
	
	int maxLeftBorderSum = 0;
	int leftBorderSum = 0;
	for(int i = center; i >= left; i--){
		leftBorderSum += a[i];
		if(maxLeftBorderSum < leftBorderSum){
			maxLeftBorderSum = leftBorderSum;
		}
	}
	int maxRigthBorderSum = 0;
	int rightBorderSum = 0;
	for(int i = center + 1; i <= right; i++){
		rightBorderSum += a[i];
		if(maxRightBorderSum < right){
			maxRightBorderSum = rightBorderSum;
		}
	}
	return max(maxLeftBorderSum, maxRightBorderSum, maxLeftBorderSum + maxRightBorderSum)
}
```

现在我们来计算这个算法的时间复杂度：
当输入规模为 \(1\) 时：\(T(1)=1\)
当输入规模为 \(N\) 时：两次循环所需要的总时间为N再加上两个人递归所需要的时间 \(2T(\frac N2)\) ，则可得总时间为 \(T(N) = 2T(\frac N2)+N\)
但是当前我们知道 \(T(1) =1\) ，那么 \(T(2)=2*2\) ，\(T(4) = 4*3\) ，\(T(8)=8*4\) 
由归纳可得，若 \(N=2^k\) ，则 \(T(N)=N*(k+1)=NlogN+N=O(NlogN)\)
### 聪明算法
```java
public static int maxSubSum(int[] a){
	int maxSum = 0;
	int thisSum = 0;
	for(int j = 0; j < a.length; j++){
		thisSum += a[j];
		if(thisSum > maxSum)
			maxSum = thisSum;
		else if(thisSum < 0)
			thisSum = 0;
	}
	return maxSum;
}
```
这个算法的核心就是舍弃掉了起点，当起点为负数时，必不可能是和最大的子序列，所以我们将其重置为0
这个算法是许多聪明算法的典型：运行时间是明显的，但是正确性不那么容易看出来。
该算法的一个附带的优点是，它只对数据进行一次扫描，一旦a\[i] 被读入并被处理，它就不再需要被记忆。因此，如果数组在磁盘上或通过互联网传送，那么它就可以被按顺序读入，在主存中不必存储数组的任何部分。不仅如此，在任意时刻，算法都能对它已经读入的数据给出子序列问题的正确大难（其他算法不具有这个特性）。具有这种特性的算法叫做**联机算法**（on-line algorithm)。*仅需要常量控件并以线性时间运行的联机算法几乎是完美的算法。*
## 2.4.4 运行时间中的对数
*如果一个算法用常数时间只是把问题的大小削减为其一部分（通常是 \(\frac 12\)），那么该算法就是 \(O(logN)\) 。另一方面，如果使用常数时间只是把问题减少一个常数的数量（如将问题减少 \(1\)），那么这种算法就是 \(O(N)\) 的。*
### 折半查找
**折半查找**：给定一个整数X和整数 \(A_0,A_1,···,A_{N-1}\) ，后者已经预先排序并存在内存中，求下标 \(i\) 使得 \(A_i=X\) ，如果 \(X\) 不在数据中，则返回 \(i=-1\) 。
实现该算法的主要思想就是将X与中间的数值进行比对，来缩小搜寻范围
```java
public static int binarySearch(int[] a, int x){
	int first = 0;
	int last = 0;
	while(first <= last){
		int mid = (first + last) / 2;
		if(x < a[mid]){
			last = mid;
		}else if(x > a[mid]){
			first = mid;
		}else if(x = a[mid]){
			return mid;
		}
	}
	return -1;
}
```
而折半查找的时间复杂度为什么是O(logN)，我们可以很好的理解：数据量从\(1\) 到 \(\frac12\) 到 \(\frac14\) 到 \(\frac18\) 是以指数倍减小的，所以我们可以得出这种折半削减其数据量的算法的时间复杂度为 \(O(logN)\)。
### 欧几里得算法
计算两数的最大公因数
```java
public static long gcd(int M, int N){
	while( n != 0){
		long rem = m % n;
		m = n;
		n = rem;
	}
	return m;
}
```

**定理2.1**：如果 \(M>N\) ，则 \(M mod N<\frac M2\) 。
### 幂运算
 计算 \(X^N\) 的明显算法是使用 \(N-1\) 次乘法自乘。有一种递归算法效果更好。\(N \leq 1\) 是这种递归地基准清醒。否则，若 \(N\) 是偶数，我们有 \(X^N=X^{\frac N2}·X^{\frac N2}\) ，如果 \(N\) 是奇数，则 \(X^N=X^{\frac{(N-1)}2}·X^\frac{(N-1)}{2}·X\) 。
我们可以使用递归来实现这个算法
```java
public static long pow(int x, int n){
	if( n = 0 ){
		return 0;
	}
	if( n = 1 ){
		return x;
	}
	if(isEven(n)){
		return pow(x * x, n / 2);
	}else{
		return pow(x * x, n/2) * x;
	}
}
```
## 2.4.5 分析结果的准确性
根据经验，有时分析会估计过大。如果这种情况发生，那么或者需要进一步细化分析（一般通过机敏的观察），或者可能是**平均**运行时间显著小于最坏情形的运行时间，不可能对所得的界再加以改进。对于许多复杂的算法，最坏的界通过某个坏的输入是可以达到的，但在实践中它通常是故居过大的。遗憾的是，对于大多数这类问题，平均清醒的分析是极其复杂的（在许多情形下仍然悬而未决），而最坏情形的界尽管过分地悲观，但确实最好的已知解析结果。