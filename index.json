[{"content":" Activity 活动组件 # Activity 是 Android 应用的核心组件，代表一个用户界面屏幕。每个 Activity 都是一个独立的用户交互单元。\nActivity 基本概念 # 什么是 Activity # Activity 是 Android 应用的四大组件之一，代表应用中的一个屏幕或界面。每个 Activity 都有其生命周期，由系统管理。\nActivity 与 Layout 的关系 # class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 设置布局文件 setContentView(R.layout.activity_main) // 初始化界面 initViews() } private fun initViews() { // 通过 findViewById 获取布局中的控件 val textView = findViewById\u0026lt;TextView\u0026gt;(R.id.textView) val button = findViewById\u0026lt;Button\u0026gt;(R.id.button) // 设置控件属性 textView.text = \u0026#34;Hello Activity!\u0026#34; button.setOnClickListener { Toast.makeText(this, \u0026#34;按钮被点击\u0026#34;, Toast.LENGTH_SHORT).show() } } } Activity 启动方式 # 1. 显式启动 # 通过指定具体的 Activity 类来启动：\nclass MainActivity : AppCompatActivity() { private lateinit var startButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupClickListeners() } private fun initViews() { startButton = findViewById(R.id.startButton) } private fun setupClickListeners() { startButton.setOnClickListener { // 显式启动 SecondActivity val intent = Intent(this, SecondActivity::class.java) startActivity(intent) } } } 2. 隐式启动 # 通过 Intent 的 action、category、data 等属性来启动：\nclass MainActivity : AppCompatActivity() { private lateinit var openWebButton: Button private lateinit var dialButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupClickListeners() } private fun initViews() { openWebButton = findViewById(R.id.openWebButton) dialButton = findViewById(R.id.dialButton) } private fun setupClickListeners() { // 打开网页 openWebButton.setOnClickListener { val intent = Intent(Intent.ACTION_VIEW).apply { data = Uri.parse(\u0026#34;https://www.example.com\u0026#34;) } startActivity(intent) } // 拨打电话 dialButton.setOnClickListener { val intent = Intent(Intent.ACTION_DIAL).apply { data = Uri.parse(\u0026#34;tel:10086\u0026#34;) } startActivity(intent) } } } 3. startActivityForResult # 启动 Activity 并等待返回结果：\nclass MainActivity : AppCompatActivity() { private lateinit var selectImageButton: Button private val REQUEST_CODE_SELECT_IMAGE = 1001 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupClickListeners() } private fun initViews() { selectImageButton = findViewById(R.id.selectImageButton) } private fun setupClickListeners() { selectImageButton.setOnClickListener { val intent = Intent(Intent.ACTION_PICK).apply { type = \u0026#34;image/*\u0026#34; } startActivityForResult(intent, REQUEST_CODE_SELECT_IMAGE) } } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) if (requestCode == REQUEST_CODE_SELECT_IMAGE \u0026amp;\u0026amp; resultCode == RESULT_OK) { data?.data?.let { imageUri -\u0026gt; // 处理选择的图片 handleSelectedImage(imageUri) } } } private fun handleSelectedImage(imageUri: Uri) { Toast.makeText(this, \u0026#34;图片已选择: $imageUri\u0026#34;, Toast.LENGTH_SHORT).show() } } Activity 启动模式 # 1. Standard（标准模式） # 默认模式，每次启动都会创建新的 Activity 实例：\n\u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:launchMode=\u0026#34;standard\u0026#34; /\u0026gt; class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onCreate: ${this.hashCode()}\u0026#34;) } override fun onNewIntent(intent: Intent?) { super.onNewIntent(intent) Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onNewIntent: ${this.hashCode()}\u0026#34;) } } 2. SingleTop（顶部复用模式） # 如果 Activity 已经在栈顶，则不会创建新实例：\n\u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:launchMode=\u0026#34;singleTop\u0026#34; /\u0026gt; class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onCreate: ${this.hashCode()}\u0026#34;) } override fun onNewIntent(intent: Intent?) { super.onNewIntent(intent) Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onNewIntent: ${this.hashCode()}\u0026#34;) // 处理新的 Intent handleNewIntent(intent) } private fun handleNewIntent(intent: Intent?) { // 更新界面或处理新数据 Toast.makeText(this, \u0026#34;收到新的 Intent\u0026#34;, Toast.LENGTH_SHORT).show() } } 3. SingleTask（单任务模式） # 整个应用中只有一个实例，会清除其上的所有 Activity：\n\u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:launchMode=\u0026#34;singleTask\u0026#34; /\u0026gt; class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onCreate: ${this.hashCode()}\u0026#34;) } override fun onNewIntent(intent: Intent?) { super.onNewIntent(intent) Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onNewIntent: ${this.hashCode()}\u0026#34;) // 处理新的 Intent handleNewIntent(intent) } private fun handleNewIntent(intent: Intent?) { // 更新界面或处理新数据 Toast.makeText(this, \u0026#34;回到主界面\u0026#34;, Toast.LENGTH_SHORT).show() } } 4. SingleInstance（单实例模式） # 单独的任务栈，整个系统中只有一个实例：\n\u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:launchMode=\u0026#34;singleInstance\u0026#34; /\u0026gt; Activity 生命周期 # 生命周期方法详解 # class LifecycleActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_lifecycle) Log.d(\u0026#34;Lifecycle\u0026#34;, \u0026#34;onCreate\u0026#34;) // 初始化界面和数据 initViews() initData() } override fun onStart() { super.onStart() Log.d(\u0026#34;Lifecycle\u0026#34;, \u0026#34;onStart\u0026#34;) // Activity 变为可见状态 } override fun onResume() { super.onResume() Log.d(\u0026#34;Lifecycle\u0026#34;, \u0026#34;onResume\u0026#34;) // Activity 获得焦点，可以接收用户输入 startLocationUpdates() } override fun onPause() { super.onPause() Log.d(\u0026#34;Lifecycle\u0026#34;, \u0026#34;onPause\u0026#34;) // Activity 失去焦点，暂停操作 stopLocationUpdates() } override fun onStop() { super.onStop() Log.d(\u0026#34;Lifecycle\u0026#34;, \u0026#34;onStop\u0026#34;) // Activity 不可见 } override fun onRestart() { super.onRestart() Log.d(\u0026#34;Lifecycle\u0026#34;, \u0026#34;onRestart\u0026#34;) // 从停止状态重新启动 } override fun onDestroy() { super.onDestroy() Log.d(\u0026#34;Lifecycle\u0026#34;, \u0026#34;onDestroy\u0026#34;) // 释放资源 releaseResources() } private fun initViews() { // 初始化界面控件 } private fun initData() { // 初始化数据 } private fun startLocationUpdates() { // 开始位置更新 } private fun stopLocationUpdates() { // 停止位置更新 } private fun releaseResources() { // 释放资源 } } 生命周期状态图 # graph TD A[onCreate] --\u003e B[onStart] B --\u003e C[onResume] C --\u003e D[onPause] D --\u003e E[onStop] E --\u003e F[onDestroy] D --\u003e C E --\u003e B E --\u003e F G[onRestart] --\u003e B E --\u003e G 保存和恢复状态 # class StateActivity : AppCompatActivity() { private lateinit var editText: EditText private lateinit var counterText: TextView private var counter = 0 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_state) initViews() // 恢复保存的状态 savedInstanceState?.let { counter = it.getInt(\u0026#34;counter\u0026#34;, 0) updateCounterDisplay() } } private fun initViews() { editText = findViewById(R.id.editText) counterText = findViewById(R.id.counterText) findViewById\u0026lt;Button\u0026gt;(R.id.incrementButton).setOnClickListener { counter++ updateCounterDisplay() } } private fun updateCounterDisplay() { counterText.text = \u0026#34;计数: $counter\u0026#34; } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) // 保存状态 outState.putInt(\u0026#34;counter\u0026#34;, counter) outState.putString(\u0026#34;editText\u0026#34;, editText.text.toString()) } override fun onRestoreInstanceState(savedInstanceState: Bundle) { super.onRestoreInstanceState(savedInstanceState) // 恢复状态 counter = savedInstanceState.getInt(\u0026#34;counter\u0026#34;, 0) editText.setText(savedInstanceState.getString(\u0026#34;editText\u0026#34;, \u0026#34;\u0026#34;)) updateCounterDisplay() } } Activity 数据传递 # 1. 传递简单数据 # class MainActivity : AppCompatActivity() { private lateinit var startButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupClickListeners() } private fun initViews() { startButton = findViewById(R.id.startButton) } private fun setupClickListeners() { startButton.setOnClickListener { val intent = Intent(this, SecondActivity::class.java).apply { // 传递简单数据 putExtra(\u0026#34;name\u0026#34;, \u0026#34;张三\u0026#34;) putExtra(\u0026#34;age\u0026#34;, 25) putExtra(\u0026#34;isStudent\u0026#34;, true) } startActivity(intent) } } } class SecondActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_second) // 接收传递的数据 val name = intent.getStringExtra(\u0026#34;name\u0026#34;) val age = intent.getIntExtra(\u0026#34;age\u0026#34;, 0) val isStudent = intent.getBooleanExtra(\u0026#34;isStudent\u0026#34;, false) // 显示数据 findViewById\u0026lt;TextView\u0026gt;(R.id.nameText).text = \u0026#34;姓名: $name\u0026#34; findViewById\u0026lt;TextView\u0026gt;(R.id.ageText).text = \u0026#34;年龄: $age\u0026#34; findViewById\u0026lt;TextView\u0026gt;(R.id.studentText).text = \u0026#34;学生: $isStudent\u0026#34; } } 2. 传递对象数据 # // 数据类 data class User( val name: String, val age: Int, val email: String ) : Parcelable { constructor(parcel: Parcel) : this( parcel.readString() ?: \u0026#34;\u0026#34;, parcel.readInt(), parcel.readString() ?: \u0026#34;\u0026#34; ) override fun writeToParcel(parcel: Parcel, flags: Int) { parcel.writeString(name) parcel.writeInt(age) parcel.writeString(email) } override fun describeContents(): Int = 0 companion object CREATOR : Parcelable.Creator\u0026lt;User\u0026gt; { override fun createFromParcel(parcel: Parcel): User = User(parcel) override fun newArray(size: Int): Array\u0026lt;User?\u0026gt; = arrayOfNulls(size) } } class MainActivity : AppCompatActivity() { private lateinit var startButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupClickListeners() } private fun initViews() { startButton = findViewById(R.id.startButton) } private fun setupClickListeners() { startButton.setOnClickListener { val user = User(\u0026#34;李四\u0026#34;, 30, \u0026#34;lisi@example.com\u0026#34;) val intent = Intent(this, SecondActivity::class.java).apply { putExtra(\u0026#34;user\u0026#34;, user) } startActivity(intent) } } } class SecondActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_second) // 接收传递的对象 val user = intent.getParcelableExtra\u0026lt;User\u0026gt;(\u0026#34;user\u0026#34;) user?.let { findViewById\u0026lt;TextView\u0026gt;(R.id.nameText).text = \u0026#34;姓名: ${it.name}\u0026#34; findViewById\u0026lt;TextView\u0026gt;(R.id.ageText).text = \u0026#34;年龄: ${it.age}\u0026#34; findViewById\u0026lt;TextView\u0026gt;(R.id.emailText).text = \u0026#34;邮箱: ${it.email}\u0026#34; } } } 3. 返回数据给上一个 Activity # class SecondActivity : AppCompatActivity() { private lateinit var resultButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_second) initViews() setupClickListeners() } private fun initViews() { resultButton = findViewById(R.id.resultButton) } private fun setupClickListeners() { resultButton.setOnClickListener { val resultIntent = Intent().apply { putExtra(\u0026#34;result\u0026#34;, \u0026#34;操作成功\u0026#34;) putExtra(\u0026#34;code\u0026#34;, 200) } setResult(RESULT_OK, resultIntent) finish() } } } class MainActivity : AppCompatActivity() { private val REQUEST_CODE_SECOND = 1001 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupClickListeners() } private fun initViews() { findViewById\u0026lt;Button\u0026gt;(R.id.startButton).setOnClickListener { val intent = Intent(this, SecondActivity::class.java) startActivityForResult(intent, REQUEST_CODE_SECOND) } } private fun setupClickListeners() { // 点击事件已在 initViews 中设置 } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) if (requestCode == REQUEST_CODE_SECOND \u0026amp;\u0026amp; resultCode == RESULT_OK) { val result = data?.getStringExtra(\u0026#34;result\u0026#34;) val code = data?.getIntExtra(\u0026#34;code\u0026#34;, 0) Toast.makeText(this, \u0026#34;结果: $result, 代码: $code\u0026#34;, Toast.LENGTH_SHORT).show() } } } Activity 最佳实践 # 1. 内存泄漏防护 # class MainActivity : AppCompatActivity() { private var handler: Handler? = null private var runnable: Runnable? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // 使用弱引用避免内存泄漏 handler = Handler(Looper.getMainLooper()) runnable = Runnable { // 更新界面 updateUI() } handler?.postDelayed(runnable!!, 1000) } override fun onDestroy() { super.onDestroy() // 清理资源 handler?.removeCallbacks(runnable!!) handler = null runnable = null } private fun updateUI() { // 更新界面逻辑 } } 2. 状态保存和恢复 # class MainActivity : AppCompatActivity() { private lateinit var editText: EditText private var userInput: String = \u0026#34;\u0026#34; override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() // 恢复保存的状态 savedInstanceState?.let { userInput = it.getString(\u0026#34;userInput\u0026#34;, \u0026#34;\u0026#34;) editText.setText(userInput) } } private fun initViews() { editText = findViewById(R.id.editText) editText.addTextChangedListener(object : TextWatcher { override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {} override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { userInput = s.toString() } override fun afterTextChanged(s: Editable?) {} }) } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) outState.putString(\u0026#34;userInput\u0026#34;, userInput) } } 3. 权限处理 # class MainActivity : AppCompatActivity() { private val REQUEST_CODE_PERMISSION = 1001 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) checkPermissions() } private fun checkPermissions() { if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions( this, arrayOf(Manifest.permission.CAMERA), REQUEST_CODE_PERMISSION ) } else { // 权限已授予，执行相关操作 openCamera() } } override fun onRequestPermissionsResult( requestCode: Int, permissions: Array\u0026lt;out String\u0026gt;, grantResults: IntArray ) { super.onRequestPermissionsResult(requestCode, permissions, grantResults) if (requestCode == REQUEST_CODE_PERMISSION) { if (grantResults.isNotEmpty() \u0026amp;\u0026amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { // 权限已授予 openCamera() } else { // 权限被拒绝 Toast.makeText(this, \u0026#34;需要相机权限\u0026#34;, Toast.LENGTH_SHORT).show() } } } private fun openCamera() { // 打开相机 Toast.makeText(this, \u0026#34;相机已打开\u0026#34;, Toast.LENGTH_SHORT).show() } } 📋 总结 # Activity 是 Android 应用的核心组件：\n生命周期管理：理解 onCreate、onStart、onResume 等生命周期方法 启动模式：Standard、SingleTop、SingleTask、SingleInstance 四种模式 数据传递：通过 Intent 传递简单数据和对象 状态保存：使用 onSaveInstanceState 保存和恢复状态 最佳实践：避免内存泄漏、正确处理权限、合理使用生命周期 掌握 Activity 的使用方法是 Android 开发的基础，对于构建高质量的应用至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/11---activity-%E6%B4%BB%E5%8A%A8%E7%BB%84%E4%BB%B6/","section":"Posts","summary":"详细介绍Android Activity活动组件的生命周期、启动模式、数据传递和最佳实践","title":"Activity 活动组件","type":"posts"},{"content":" AlertDialog 消息提示 # AlertDialog 是 Android 中最常用的对话框组件，用于向用户传递信息、提示或警告用户的行为。\nAlertDialog 基本概念 # AlertDialog 是一个模态对话框，用于显示重要信息或获取用户确认。它提供了多种样式和交互方式。\n基本方法 # 方法 说明 示例 setTitle() 设置对话框标题 setTitle(\u0026quot;提示\u0026quot;) setMessage() 设置对话框内容 setMessage(\u0026quot;确定要删除吗？\u0026quot;) setPositiveButton() 设置确认按钮 setPositiveButton(\u0026quot;确定\u0026quot;) setNegativeButton() 设置取消按钮 setNegativeButton(\u0026quot;取消\u0026quot;) setNeutralButton() 设置中性按钮 setNeutralButton(\u0026quot;稍后\u0026quot;) create() 创建对话框 builder.create() show() 显示对话框 dialog.show() 基本使用示例 # 1. 简单提示对话框 # class AlertDialogActivity : AppCompatActivity() { private lateinit var showDialogButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_alert_dialog) initViews() setupClickListeners() } private fun initViews() { showDialogButton = findViewById(R.id.showDialogButton) } private fun setupClickListeners() { showDialogButton.setOnClickListener { showSimpleDialog() } } private fun showSimpleDialog() { AlertDialog.Builder(this) .setTitle(\u0026#34;提示\u0026#34;) .setMessage(\u0026#34;这是一个简单的提示对话框\u0026#34;) .setPositiveButton(\u0026#34;确定\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;点击了确定\u0026#34;, Toast.LENGTH_SHORT).show() } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;点击了取消\u0026#34;, Toast.LENGTH_SHORT).show() } .show() } } 2. 确认对话框 # class ConfirmDialogActivity : AppCompatActivity() { private lateinit var deleteButton: Button private lateinit var exitButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_confirm_dialog) initViews() setupClickListeners() } private fun initViews() { deleteButton = findViewById(R.id.deleteButton) exitButton = findViewById(R.id.exitButton) } private fun setupClickListeners() { deleteButton.setOnClickListener { showDeleteConfirmDialog() } exitButton.setOnClickListener { showExitConfirmDialog() } } private fun showDeleteConfirmDialog() { AlertDialog.Builder(this) .setTitle(\u0026#34;删除确认\u0026#34;) .setMessage(\u0026#34;确定要删除这个项目吗？此操作不可撤销。\u0026#34;) .setPositiveButton(\u0026#34;删除\u0026#34;) { dialog, which -\u0026gt; performDelete() } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;取消删除\u0026#34;, Toast.LENGTH_SHORT).show() } .setIcon(android.R.drawable.ic_dialog_alert) .show() } private fun showExitConfirmDialog() { AlertDialog.Builder(this) .setTitle(\u0026#34;退出应用\u0026#34;) .setMessage(\u0026#34;确定要退出应用吗？\u0026#34;) .setPositiveButton(\u0026#34;退出\u0026#34;) { dialog, which -\u0026gt; finish() } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;取消退出\u0026#34;, Toast.LENGTH_SHORT).show() } .setNeutralButton(\u0026#34;最小化\u0026#34;) { dialog, which -\u0026gt; moveTaskToBack(true) } .show() } private fun performDelete() { Toast.makeText(this, \u0026#34;删除成功\u0026#34;, Toast.LENGTH_SHORT).show() // 执行删除操作 } } 3. 列表选择对话框 # class ListDialogActivity : AppCompatActivity() { private lateinit var showListButton: Button private lateinit var showMultiChoiceButton: Button private val items = arrayOf(\u0026#34;选项1\u0026#34;, \u0026#34;选项2\u0026#34;, \u0026#34;选项3\u0026#34;, \u0026#34;选项4\u0026#34;, \u0026#34;选项5\u0026#34;) private val selectedItems = booleanArrayOf(false, false, false, false, false) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_list_dialog) initViews() setupClickListeners() } private fun initViews() { showListButton = findViewById(R.id.showListButton) showMultiChoiceButton = findViewById(R.id.showMultiChoiceButton) } private fun setupClickListeners() { showListButton.setOnClickListener { showSingleChoiceDialog() } showMultiChoiceButton.setOnClickListener { showMultiChoiceDialog() } } private fun showSingleChoiceDialog() { AlertDialog.Builder(this) .setTitle(\u0026#34;选择选项\u0026#34;) .setItems(items) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;选择了: ${items[which]}\u0026#34;, Toast.LENGTH_SHORT).show() } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;取消选择\u0026#34;, Toast.LENGTH_SHORT).show() } .show() } private fun showMultiChoiceDialog() { AlertDialog.Builder(this) .setTitle(\u0026#34;多选选项\u0026#34;) .setMultiChoiceItems(items, selectedItems) { dialog, which, isChecked -\u0026gt; selectedItems[which] = isChecked } .setPositiveButton(\u0026#34;确定\u0026#34;) { dialog, which -\u0026gt; val selectedOptions = mutableListOf\u0026lt;String\u0026gt;() selectedItems.forEachIndexed { index, isSelected -\u0026gt; if (isSelected) { selectedOptions.add(items[index]) } } Toast.makeText(this, \u0026#34;选择了: ${selectedOptions.joinToString(\u0026#34;, \u0026#34;)}\u0026#34;, Toast.LENGTH_LONG).show() } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;取消选择\u0026#34;, Toast.LENGTH_SHORT).show() } .show() } } 自定义对话框 # 1. 自定义布局对话框 # class CustomDialogActivity : AppCompatActivity() { private lateinit var showCustomDialogButton: Button private lateinit var showLoginDialogButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_custom_dialog) initViews() setupClickListeners() } private fun initViews() { showCustomDialogButton = findViewById(R.id.showCustomDialogButton) showLoginDialogButton = findViewById(R.id.showLoginDialogButton) } private fun setupClickListeners() { showCustomDialogButton.setOnClickListener { showCustomLayoutDialog() } showLoginDialogButton.setOnClickListener { showLoginDialog() } } private fun showCustomLayoutDialog() { val dialogView = layoutInflater.inflate(R.layout.dialog_custom, null) val editText = dialogView.findViewById\u0026lt;EditText\u0026gt;(R.id.editText) val checkBox = dialogView.findViewById\u0026lt;CheckBox\u0026gt;(R.id.checkBox) AlertDialog.Builder(this) .setTitle(\u0026#34;自定义对话框\u0026#34;) .setView(dialogView) .setPositiveButton(\u0026#34;确定\u0026#34;) { dialog, which -\u0026gt; val inputText = editText.text.toString() val isChecked = checkBox.isChecked Toast.makeText(this, \u0026#34;输入: $inputText, 勾选: $isChecked\u0026#34;, Toast.LENGTH_SHORT).show() } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;取消操作\u0026#34;, Toast.LENGTH_SHORT).show() } .show() } private fun showLoginDialog() { val dialogView = layoutInflater.inflate(R.layout.dialog_login, null) val usernameEditText = dialogView.findViewById\u0026lt;EditText\u0026gt;(R.id.usernameEditText) val passwordEditText = dialogView.findViewById\u0026lt;EditText\u0026gt;(R.id.passwordEditText) val rememberCheckBox = dialogView.findViewById\u0026lt;CheckBox\u0026gt;(R.id.rememberCheckBox) AlertDialog.Builder(this) .setTitle(\u0026#34;用户登录\u0026#34;) .setView(dialogView) .setPositiveButton(\u0026#34;登录\u0026#34;) { dialog, which -\u0026gt; val username = usernameEditText.text.toString() val password = passwordEditText.text.toString() val remember = rememberCheckBox.isChecked if (username.isNotEmpty() \u0026amp;\u0026amp; password.isNotEmpty()) { performLogin(username, password, remember) } else { Toast.makeText(this, \u0026#34;请输入用户名和密码\u0026#34;, Toast.LENGTH_SHORT).show() } } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;取消登录\u0026#34;, Toast.LENGTH_SHORT).show() } .setCancelable(false) .show() } private fun performLogin(username: String, password: String, remember: Boolean) { Toast.makeText(this, \u0026#34;登录成功: $username, 记住密码: $remember\u0026#34;, Toast.LENGTH_SHORT).show() // 执行登录逻辑 } } 2. 自定义样式对话框 # \u0026lt;!-- res/values/styles.xml --\u0026gt; \u0026lt;style name=\u0026#34;CustomDialogTheme\u0026#34; parent=\u0026#34;Theme.AppCompat.Dialog\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowBackground\u0026#34;\u0026gt;@drawable/dialog_background\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowAnimationStyle\u0026#34;\u0026gt;@style/DialogAnimation\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;style name=\u0026#34;DialogAnimation\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowEnterAnimation\u0026#34;\u0026gt;@anim/dialog_enter\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowExitAnimation\u0026#34;\u0026gt;@anim/dialog_exit\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; class StyledDialogActivity : AppCompatActivity() { private lateinit var showStyledDialogButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_styled_dialog) initViews() setupClickListeners() } private fun initViews() { showStyledDialogButton = findViewById(R.id.showStyledDialogButton) } private fun setupClickListeners() { showStyledDialogButton.setOnClickListener { showStyledDialog() } } private fun showStyledDialog() { val dialog = AlertDialog.Builder(this, R.style.CustomDialogTheme) .setTitle(\u0026#34;样式对话框\u0026#34;) .setMessage(\u0026#34;这是一个自定义样式的对话框\u0026#34;) .setPositiveButton(\u0026#34;确定\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;点击了确定\u0026#34;, Toast.LENGTH_SHORT).show() } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;点击了取消\u0026#34;, Toast.LENGTH_SHORT).show() } .create() dialog.show() // 自定义按钮样式 dialog.getButton(AlertDialog.BUTTON_POSITIVE)?.setTextColor(ContextCompat.getColor(this, R.color.primary)) dialog.getButton(AlertDialog.BUTTON_NEGATIVE)?.setTextColor(ContextCompat.getColor(this, R.color.secondary)) } } 实际应用场景 # 1. 权限请求对话框 # class PermissionDialogActivity : AppCompatActivity() { private lateinit var requestPermissionButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_permission_dialog) initViews() setupClickListeners() } private fun initViews() { requestPermissionButton = findViewById(R.id.requestPermissionButton) } private fun setupClickListeners() { requestPermissionButton.setOnClickListener { showPermissionDialog() } } private fun showPermissionDialog() { AlertDialog.Builder(this) .setTitle(\u0026#34;权限请求\u0026#34;) .setMessage(\u0026#34;应用需要访问相机权限来拍照，是否允许？\u0026#34;) .setPositiveButton(\u0026#34;允许\u0026#34;) { dialog, which -\u0026gt; requestCameraPermission() } .setNegativeButton(\u0026#34;拒绝\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;权限被拒绝\u0026#34;, Toast.LENGTH_SHORT).show() } .setIcon(android.R.drawable.ic_dialog_info) .show() } private fun requestCameraPermission() { if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), 1001) } } } 2. 网络错误对话框 # class NetworkErrorDialogActivity : AppCompatActivity() { private lateinit var simulateErrorButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_network_error_dialog) initViews() setupClickListeners() } private fun initViews() { simulateErrorButton = findViewById(R.id.simulateErrorButton) } private fun setupClickListeners() { simulateErrorButton.setOnClickListener { showNetworkErrorDialog() } } private fun showNetworkErrorDialog() { AlertDialog.Builder(this) .setTitle(\u0026#34;网络错误\u0026#34;) .setMessage(\u0026#34;网络连接失败，请检查网络设置后重试\u0026#34;) .setPositiveButton(\u0026#34;重试\u0026#34;) { dialog, which -\u0026gt; retryNetworkRequest() } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;取消操作\u0026#34;, Toast.LENGTH_SHORT).show() } .setNeutralButton(\u0026#34;设置\u0026#34;) { dialog, which -\u0026gt; openNetworkSettings() } .setIcon(android.R.drawable.ic_dialog_alert) .setCancelable(false) .show() } private fun retryNetworkRequest() { Toast.makeText(this, \u0026#34;正在重试...\u0026#34;, Toast.LENGTH_SHORT).show() // 执行重试逻辑 } private fun openNetworkSettings() { Toast.makeText(this, \u0026#34;打开网络设置\u0026#34;, Toast.LENGTH_SHORT).show() // 打开网络设置页面 } } 3. 更新提示对话框 # class UpdateDialogActivity : AppCompatActivity() { private lateinit var showUpdateButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_update_dialog) initViews() setupClickListeners() } private fun initViews() { showUpdateButton = findViewById(R.id.showUpdateButton) } private fun setupClickListeners() { showUpdateButton.setOnClickListener { showUpdateDialog() } } private fun showUpdateDialog() { AlertDialog.Builder(this) .setTitle(\u0026#34;发现新版本\u0026#34;) .setMessage(\u0026#34;发现新版本 v2.0.0，是否立即更新？\\n\\n更新内容：\\n• 修复已知问题\\n• 新增功能\\n• 性能优化\u0026#34;) .setPositiveButton(\u0026#34;立即更新\u0026#34;) { dialog, which -\u0026gt; startUpdate() } .setNegativeButton(\u0026#34;稍后更新\u0026#34;) { dialog, which -\u0026gt; Toast.makeText(this, \u0026#34;稍后更新\u0026#34;, Toast.LENGTH_SHORT).show() } .setNeutralButton(\u0026#34;跳过此版本\u0026#34;) { dialog, which -\u0026gt; skipThisVersion() } .setIcon(android.R.drawable.ic_dialog_info) .setCancelable(false) .show() } private fun startUpdate() { Toast.makeText(this, \u0026#34;开始更新...\u0026#34;, Toast.LENGTH_SHORT).show() // 执行更新逻辑 } private fun skipThisVersion() { Toast.makeText(this, \u0026#34;跳过此版本\u0026#34;, Toast.LENGTH_SHORT).show() // 记录跳过版本 } } 对话框最佳实践 # 1. 对话框管理 # class DialogManager { private var currentDialog: AlertDialog? = null fun showDialog( context: Context, title: String, message: String, positiveText: String = \u0026#34;确定\u0026#34;, negativeText: String = \u0026#34;取消\u0026#34;, onPositiveClick: (() -\u0026gt; Unit)? = null, onNegativeClick: (() -\u0026gt; Unit)? = null ) { dismissCurrentDialog() currentDialog = AlertDialog.Builder(context) .setTitle(title) .setMessage(message) .setPositiveButton(positiveText) { dialog, which -\u0026gt; onPositiveClick?.invoke() } .setNegativeButton(negativeText) { dialog, which -\u0026gt; onNegativeClick?.invoke() } .setOnDismissListener { currentDialog = null } .show() } fun dismissCurrentDialog() { currentDialog?.dismiss() currentDialog = null } } 2. 对话框工具类 # object DialogUtils { fun showConfirmDialog( context: Context, title: String, message: String, onConfirm: () -\u0026gt; Unit ) { AlertDialog.Builder(context) .setTitle(title) .setMessage(message) .setPositiveButton(\u0026#34;确定\u0026#34;) { dialog, which -\u0026gt; onConfirm() } .setNegativeButton(\u0026#34;取消\u0026#34;) { dialog, which -\u0026gt; // 什么都不做 } .show() } fun showInfoDialog( context: Context, title: String, message: String ) { AlertDialog.Builder(context) .setTitle(title) .setMessage(message) .setPositiveButton(\u0026#34;确定\u0026#34;) { dialog, which -\u0026gt; // 什么都不做 } .show() } fun showErrorDialog( context: Context, title: String = \u0026#34;错误\u0026#34;, message: String ) { AlertDialog.Builder(context) .setTitle(title) .setMessage(message) .setPositiveButton(\u0026#34;确定\u0026#34;) { dialog, which -\u0026gt; // 什么都不做 } .setIcon(android.R.drawable.ic_dialog_alert) .show() } } 📋 总结 # AlertDialog 是 Android 开发中重要的用户交互组件：\n基本用法：标题、内容、按钮设置 多种样式：简单提示、确认对话框、列表选择 自定义布局：支持自定义视图和样式 实际应用：权限请求、错误提示、更新通知等场景 最佳实践：对话框管理、工具类封装 掌握 AlertDialog 的使用方法对于创建良好的用户交互体验至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/13---alertdialog-%E6%B6%88%E6%81%AF%E6%8F%90%E7%A4%BA/","section":"Posts","summary":"详细介绍Android AlertDialog消息提示对话框的使用方法、自定义样式和实际应用场景","title":"AlertDialog 消息提示","type":"posts"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/categories/android/","section":"Categories","summary":"","title":"Android","type":"categories"},{"content":" Android 开发方式 # Android UI 开发主要有两种方式：Java/Kotlin 代码开发和 XML 文件开发。每种方式都有其特点和适用场景。\n开发方式对比 # 1. Java/Kotlin 代码开发 # Java/Kotlin 代码开发是通过编程语言直接创建和配置 UI 组件的方式。\n特点 # 动态性：可以根据运行时条件动态创建和修改 UI 灵活性：可以完全控制组件的创建和配置过程 代码量大：需要编写大量代码来创建和配置 UI 组件 实现步骤 # 创建布局对象（如 LinearLayout、RelativeLayout 等） 定义布局内容（添加子视图） 设置布局属性（宽、高、背景、边距等） 将布局设置为 Activity 的内容视图 代码示例 # class JavaCodeDevelopmentActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 创建主布局 val mainLayout = LinearLayout(this).apply { orientation = LinearLayout.VERTICAL layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT ) setPadding(32, 32, 32, 32) setBackgroundColor(ContextCompat.getColor(this@JavaCodeDevelopmentActivity, R.color.white)) } // 创建标题 val titleText = TextView(this).apply { text = \u0026#34;Java代码开发示例\u0026#34; textSize = 24f setTextColor(ContextCompat.getColor(this@JavaCodeDevelopmentActivity, R.color.black)) gravity = Gravity.CENTER layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT ).apply { bottomMargin = 32 } } // 创建按钮 val button = Button(this).apply { text = \u0026#34;点击我\u0026#34; layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT ).apply { topMargin = 16 } setOnClickListener { Toast.makeText(this@JavaCodeDevelopmentActivity, \u0026#34;按钮被点击了！\u0026#34;, Toast.LENGTH_SHORT).show() } } // 创建输入框 val editText = EditText(this).apply { hint = \u0026#34;请输入内容\u0026#34; layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT ).apply { topMargin = 16 } } // 添加子视图到主布局 mainLayout.addView(titleText) mainLayout.addView(button) mainLayout.addView(editText) // 设置内容视图 setContentView(mainLayout) } } 2. XML 文件开发 # XML 文件开发是通过 XML 标记语言定义 UI 布局的方式。\n特点 # 声明式：通过 XML 标签声明 UI 结构 可视化：可以在 Android Studio 中可视化编辑 代码简洁：XML 语法简洁，易于理解和维护 静态性：布局结构在编译时确定 实现步骤 # 在 res/layout 目录下创建 XML 布局文件 使用 XML 标签定义 UI 组件 设置组件的属性和样式 在 Activity 中加载布局文件 XML 布局示例 # \u0026lt;!-- res/layout/activity_xml_development.xml --\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;32dp\u0026#34; android:background=\u0026#34;@color/white\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;XML文件开发示例\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:layout_marginBottom=\u0026#34;32dp\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;点击我\u0026#34; android:layout_marginTop=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/editText\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入内容\u0026#34; android:layout_marginTop=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Activity 代码 # class XmlDevelopmentActivity : AppCompatActivity() { private lateinit var button: Button private lateinit var editText: EditText override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_xml_development) initViews() setupClickListeners() } private fun initViews() { button = findViewById(R.id.button) editText = findViewById(R.id.editText) } private fun setupClickListeners() { button.setOnClickListener { val inputText = editText.text.toString() if (inputText.isNotEmpty()) { Toast.makeText(this, \u0026#34;输入内容: $inputText\u0026#34;, Toast.LENGTH_SHORT).show() } else { Toast.makeText(this, \u0026#34;请输入内容\u0026#34;, Toast.LENGTH_SHORT).show() } } } } 混合开发方式 # 在实际开发中，通常采用混合方式：XML 定义静态布局，Java/Kotlin 代码处理动态逻辑。\n混合开发示例 # class HybridDevelopmentActivity : AppCompatActivity() { private lateinit var containerLayout: LinearLayout private lateinit var addButton: Button private lateinit var clearButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_hybrid_development) initViews() setupClickListeners() } private fun initViews() { containerLayout = findViewById(R.id.containerLayout) addButton = findViewById(R.id.addButton) clearButton = findViewById(R.id.clearButton) } private fun setupClickListeners() { addButton.setOnClickListener { addDynamicView() } clearButton.setOnClickListener { clearDynamicViews() } } private fun addDynamicView() { // 动态创建视图 val dynamicView = TextView(this).apply { text = \u0026#34;动态添加的视图 ${System.currentTimeMillis()}\u0026#34; textSize = 16f setTextColor(ContextCompat.getColor(this@HybridDevelopmentActivity, R.color.black)) setPadding(16, 16, 16, 16) background = ContextCompat.getDrawable(this@HybridDevelopmentActivity, R.drawable.border_background) layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT ).apply { topMargin = 8 } } containerLayout.addView(dynamicView) } private fun clearDynamicViews() { containerLayout.removeAllViews() } } 混合布局文件 # \u0026lt;!-- res/layout/activity_hybrid_development.xml --\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;16dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;混合开发示例\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/addButton\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;添加视图\u0026#34; android:layout_marginEnd=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/clearButton\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;清除视图\u0026#34; android:layout_marginStart=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/containerLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; /\u0026gt; \u0026lt;/ScrollView\u0026gt; \u0026lt;/LinearLayout\u0026gt; 开发方式选择建议 # 推荐使用 XML 开发的情况 # 静态布局：UI 结构相对固定，不需要动态变化 复杂布局：需要嵌套多个布局容器 团队协作：设计师和开发者可以分工合作 维护性：代码结构清晰，易于维护 推荐使用代码开发的情况 # 动态布局：需要根据数据动态创建 UI 复杂逻辑：需要复杂的条件判断和循环 性能要求：需要精确控制内存和性能 特殊需求：需要实现特殊的 UI 效果 最佳实践 # 1. 布局优化 # class LayoutOptimizationActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_layout_optimization) // 使用 ViewStub 延迟加载 val viewStub = findViewById\u0026lt;ViewStub\u0026gt;(R.id.viewStub) viewStub?.inflate() // 使用 include 标签复用布局 setupIncludeLayout() } private fun setupIncludeLayout() { val includeLayout = findViewById\u0026lt;View\u0026gt;(R.id.includeLayout) val titleText = includeLayout.findViewById\u0026lt;TextView\u0026gt;(R.id.titleText) titleText?.text = \u0026#34;复用的布局\u0026#34; } } 2. 性能优化 # class PerformanceOptimizationActivity : AppCompatActivity() { private lateinit var recyclerView: RecyclerView private lateinit var adapter: OptimizedAdapter override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_performance_optimization) initViews() setupRecyclerView() } private fun initViews() { recyclerView = findViewById(R.id.recyclerView) } private fun setupRecyclerView() { // 使用 RecyclerView 替代 ListView adapter = OptimizedAdapter() recyclerView.adapter = adapter recyclerView.layoutManager = LinearLayoutManager(this) // 设置固定大小优化 recyclerView.setHasFixedSize(true) } } 📋 总结 # Android UI 开发方式的选择：\nXML 开发：适合静态布局，代码简洁，易于维护 代码开发：适合动态布局，灵活性高，但代码量大 混合开发：结合两者优势，是最常用的开发方式 最佳实践：根据具体需求选择合适的开发方式，注重性能优化 在实际开发中，建议优先使用 XML 开发，在需要动态性时再结合代码开发，这样既能保证开发效率，又能满足功能需求。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/01---android-%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F/","section":"Posts","summary":"详细介绍Android UI开发的两种方式：Java代码开发和XML文件开发，以及它们的特点和适用场景","title":"Android 开发方式","type":"posts"},{"content":" ArrayAdapter 数组适配器 # ArrayAdapter 是 Android 中最简单的适配器，用于将数组或列表数据绑定到 ListView 等列表控件上。\nArrayAdapter 基本概念 # ArrayAdapter 是一个简单的适配器，只能用来显示单一的文本内容。它适用于简单的文本列表显示场景。\n构造方法 # ArrayAdapter(Context context, int resource, int textViewResourceId, List\u0026lt;T\u0026gt; objects) 参数 说明 示例 context 环境上下文 this resource 布局资源ID R.layout.list_item textViewResourceId 文本控件ID R.id.textView objects 数据源 listOf(\u0026quot;项目1\u0026quot;, \u0026quot;项目2\u0026quot;) 基本使用示例 # 1. 简单文本列表 # class ArrayAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: ArrayAdapter\u0026lt;String\u0026gt; private val dataList = mutableListOf( \u0026#34;Android开发\u0026#34;, \u0026#34;Kotlin编程\u0026#34;, \u0026#34;Java基础\u0026#34;, \u0026#34;移动开发\u0026#34;, \u0026#34;UI设计\u0026#34;, \u0026#34;数据库\u0026#34;, \u0026#34;网络编程\u0026#34;, \u0026#34;算法\u0026#34; ) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_array_adapter) initViews() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupAdapter() { adapter = ArrayAdapter( this, android.R.layout.simple_list_item_1, android.R.id.text1, dataList ) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val selectedItem = dataList[position] Toast.makeText(this, \u0026#34;选择了: $selectedItem\u0026#34;, Toast.LENGTH_SHORT).show() } listView.onItemLongClickListener = AdapterView.OnItemLongClickListener { _, _, position, _ -\u0026gt; showItemOptions(position) true } } private fun showItemOptions(position: Int) { val item = dataList[position] AlertDialog.Builder(this) .setTitle(\u0026#34;操作选项\u0026#34;) .setMessage(\u0026#34;对 \u0026#39;$item\u0026#39; 执行什么操作？\u0026#34;) .setPositiveButton(\u0026#34;删除\u0026#34;) { _, _ -\u0026gt; removeItem(position) } .setNegativeButton(\u0026#34;编辑\u0026#34;) { _, _ -\u0026gt; editItem(position) } .setNeutralButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } private fun removeItem(position: Int) { dataList.removeAt(position) adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已删除\u0026#34;, Toast.LENGTH_SHORT).show() } private fun editItem(position: Int) { val currentItem = dataList[position] val editText = EditText(this).apply { setText(currentItem) } AlertDialog.Builder(this) .setTitle(\u0026#34;编辑项目\u0026#34;) .setView(editText) .setPositiveButton(\u0026#34;确定\u0026#34;) { _, _ -\u0026gt; val newText = editText.text.toString() if (newText.isNotEmpty()) { dataList[position] = newText adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已更新\u0026#34;, Toast.LENGTH_SHORT).show() } } .setNegativeButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } } 2. 自定义布局适配器 # class CustomArrayAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: ArrayAdapter\u0026lt;String\u0026gt; private lateinit var addButton: Button private val dataList = mutableListOf( \u0026#34;项目1\u0026#34;, \u0026#34;项目2\u0026#34;, \u0026#34;项目3\u0026#34;, \u0026#34;项目4\u0026#34;, \u0026#34;项目5\u0026#34; ) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_custom_array_adapter) initViews() setupCustomAdapter() setupListView() setupAddButton() } private fun initViews() { listView = findViewById(R.id.listView) addButton = findViewById(R.id.addButton) } private fun setupCustomAdapter() { adapter = ArrayAdapter( this, R.layout.custom_list_item, R.id.itemText, dataList ) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val selectedItem = dataList[position] Toast.makeText(this, \u0026#34;选择了: $selectedItem\u0026#34;, Toast.LENGTH_SHORT).show() } } private fun setupAddButton() { addButton.setOnClickListener { addNewItem() } } private fun addNewItem() { val editText = EditText(this).apply { hint = \u0026#34;请输入新项目\u0026#34; } AlertDialog.Builder(this) .setTitle(\u0026#34;添加新项目\u0026#34;) .setView(editText) .setPositiveButton(\u0026#34;添加\u0026#34;) { _, _ -\u0026gt; val newItem = editText.text.toString() if (newItem.isNotEmpty()) { dataList.add(newItem) adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已添加: $newItem\u0026#34;, Toast.LENGTH_SHORT).show() } } .setNegativeButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } } 3. 自定义布局文件 # \u0026lt;!-- res/layout/custom_list_item.xml --\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;?android:attr/selectableItemBackground\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/itemIcon\u0026#34; android:layout_width=\u0026#34;24dp\u0026#34; android:layout_height=\u0026#34;24dp\u0026#34; android:src=\u0026#34;@drawable/ic_item\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/itemText\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textColor=\u0026#34;@android:color/black\u0026#34; /\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/arrowIcon\u0026#34; android:layout_width=\u0026#34;16dp\u0026#34; android:layout_height=\u0026#34;16dp\u0026#34; android:src=\u0026#34;@drawable/ic_arrow_right\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 高级用法示例 # 1. 带过滤功能的适配器 # class FilterableArrayAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var searchEditText: EditText private lateinit var adapter: ArrayAdapter\u0026lt;String\u0026gt; private val originalData = listOf( \u0026#34;Android开发\u0026#34;, \u0026#34;Kotlin编程\u0026#34;, \u0026#34;Java基础\u0026#34;, \u0026#34;移动开发\u0026#34;, \u0026#34;UI设计\u0026#34;, \u0026#34;数据库\u0026#34;, \u0026#34;网络编程\u0026#34;, \u0026#34;算法\u0026#34;, \u0026#34;Android Studio\u0026#34;, \u0026#34;Kotlin协程\u0026#34;, \u0026#34;Java集合\u0026#34;, \u0026#34;移动端开发\u0026#34;, \u0026#34;Material Design\u0026#34;, \u0026#34;SQLite\u0026#34;, \u0026#34;HTTP协议\u0026#34;, \u0026#34;排序算法\u0026#34; ) private val filteredData = mutableListOf\u0026lt;String\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_filterable_array_adapter) initViews() setupAdapter() setupListView() setupSearch() } private fun initViews() { listView = findViewById(R.id.listView) searchEditText = findViewById(R.id.searchEditText) } private fun setupAdapter() { filteredData.addAll(originalData) adapter = ArrayAdapter( this, android.R.layout.simple_list_item_1, android.R.id.text1, filteredData ) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val selectedItem = filteredData[position] Toast.makeText(this, \u0026#34;选择了: $selectedItem\u0026#34;, Toast.LENGTH_SHORT).show() } } private fun setupSearch() { searchEditText.addTextChangedListener(object : TextWatcher { override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {} override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { filterData(s.toString()) } override fun afterTextChanged(s: Editable?) {} }) } private fun filterData(query: String) { filteredData.clear() if (query.isEmpty()) { filteredData.addAll(originalData) } else { originalData.forEach { item -\u0026gt; if (item.contains(query, ignoreCase = true)) { filteredData.add(item) } } } adapter.notifyDataSetChanged() } } 2. 多选列表适配器 # class MultiSelectArrayAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: ArrayAdapter\u0026lt;String\u0026gt; private lateinit var selectAllButton: Button private lateinit var clearAllButton: Button private lateinit var selectedCountText: TextView private val dataList = mutableListOf( \u0026#34;选项1\u0026#34;, \u0026#34;选项2\u0026#34;, \u0026#34;选项3\u0026#34;, \u0026#34;选项4\u0026#34;, \u0026#34;选项5\u0026#34;, \u0026#34;选项6\u0026#34;, \u0026#34;选项7\u0026#34;, \u0026#34;选项8\u0026#34;, \u0026#34;选项9\u0026#34;, \u0026#34;选项10\u0026#34; ) private val selectedItems = mutableSetOf\u0026lt;Int\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_multi_select_array_adapter) initViews() setupAdapter() setupListView() setupButtons() } private fun initViews() { listView = findViewById(R.id.listView) selectAllButton = findViewById(R.id.selectAllButton) clearAllButton = findViewById(R.id.clearAllButton) selectedCountText = findViewById(R.id.selectedCountText) } private fun setupAdapter() { adapter = ArrayAdapter( this, android.R.layout.simple_list_item_multiple_choice, android.R.id.text1, dataList ) } private fun setupListView() { listView.adapter = adapter listView.choiceMode = ListView.CHOICE_MODE_MULTIPLE listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; if (selectedItems.contains(position)) { selectedItems.remove(position) } else { selectedItems.add(position) } updateSelectedCount() } updateSelectedCount() } private fun setupButtons() { selectAllButton.setOnClickListener { selectAllItems() } clearAllButton.setOnClickListener { clearAllItems() } } private fun selectAllItems() { selectedItems.clear() for (i in dataList.indices) { selectedItems.add(i) listView.setItemChecked(i, true) } updateSelectedCount() } private fun clearAllItems() { selectedItems.clear() for (i in dataList.indices) { listView.setItemChecked(i, false) } updateSelectedCount() } private fun updateSelectedCount() { selectedCountText.text = \u0026#34;已选择: ${selectedItems.size} 项\u0026#34; } } 实际应用场景 # 1. 设置列表 # class SettingsListActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: ArrayAdapter\u0026lt;String\u0026gt; private val settingsItems = listOf( \u0026#34;账户设置\u0026#34;, \u0026#34;隐私设置\u0026#34;, \u0026#34;通知设置\u0026#34;, \u0026#34;语言设置\u0026#34;, \u0026#34;主题设置\u0026#34;, \u0026#34;存储设置\u0026#34;, \u0026#34;关于应用\u0026#34;, \u0026#34;帮助与反馈\u0026#34; ) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_settings_list) initViews() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupAdapter() { adapter = ArrayAdapter( this, R.layout.settings_list_item, R.id.settingText, settingsItems ) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val settingItem = settingsItems[position] openSettingDetail(settingItem) } } private fun openSettingDetail(setting: String) { Toast.makeText(this, \u0026#34;打开: $setting\u0026#34;, Toast.LENGTH_SHORT).show() // 根据设置项打开对应的设置页面 } } 2. 历史记录列表 # class HistoryListActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: ArrayAdapter\u0026lt;String\u0026gt; private lateinit var clearHistoryButton: Button private val historyList = mutableListOf\u0026lt;String\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_history_list) initViews() loadHistory() setupAdapter() setupListView() setupClearButton() } private fun initViews() { listView = findViewById(R.id.listView) clearHistoryButton = findViewById(R.id.clearHistoryButton) } private fun loadHistory() { // 模拟加载历史记录 historyList.addAll(listOf( \u0026#34;Android开发教程\u0026#34;, \u0026#34;Kotlin基础语法\u0026#34;, \u0026#34;Java集合框架\u0026#34;, \u0026#34;移动端UI设计\u0026#34;, \u0026#34;数据库操作\u0026#34; )) } private fun setupAdapter() { adapter = ArrayAdapter( this, R.layout.history_list_item, R.id.historyText, historyList ) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val historyItem = historyList[position] openHistoryItem(historyItem) } listView.onItemLongClickListener = AdapterView.OnItemLongClickListener { _, _, position, _ -\u0026gt; showHistoryOptions(position) true } } private fun setupClearButton() { clearHistoryButton.setOnClickListener { clearHistory() } } private fun openHistoryItem(item: String) { Toast.makeText(this, \u0026#34;打开: $item\u0026#34;, Toast.LENGTH_SHORT).show() // 打开历史记录项 } private fun showHistoryOptions(position: Int) { val item = historyList[position] AlertDialog.Builder(this) .setTitle(\u0026#34;历史记录选项\u0026#34;) .setMessage(\u0026#34;对 \u0026#39;$item\u0026#39; 执行什么操作？\u0026#34;) .setPositiveButton(\u0026#34;删除\u0026#34;) { _, _ -\u0026gt; removeHistoryItem(position) } .setNegativeButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } private fun removeHistoryItem(position: Int) { historyList.removeAt(position) adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已删除\u0026#34;, Toast.LENGTH_SHORT).show() } private fun clearHistory() { AlertDialog.Builder(this) .setTitle(\u0026#34;清除历史记录\u0026#34;) .setMessage(\u0026#34;确定要清除所有历史记录吗？\u0026#34;) .setPositiveButton(\u0026#34;确定\u0026#34;) { _, _ -\u0026gt; historyList.clear() adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已清除所有历史记录\u0026#34;, Toast.LENGTH_SHORT).show() } .setNegativeButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } } ArrayAdapter 最佳实践 # 1. 适配器工具类 # object ArrayAdapterUtils { fun createSimpleAdapter( context: Context, data: List\u0026lt;String\u0026gt; ): ArrayAdapter\u0026lt;String\u0026gt; { return ArrayAdapter( context, android.R.layout.simple_list_item_1, android.R.id.text1, data ) } fun createCustomAdapter( context: Context, layoutRes: Int, textViewResId: Int, data: List\u0026lt;String\u0026gt; ): ArrayAdapter\u0026lt;String\u0026gt; { return ArrayAdapter( context, layoutRes, textViewResId, data ) } fun createFilterableAdapter( context: Context, data: List\u0026lt;String\u0026gt; ): ArrayAdapter\u0026lt;String\u0026gt; { return object : ArrayAdapter\u0026lt;String\u0026gt;( context, android.R.layout.simple_list_item_1, android.R.id.text1, data ) { override fun getFilter(): Filter { return object : Filter() { override fun performFiltering(constraint: CharSequence?): FilterResults { val results = FilterResults() val filteredList = mutableListOf\u0026lt;String\u0026gt;() if (constraint.isNullOrEmpty()) { filteredList.addAll(data) } else { data.forEach { item -\u0026gt; if (item.contains(constraint, ignoreCase = true)) { filteredList.add(item) } } } results.values = filteredList results.count = filteredList.size return results } override fun publishResults(constraint: CharSequence?, results: FilterResults?) { clear() if (results != null) { addAll(results.values as List\u0026lt;String\u0026gt;) notifyDataSetChanged() } } } } } } } 2. 适配器管理类 # class AdapterManager\u0026lt;T\u0026gt; { private var adapter: ArrayAdapter\u0026lt;T\u0026gt;? = null private var dataList = mutableListOf\u0026lt;T\u0026gt;() fun createAdapter( context: Context, layoutRes: Int, textViewResId: Int ): ArrayAdapter\u0026lt;T\u0026gt; { adapter = ArrayAdapter(context, layoutRes, textViewResId, dataList) return adapter!! } fun addItem(item: T) { dataList.add(item) adapter?.notifyDataSetChanged() } fun removeItem(position: Int) { if (position in 0 until dataList.size) { dataList.removeAt(position) adapter?.notifyDataSetChanged() } } fun updateItem(position: Int, item: T) { if (position in 0 until dataList.size) { dataList[position] = item adapter?.notifyDataSetChanged() } } fun clearAll() { dataList.clear() adapter?.notifyDataSetChanged() } fun getItem(position: Int): T? { return if (position in 0 until dataList.size) dataList[position] else null } fun getItemCount(): Int = dataList.size } 📋 总结 # ArrayAdapter 是 Android 开发中最简单的适配器：\n基本用法：简单的文本列表显示 自定义布局：支持自定义列表项布局 过滤功能：支持数据过滤和搜索 多选功能：支持多选列表 实际应用：设置列表、历史记录、简单菜单等场景 最佳实践：工具类封装、适配器管理 掌握 ArrayAdapter 的使用方法对于创建简单的列表界面至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/15---arrayadapter-%E6%95%B0%E7%BB%84%E9%80%82%E9%85%8D%E5%99%A8/","section":"Posts","summary":"详细介绍Android ArrayAdapter数组适配器的使用方法、自定义样式和实际应用场景","title":"ArrayAdapter 数组适配器","type":"posts"},{"content":" BaseAdapter 基础单一元素 # BaseAdapter 是 Android 中所有适配器的基类，提供了最大的灵活性，可以完全自定义列表项的显示和交互。\nBaseAdapter 基本概念 # BaseAdapter 是所有适配器的抽象基类，与 SimpleAdapter 的区别在于可以完全自定义每个列表项的内容和样式。它提供了最大的灵活性，但需要更多的代码实现。\n核心方法 # 方法 说明 返回值 getCount() 返回数据项数量 Int getItem(position) 返回指定位置的数据项 Any? getItemId(position) 返回指定位置的数据项ID Long getView(position, convertView, parent) 创建或复用列表项视图 View 基本使用示例 # 1. 简单BaseAdapter实现 # class BaseAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: CustomBaseAdapter private val dataList = mutableListOf\u0026lt;String\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_base_adapter) initViews() setupData() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupData() { dataList.addAll(listOf( \u0026#34;Android开发\u0026#34;, \u0026#34;Kotlin编程\u0026#34;, \u0026#34;Java基础\u0026#34;, \u0026#34;移动开发\u0026#34;, \u0026#34;UI设计\u0026#34;, \u0026#34;数据库\u0026#34;, \u0026#34;网络编程\u0026#34;, \u0026#34;算法\u0026#34; )) } private fun setupAdapter() { adapter = CustomBaseAdapter(this, dataList) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val selectedItem = dataList[position] Toast.makeText(this, \u0026#34;选择了: $selectedItem\u0026#34;, Toast.LENGTH_SHORT).show() } listView.onItemLongClickListener = AdapterView.OnItemLongClickListener { _, _, position, _ -\u0026gt; showItemOptions(position) true } } private fun showItemOptions(position: Int) { val item = dataList[position] AlertDialog.Builder(this) .setTitle(\u0026#34;操作选项\u0026#34;) .setMessage(\u0026#34;对 \u0026#39;$item\u0026#39; 执行什么操作？\u0026#34;) .setPositiveButton(\u0026#34;编辑\u0026#34;) { _, _ -\u0026gt; editItem(position) } .setNegativeButton(\u0026#34;删除\u0026#34;) { _, _ -\u0026gt; removeItem(position) } .setNeutralButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } private fun editItem(position: Int) { val currentItem = dataList[position] val editText = EditText(this).apply { setText(currentItem) } AlertDialog.Builder(this) .setTitle(\u0026#34;编辑项目\u0026#34;) .setView(editText) .setPositiveButton(\u0026#34;确定\u0026#34;) { _, _ -\u0026gt; val newText = editText.text.toString() if (newText.isNotEmpty()) { dataList[position] = newText adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已更新\u0026#34;, Toast.LENGTH_SHORT).show() } } .setNegativeButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } private fun removeItem(position: Int) { dataList.removeAt(position) adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已删除\u0026#34;, Toast.LENGTH_SHORT).show() } } class CustomBaseAdapter( private val context: Context, private val dataList: MutableList\u0026lt;String\u0026gt; ) : BaseAdapter() { override fun getCount(): Int = dataList.size override fun getItem(position: Int): Any? = dataList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view: View val holder: ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.base_adapter_item, parent, false) holder = ViewHolder(view) view.tag = holder } else { view = convertView holder = view.tag as ViewHolder } val item = dataList[position] holder.titleText.text = item holder.subtitleText.text = \u0026#34;这是第 ${position + 1} 个项目\u0026#34; // 根据位置设置不同的背景色 when (position % 3) { 0 -\u0026gt; holder.container.setBackgroundColor(ContextCompat.getColor(context, R.color.colorPrimary)) 1 -\u0026gt; holder.container.setBackgroundColor(ContextCompat.getColor(context, R.color.colorAccent)) 2 -\u0026gt; holder.container.setBackgroundColor(ContextCompat.getColor(context, R.color.colorSecondary)) } return view } private class ViewHolder(view: View) { val container: LinearLayout = view.findViewById(R.id.container) val titleText: TextView = view.findViewById(R.id.titleText) val subtitleText: TextView = view.findViewById(R.id.subtitleText) } } 2. 自定义布局文件 # \u0026lt;!-- res/layout/base_adapter_item.xml --\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/container\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;?android:attr/selectableItemBackground\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iconImage\u0026#34; android:layout_width=\u0026#34;48dp\u0026#34; android:layout_height=\u0026#34;48dp\u0026#34; android:src=\u0026#34;@drawable/ic_default\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/titleText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:textColor=\u0026#34;@android:color/white\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/subtitleText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;@android:color/white\u0026#34; android:alpha=\u0026#34;0.8\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/arrowImage\u0026#34; android:layout_width=\u0026#34;24dp\u0026#34; android:layout_height=\u0026#34;24dp\u0026#34; android:src=\u0026#34;@drawable/ic_arrow_right\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:tint=\u0026#34;@android:color/white\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 3. 复杂数据模型BaseAdapter # class ComplexBaseAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: ComplexBaseAdapter private val dataList = mutableListOf\u0026lt;ContactItem\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_complex_base_adapter) initViews() setupData() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupData() { dataList.addAll(listOf( ContactItem(\u0026#34;张三\u0026#34;, \u0026#34;13800138000\u0026#34;, \u0026#34;zhangsan@example.com\u0026#34;, true), ContactItem(\u0026#34;李四\u0026#34;, \u0026#34;13800138001\u0026#34;, \u0026#34;lisi@example.com\u0026#34;, false), ContactItem(\u0026#34;王五\u0026#34;, \u0026#34;13800138002\u0026#34;, \u0026#34;wangwu@example.com\u0026#34;, true), ContactItem(\u0026#34;赵六\u0026#34;, \u0026#34;13800138003\u0026#34;, \u0026#34;zhaoliu@example.com\u0026#34;, false), ContactItem(\u0026#34;钱七\u0026#34;, \u0026#34;13800138004\u0026#34;, \u0026#34;qianqi@example.com\u0026#34;, true) )) } private fun setupAdapter() { adapter = ComplexBaseAdapter(this, dataList) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val contact = dataList[position] showContactDetail(contact) } } private fun showContactDetail(contact: ContactItem) { AlertDialog.Builder(this) .setTitle(\u0026#34;联系人详情\u0026#34;) .setMessage(\u0026#34;姓名: ${contact.name}\\n电话: ${contact.phone}\\n邮箱: ${contact.email}\\n状态: ${if (contact.isOnline) \u0026#34;在线\u0026#34; else \u0026#34;离线\u0026#34;}\u0026#34;) .setPositiveButton(\u0026#34;确定\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } } data class ContactItem( val name: String, val phone: String, val email: String, val isOnline: Boolean ) class ComplexBaseAdapter( private val context: Context, private val dataList: MutableList\u0026lt;ContactItem\u0026gt; ) : BaseAdapter() { override fun getCount(): Int = dataList.size override fun getItem(position: Int): ContactItem = dataList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view: View val holder: ContactViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.contact_item, parent, false) holder = ContactViewHolder(view) view.tag = holder } else { view = convertView holder = view.tag as ContactViewHolder } val contact = dataList[position] holder.nameText.text = contact.name holder.phoneText.text = contact.phone holder.emailText.text = contact.email // 设置在线状态 if (contact.isOnline) { holder.statusIndicator.setBackgroundColor(ContextCompat.getColor(context, R.color.online_color)) holder.statusText.text = \u0026#34;在线\u0026#34; holder.statusText.setTextColor(ContextCompat.getColor(context, R.color.online_color)) } else { holder.statusIndicator.setBackgroundColor(ContextCompat.getColor(context, R.color.offline_color)) holder.statusText.text = \u0026#34;离线\u0026#34; holder.statusText.setTextColor(ContextCompat.getColor(context, R.color.offline_color)) } // 设置头像 holder.avatarImage.setImageResource( when (position % 4) { 0 -\u0026gt; android.R.drawable.ic_menu_myplaces 1 -\u0026gt; android.R.drawable.ic_menu_camera 2 -\u0026gt; android.R.drawable.ic_menu_send else -\u0026gt; android.R.drawable.ic_menu_share } ) return view } private class ContactViewHolder(view: View) { val container: LinearLayout = view.findViewById(R.id.container) val avatarImage: ImageView = view.findViewById(R.id.avatarImage) val nameText: TextView = view.findViewById(R.id.nameText) val phoneText: TextView = view.findViewById(R.id.phoneText) val emailText: TextView = view.findViewById(R.id.emailText) val statusIndicator: View = view.findViewById(R.id.statusIndicator) val statusText: TextView = view.findViewById(R.id.statusText) } } 4. 复杂布局文件 # \u0026lt;!-- res/layout/contact_item.xml --\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/container\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;?android:attr/selectableItemBackground\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/avatarImage\u0026#34; android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:src=\u0026#34;@drawable/ic_default_avatar\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; android:background=\u0026#34;@drawable/circle_background\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/nameText\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:textColor=\u0026#34;@android:color/black\u0026#34; /\u0026gt; \u0026lt;View android:id=\u0026#34;@+id/statusIndicator\u0026#34; android:layout_width=\u0026#34;12dp\u0026#34; android:layout_height=\u0026#34;12dp\u0026#34; android:layout_marginEnd=\u0026#34;8dp\u0026#34; android:background=\u0026#34;@drawable/circle_background\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/statusText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/phoneText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;@android:color/darker_gray\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/emailText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; android:textColor=\u0026#34;@android:color/darker_gray\u0026#34; android:layout_marginTop=\u0026#34;2dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 高级用法示例 # 1. 多类型列表项 # class MultiTypeBaseAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: MultiTypeBaseAdapter private val dataList = mutableListOf\u0026lt;Any\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_multi_type_base_adapter) initViews() setupData() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupData() { dataList.addAll(listOf( HeaderItem(\u0026#34;联系人\u0026#34;), ContactItem(\u0026#34;张三\u0026#34;, \u0026#34;13800138000\u0026#34;, \u0026#34;zhangsan@example.com\u0026#34;, true), ContactItem(\u0026#34;李四\u0026#34;, \u0026#34;13800138001\u0026#34;, \u0026#34;lisi@example.com\u0026#34;, false), HeaderItem(\u0026#34;群组\u0026#34;), GroupItem(\u0026#34;工作群\u0026#34;, \u0026#34;5人\u0026#34;, \u0026#34;最新消息：明天开会\u0026#34;), GroupItem(\u0026#34;朋友群\u0026#34;, \u0026#34;8人\u0026#34;, \u0026#34;最新消息：周末聚餐\u0026#34;), HeaderItem(\u0026#34;最近聊天\u0026#34;), RecentChatItem(\u0026#34;王五\u0026#34;, \u0026#34;你好，最近怎么样？\u0026#34;, \u0026#34;10:30\u0026#34;, 2), RecentChatItem(\u0026#34;赵六\u0026#34;, \u0026#34;好的，没问题\u0026#34;, \u0026#34;09:15\u0026#34;, 0) )) } private fun setupAdapter() { adapter = MultiTypeBaseAdapter(this, dataList) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val item = dataList[position] when (item) { is ContactItem -\u0026gt; showContactDetail(item) is GroupItem -\u0026gt; showGroupDetail(item) is RecentChatItem -\u0026gt; showChatDetail(item) else -\u0026gt; Toast.makeText(this, \u0026#34;点击了标题\u0026#34;, Toast.LENGTH_SHORT).show() } } } private fun showContactDetail(contact: ContactItem) { Toast.makeText(this, \u0026#34;联系人: ${contact.name}\u0026#34;, Toast.LENGTH_SHORT).show() } private fun showGroupDetail(group: GroupItem) { Toast.makeText(this, \u0026#34;群组: ${group.name}\u0026#34;, Toast.LENGTH_SHORT).show() } private fun showChatDetail(chat: RecentChatItem) { Toast.makeText(this, \u0026#34;聊天: ${chat.name}\u0026#34;, Toast.LENGTH_SHORT).show() } } data class HeaderItem(val title: String) data class GroupItem(val name: String, val memberCount: String, val lastMessage: String) data class RecentChatItem(val name: String, val lastMessage: String, val time: String, val unreadCount: Int) class MultiTypeBaseAdapter( private val context: Context, private val dataList: MutableList\u0026lt;Any\u0026gt; ) : BaseAdapter() { companion object { private const val TYPE_HEADER = 0 private const val TYPE_CONTACT = 1 private const val TYPE_GROUP = 2 private const val TYPE_RECENT_CHAT = 3 } override fun getCount(): Int = dataList.size override fun getItem(position: Int): Any = dataList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getViewTypeCount(): Int = 4 override fun getItemViewType(position: Int): Int { return when (dataList[position]) { is HeaderItem -\u0026gt; TYPE_HEADER is ContactItem -\u0026gt; TYPE_CONTACT is GroupItem -\u0026gt; TYPE_GROUP is RecentChatItem -\u0026gt; TYPE_RECENT_CHAT else -\u0026gt; TYPE_HEADER } } override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val item = dataList[position] val viewType = getItemViewType(position) when (viewType) { TYPE_HEADER -\u0026gt; { val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.header_item, parent, false) val holder = view.tag as? HeaderViewHolder ?: HeaderViewHolder(view).also { view.tag = it } val header = item as HeaderItem holder.titleText.text = header.title return view } TYPE_CONTACT -\u0026gt; { val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.contact_item, parent, false) val holder = view.tag as? ContactViewHolder ?: ContactViewHolder(view).also { view.tag = it } val contact = item as ContactItem holder.nameText.text = contact.name holder.phoneText.text = contact.phone holder.emailText.text = contact.email return view } TYPE_GROUP -\u0026gt; { val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.group_item, parent, false) val holder = view.tag as? GroupViewHolder ?: GroupViewHolder(view).also { view.tag = it } val group = item as GroupItem holder.nameText.text = group.name holder.memberCountText.text = group.memberCount holder.lastMessageText.text = group.lastMessage return view } TYPE_RECENT_CHAT -\u0026gt; { val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.recent_chat_item, parent, false) val holder = view.tag as? RecentChatViewHolder ?: RecentChatViewHolder(view).also { view.tag = it } val chat = item as RecentChatItem holder.nameText.text = chat.name holder.lastMessageText.text = chat.lastMessage holder.timeText.text = chat.time holder.unreadCountText.text = if (chat.unreadCount \u0026gt; 0) chat.unreadCount.toString() else \u0026#34;\u0026#34; return view } else -\u0026gt; return convertView ?: View(context) } } private class HeaderViewHolder(view: View) { val titleText: TextView = view.findViewById(R.id.titleText) } private class ContactViewHolder(view: View) { val nameText: TextView = view.findViewById(R.id.nameText) val phoneText: TextView = view.findViewById(R.id.phoneText) val emailText: TextView = view.findViewById(R.id.emailText) } private class GroupViewHolder(view: View) { val nameText: TextView = view.findViewById(R.id.nameText) val memberCountText: TextView = view.findViewById(R.id.memberCountText) val lastMessageText: TextView = view.findViewById(R.id.lastMessageText) } private class RecentChatViewHolder(view: View) { val nameText: TextView = view.findViewById(R.id.nameText) val lastMessageText: TextView = view.findViewById(R.id.lastMessageText) val timeText: TextView = view.findViewById(R.id.timeText) val unreadCountText: TextView = view.findViewById(R.id.unreadCountText) } } 2. 动态数据更新 # class DynamicBaseAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: DynamicBaseAdapter private lateinit var addButton: Button private lateinit var refreshButton: Button private val dataList = mutableListOf\u0026lt;String\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_dynamic_base_adapter) initViews() setupInitialData() setupAdapter() setupListView() setupButtons() } private fun initViews() { listView = findViewById(R.id.listView) addButton = findViewById(R.id.addButton) refreshButton = findViewById(R.id.refreshButton) } private fun setupInitialData() { dataList.addAll(listOf( \u0026#34;初始项目1\u0026#34;, \u0026#34;初始项目2\u0026#34;, \u0026#34;初始项目3\u0026#34; )) } private fun setupAdapter() { adapter = DynamicBaseAdapter(this, dataList) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val item = dataList[position] Toast.makeText(this, \u0026#34;选择了: $item\u0026#34;, Toast.LENGTH_SHORT).show() } } private fun setupButtons() { addButton.setOnClickListener { addNewItem() } refreshButton.setOnClickListener { refreshData() } } private fun addNewItem() { val editText = EditText(this).apply { hint = \u0026#34;请输入新项目\u0026#34; } AlertDialog.Builder(this) .setTitle(\u0026#34;添加新项目\u0026#34;) .setView(editText) .setPositiveButton(\u0026#34;添加\u0026#34;) { _, _ -\u0026gt; val newItem = editText.text.toString() if (newItem.isNotEmpty()) { dataList.add(newItem) adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已添加: $newItem\u0026#34;, Toast.LENGTH_SHORT).show() } } .setNegativeButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } private fun refreshData() { dataList.clear() setupInitialData() // 添加一些随机数据 repeat(5) { index -\u0026gt; dataList.add(\u0026#34;刷新项目${index + 1}\u0026#34;) } adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;数据已刷新\u0026#34;, Toast.LENGTH_SHORT).show() } } class DynamicBaseAdapter( private val context: Context, private val dataList: MutableList\u0026lt;String\u0026gt; ) : BaseAdapter() { override fun getCount(): Int = dataList.size override fun getItem(position: Int): String = dataList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view: View val holder: DynamicViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.dynamic_item, parent, false) holder = DynamicViewHolder(view) view.tag = holder } else { view = convertView holder = view.tag as DynamicViewHolder } val item = dataList[position] holder.titleText.text = item holder.subtitleText.text = \u0026#34;位置: $position, 时间: ${System.currentTimeMillis()}\u0026#34; // 根据位置设置不同的样式 when (position % 4) { 0 -\u0026gt; { holder.container.setBackgroundColor(ContextCompat.getColor(context, R.color.colorPrimary)) holder.titleText.setTextColor(ContextCompat.getColor(context, android.R.color.white)) holder.subtitleText.setTextColor(ContextCompat.getColor(context, android.R.color.white)) } 1 -\u0026gt; { holder.container.setBackgroundColor(ContextCompat.getColor(context, R.color.colorAccent)) holder.titleText.setTextColor(ContextCompat.getColor(context, android.R.color.white)) holder.subtitleText.setTextColor(ContextCompat.getColor(context, android.R.color.white)) } 2 -\u0026gt; { holder.container.setBackgroundColor(ContextCompat.getColor(context, R.color.colorSecondary)) holder.titleText.setTextColor(ContextCompat.getColor(context, android.R.color.white)) holder.subtitleText.setTextColor(ContextCompat.getColor(context, android.R.color.white)) } else -\u0026gt; { holder.container.setBackgroundColor(ContextCompat.getColor(context, android.R.color.white)) holder.titleText.setTextColor(ContextCompat.getColor(context, android.R.color.black)) holder.subtitleText.setTextColor(ContextCompat.getColor(context, android.R.color.black)) } } return view } private class DynamicViewHolder(view: View) { val container: LinearLayout = view.findViewById(R.id.container) val titleText: TextView = view.findViewById(R.id.titleText) val subtitleText: TextView = view.findViewById(R.id.subtitleText) } } 实际应用场景 # 1. 聊天消息列表 # class ChatMessageActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: ChatMessageAdapter private val messageList = mutableListOf\u0026lt;ChatMessage\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_chat_message) initViews() setupData() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupData() { messageList.addAll(listOf( ChatMessage(\u0026#34;张三\u0026#34;, \u0026#34;你好，最近怎么样？\u0026#34;, \u0026#34;10:30\u0026#34;, true), ChatMessage(\u0026#34;我\u0026#34;, \u0026#34;还不错，你呢？\u0026#34;, \u0026#34;10:32\u0026#34;, false), ChatMessage(\u0026#34;张三\u0026#34;, \u0026#34;我也很好，明天见面吧\u0026#34;, \u0026#34;10:35\u0026#34;, true), ChatMessage(\u0026#34;我\u0026#34;, \u0026#34;好的，没问题\u0026#34;, \u0026#34;10:36\u0026#34;, false), ChatMessage(\u0026#34;张三\u0026#34;, \u0026#34;那就这样定了\u0026#34;, \u0026#34;10:37\u0026#34;, true) )) } private fun setupAdapter() { adapter = ChatMessageAdapter(this, messageList) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val message = messageList[position] Toast.makeText(this, \u0026#34;消息: ${message.content}\u0026#34;, Toast.LENGTH_SHORT).show() } } } data class ChatMessage( val sender: String, val content: String, val time: String, val isFromMe: Boolean ) class ChatMessageAdapter( private val context: Context, private val messageList: MutableList\u0026lt;ChatMessage\u0026gt; ) : BaseAdapter() { override fun getCount(): Int = messageList.size override fun getItem(position: Int): ChatMessage = messageList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val message = messageList[position] val view: View val holder: ChatMessageViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.chat_message_item, parent, false) holder = ChatMessageViewHolder(view) view.tag = holder } else { view = convertView holder = view.tag as ChatMessageViewHolder } holder.senderText.text = message.sender holder.contentText.text = message.content holder.timeText.text = message.time // 根据消息来源设置不同的样式 if (message.isFromMe) { holder.messageContainer.setBackgroundColor(ContextCompat.getColor(context, R.color.my_message_bg)) holder.senderText.setTextColor(ContextCompat.getColor(context, R.color.my_message_text)) holder.contentText.setTextColor(ContextCompat.getColor(context, R.color.my_message_text)) } else { holder.messageContainer.setBackgroundColor(ContextCompat.getColor(context, R.color.other_message_bg)) holder.senderText.setTextColor(ContextCompat.getColor(context, R.color.other_message_text)) holder.contentText.setTextColor(ContextCompat.getColor(context, R.color.other_message_text)) } return view } private class ChatMessageViewHolder(view: View) { val messageContainer: LinearLayout = view.findViewById(R.id.messageContainer) val senderText: TextView = view.findViewById(R.id.senderText) val contentText: TextView = view.findViewById(R.id.contentText) val timeText: TextView = view.findViewById(R.id.timeText) } } BaseAdapter 最佳实践 # 1. ViewHolder模式 # abstract class BaseViewHolder { abstract fun bindData(data: Any) } class ContactViewHolder(view: View) : BaseViewHolder() { val nameText: TextView = view.findViewById(R.id.nameText) val phoneText: TextView = view.findViewById(R.id.phoneText) val emailText: TextView = view.findViewById(R.id.emailText) override fun bindData(data: Any) { if (data is ContactItem) { nameText.text = data.name phoneText.text = data.phone emailText.text = data.email } } } 2. 适配器工具类 # object BaseAdapterUtils { fun \u0026lt;T\u0026gt; createSimpleAdapter( context: Context, data: List\u0026lt;T\u0026gt;, layoutRes: Int, bindView: (View, T, Int) -\u0026gt; Unit ): BaseAdapter { return object : BaseAdapter() { override fun getCount(): Int = data.size override fun getItem(position: Int): T = data[position] override fun getItemId(position: Int): Long = position.toLong() override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view = convertView ?: LayoutInflater.from(context).inflate(layoutRes, parent, false) bindView(view, data[position], position) return view } } } fun createContactAdapter( context: Context, contacts: List\u0026lt;ContactItem\u0026gt; ): BaseAdapter { return createSimpleAdapter(context, contacts, R.layout.contact_item) { view, contact, position -\u0026gt; val nameText = view.findViewById\u0026lt;TextView\u0026gt;(R.id.nameText) val phoneText = view.findViewById\u0026lt;TextView\u0026gt;(R.id.phoneText) val emailText = view.findViewById\u0026lt;TextView\u0026gt;(R.id.emailText) nameText.text = contact.name phoneText.text = contact.phone emailText.text = contact.email } } } 📋 总结 # BaseAdapter 是 Android 开发中最灵活的适配器：\n最大灵活性：完全自定义列表项内容和样式 ViewHolder模式：提高性能，减少findViewById调用 多类型支持：支持不同类型的列表项 动态更新：支持数据的动态添加、删除、修改 实际应用：聊天消息、复杂列表、多类型数据等场景 最佳实践：ViewHolder模式、工具类封装 掌握 BaseAdapter 的使用方法对于创建高度自定义的列表界面至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/18---baseadapter-%E5%9F%BA%E7%A1%80%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/","section":"Posts","summary":"详细介绍Android BaseAdapter的使用方法、自定义实现和ViewHolder模式","title":"BaseAdapter 基础单一元素","type":"posts"},{"content":" Button 按钮控件 # Button 是 Android 中最常用的交互控件，继承自 TextView，用于响应用户的点击操作。\nButton 基本属性 # \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;点击我\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textColor=\u0026#34;#FFFFFF\u0026#34; android:background=\u0026#34;@drawable/button_background\u0026#34; android:padding=\u0026#34;12dp\u0026#34; android:layout_margin=\u0026#34;8dp\u0026#34; /\u0026gt; 点击事件实现方式 # Android 提供了四种实现 Button 点击事件的方式：\n1. 自定义内部类实现 # class MainActivity : AppCompatActivity() { private lateinit var button: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupButton() } private fun initViews() { button = findViewById(R.id.button) } private fun setupButton() { // 创建自定义点击监听器 val myOnClickListener = MyOnClickListener() button.setOnClickListener(myOnClickListener) } // 自定义内部类 inner class MyOnClickListener : View.OnClickListener { override fun onClick(v: View?) { when (v?.id) { R.id.button -\u0026gt; { Toast.makeText(this@MainActivity, \u0026#34;按钮被点击了\u0026#34;, Toast.LENGTH_SHORT).show() Log.d(\u0026#34;Button\u0026#34;, \u0026#34;自定义内部类实现点击事件\u0026#34;) } } } } } 2. 匿名内部类实现 # class MainActivity : AppCompatActivity() { private lateinit var button: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupButton() } private fun initViews() { button = findViewById(R.id.button) } private fun setupButton() { // 使用匿名内部类 button.setOnClickListener(object : View.OnClickListener { override fun onClick(v: View?) { Toast.makeText(this@MainActivity, \u0026#34;匿名内部类实现点击事件\u0026#34;, Toast.LENGTH_SHORT).show() Log.d(\u0026#34;Button\u0026#34;, \u0026#34;匿名内部类实现\u0026#34;) } }) } } 3. Lambda 表达式实现（推荐） # class MainActivity : AppCompatActivity() { private lateinit var button: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupButton() } private fun initViews() { button = findViewById(R.id.button) } private fun setupButton() { // 使用 Lambda 表达式（最简洁的方式） button.setOnClickListener { Toast.makeText(this, \u0026#34;Lambda表达式实现点击事件\u0026#34;, Toast.LENGTH_SHORT).show() Log.d(\u0026#34;Button\u0026#34;, \u0026#34;Lambda表达式实现\u0026#34;) // 可以在这里添加更多逻辑 handleButtonClick() } } private fun handleButtonClick() { // 处理按钮点击的业务逻辑 val currentTime = System.currentTimeMillis() Log.d(\u0026#34;Button\u0026#34;, \u0026#34;点击时间：$currentTime\u0026#34;) } } 4. 实现接口方式 # class MainActivity : AppCompatActivity(), View.OnClickListener { private lateinit var button: Button private lateinit var button2: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupButtons() } private fun initViews() { button = findViewById(R.id.button) button2 = findViewById(R.id.button2) } private fun setupButtons() { // 设置点击监听器为当前Activity button.setOnClickListener(this) button2.setOnClickListener(this) } override fun onClick(v: View?) { when (v?.id) { R.id.button -\u0026gt; { Toast.makeText(this, \u0026#34;第一个按钮被点击\u0026#34;, Toast.LENGTH_SHORT).show() Log.d(\u0026#34;Button\u0026#34;, \u0026#34;第一个按钮点击事件\u0026#34;) } R.id.button2 -\u0026gt; { Toast.makeText(this, \u0026#34;第二个按钮被点击\u0026#34;, Toast.LENGTH_SHORT).show() Log.d(\u0026#34;Button\u0026#34;, \u0026#34;第二个按钮点击事件\u0026#34;) } } } } 5. XML 绑定函数实现 # XML 布局文件 # \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;XML绑定按钮\u0026#34; android:onClick=\u0026#34;onButtonClick\u0026#34; android:background=\u0026#34;@drawable/button_background\u0026#34; /\u0026gt; Kotlin 代码 # class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) } // XML绑定的点击事件方法 fun onButtonClick(view: View) { when (view.id) { R.id.button -\u0026gt; { Toast.makeText(this, \u0026#34;XML绑定实现点击事件\u0026#34;, Toast.LENGTH_SHORT).show() Log.d(\u0026#34;Button\u0026#34;, \u0026#34;XML绑定实现\u0026#34;) } } } } Button 样式定制 # 自定义背景样式 # 在 res/drawable/button_background.xml 中定义：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;selector xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!-- 正常状态 --\u0026gt; \u0026lt;item android:state_enabled=\u0026#34;true\u0026#34; android:state_pressed=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;shape android:shape=\u0026#34;rectangle\u0026#34;\u0026gt; \u0026lt;solid android:color=\u0026#34;#2196F3\u0026#34; /\u0026gt; \u0026lt;corners android:radius=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;stroke android:width=\u0026#34;1dp\u0026#34; android:color=\u0026#34;#1976D2\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;!-- 按下状态 --\u0026gt; \u0026lt;item android:state_pressed=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;shape android:shape=\u0026#34;rectangle\u0026#34;\u0026gt; \u0026lt;solid android:color=\u0026#34;#1976D2\u0026#34; /\u0026gt; \u0026lt;corners android:radius=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;!-- 禁用状态 --\u0026gt; \u0026lt;item android:state_enabled=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;shape android:shape=\u0026#34;rectangle\u0026#34;\u0026gt; \u0026lt;solid android:color=\u0026#34;#CCCCCC\u0026#34; /\u0026gt; \u0026lt;corners android:radius=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/selector\u0026gt; 应用自定义样式 # \u0026lt;Button android:id=\u0026#34;@+id/customButton\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;自定义样式按钮\u0026#34; android:textColor=\u0026#34;#FFFFFF\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:background=\u0026#34;@drawable/button_background\u0026#34; android:padding=\u0026#34;16dp\u0026#34; /\u0026gt; 特殊按钮类型 # ImageButton 图片按钮 # \u0026lt;ImageButton android:id=\u0026#34;@+id/imageButton\u0026#34; android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:src=\u0026#34;@drawable/ic_add\u0026#34; android:background=\u0026#34;@drawable/image_button_background\u0026#34; android:scaleType=\u0026#34;centerInside\u0026#34; /\u0026gt; private fun setupImageButton() { imageButton.setOnClickListener { Toast.makeText(this, \u0026#34;图片按钮被点击\u0026#34;, Toast.LENGTH_SHORT).show() } } FloatingActionButton 悬浮按钮 # \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/fab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;bottom|end\u0026#34; android:layout_margin=\u0026#34;16dp\u0026#34; android:src=\u0026#34;@drawable/ic_add\u0026#34; app:backgroundTint=\u0026#34;@color/primary\u0026#34; app:tint=\u0026#34;@color/white\u0026#34; /\u0026gt; 按钮状态管理 # 动态控制按钮状态 # class MainActivity : AppCompatActivity() { private lateinit var submitButton: Button private lateinit var editText: EditText override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupButtonState() } private fun initViews() { submitButton = findViewById(R.id.submitButton) editText = findViewById(R.id.editText) } private fun setupButtonState() { // 初始状态禁用按钮 submitButton.isEnabled = false // 监听输入变化 editText.addTextChangedListener(object : TextWatcher { override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {} override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { // 根据输入内容动态启用/禁用按钮 submitButton.isEnabled = s?.isNotEmpty() == true } override fun afterTextChanged(s: Editable?) {} }) // 按钮点击处理 submitButton.setOnClickListener { if (submitButton.isEnabled) { handleSubmit() } } } private fun handleSubmit() { val inputText = editText.text.toString() Toast.makeText(this, \u0026#34;提交内容：$inputText\u0026#34;, Toast.LENGTH_SHORT).show() // 提交后禁用按钮防止重复提交 submitButton.isEnabled = false submitButton.text = \u0026#34;已提交\u0026#34; } } 按钮动画效果 # 点击动画 # private fun setupButtonAnimation() { button.setOnClickListener { // 缩放动画 val scaleDown = ObjectAnimator.ofFloat(button, \u0026#34;scaleX\u0026#34;, 1f, 0.9f) val scaleUp = ObjectAnimator.ofFloat(button, \u0026#34;scaleX\u0026#34;, 0.9f, 1f) val animatorSet = AnimatorSet() animatorSet.play(scaleUp).after(scaleDown) animatorSet.duration = 100 animatorSet.start() // 执行点击逻辑 handleButtonClick() } } 最佳实践 # 1. 事件处理方式选择 # 方式 适用场景 优点 缺点 Lambda表达式 简单点击事件 代码简洁 不适合复杂逻辑 自定义内部类 复杂事件处理 逻辑清晰 代码较多 接口实现 多个按钮 统一管理 需要判断ID XML绑定 简单场景 声明式 灵活性差 2. 性能优化 # // 避免在点击事件中创建新对象 private val clickListener = View.OnClickListener { view -\u0026gt; when (view.id) { R.id.button -\u0026gt; handleClick() } } private fun setupButtons() { button.setOnClickListener(clickListener) } 3. 无障碍支持 # \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;提交\u0026#34; android:contentDescription=\u0026#34;提交表单数据\u0026#34; android:importantForAccessibility=\u0026#34;yes\u0026#34; /\u0026gt; 📋 总结 # Button 是 Android 开发中最基础的交互控件：\n多种事件实现方式：Lambda表达式、内部类、接口实现、XML绑定 样式定制：通过drawable资源实现自定义外观 状态管理：动态控制按钮的启用/禁用状态 动画效果：添加点击反馈和过渡动画 最佳实践：选择合适的实现方式，注重性能和用户体验 掌握 Button 的各种使用方法是 Android 开发的基础技能。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/05---button-%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"详细介绍Android Button按钮控件的四种点击事件实现方式，包括自定义内部类、匿名内部类、接口实现和XML绑定","title":"Button 按钮控件","type":"posts"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" CheckBox 选择控件 # Android 提供了多种选择控件，用于不同的用户交互场景。本文将详细介绍各种选择控件的使用方法。\nCheckBox 复选框 # CheckBox 是系统封装的复选控件，支持两种状态：选中和未选中。\n基本属性 # 属性 说明 示例值 android:checked 初始选中状态 true, false android:text 显示文本 \u0026quot;同意条款\u0026quot; android:textOn 选中时显示文本 \u0026quot;已选中\u0026quot; android:textOff 未选中时显示文本 \u0026quot;未选中\u0026quot; 基本使用 # \u0026lt;CheckBox android:id=\u0026#34;@+id/checkBox\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;同意用户协议\u0026#34; android:checked=\u0026#34;false\u0026#34; /\u0026gt; Kotlin 代码示例 # class CheckBoxActivity : AppCompatActivity() { private lateinit var checkBox: CheckBox private lateinit var submitButton: Button private lateinit var statusText: TextView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_checkbox) initViews() setupCheckBox() setupSubmitButton() } private fun initViews() { checkBox = findViewById(R.id.checkBox) submitButton = findViewById(R.id.submitButton) statusText = findViewById(R.id.statusText) } private fun setupCheckBox() { // 设置选中状态变化监听器 checkBox.setOnCheckedChangeListener { _, isChecked -\u0026gt; statusText.text = if (isChecked) \u0026#34;已选中\u0026#34; else \u0026#34;未选中\u0026#34; submitButton.isEnabled = isChecked } } private fun setupSubmitButton() { submitButton.isEnabled = false submitButton.setOnClickListener { if (checkBox.isChecked) { Toast.makeText(this, \u0026#34;提交成功\u0026#34;, Toast.LENGTH_SHORT).show() } } } // 程序控制选中状态 private fun setCheckBoxChecked(checked: Boolean) { checkBox.isChecked = checked } // 获取选中状态 private fun isCheckBoxChecked(): Boolean { return checkBox.isChecked } } 多选示例 # class MultiCheckBoxActivity : AppCompatActivity() { private lateinit var checkBoxes: List\u0026lt;CheckBox\u0026gt; private lateinit var selectAllButton: Button private lateinit var clearAllButton: Button private lateinit var submitButton: Button private lateinit var selectedCountText: TextView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_multi_checkbox) initViews() setupCheckBoxes() setupButtons() } private fun initViews() { checkBoxes = listOf( findViewById(R.id.checkBox1), findViewById(R.id.checkBox2), findViewById(R.id.checkBox3), findViewById(R.id.checkBox4) ) selectAllButton = findViewById(R.id.selectAllButton) clearAllButton = findViewById(R.id.clearAllButton) submitButton = findViewById(R.id.submitButton) selectedCountText = findViewById(R.id.selectedCountText) } private fun setupCheckBoxes() { val options = listOf(\u0026#34;选项1\u0026#34;, \u0026#34;选项2\u0026#34;, \u0026#34;选项3\u0026#34;, \u0026#34;选项4\u0026#34;) checkBoxes.forEachIndexed { index, checkBox -\u0026gt; checkBox.text = options[index] checkBox.setOnCheckedChangeListener { _, _ -\u0026gt; updateSelectedCount() } } updateSelectedCount() } private fun setupButtons() { selectAllButton.setOnClickListener { selectAll(true) } clearAllButton.setOnClickListener { selectAll(false) } submitButton.setOnClickListener { submitSelectedOptions() } } private fun selectAll(select: Boolean) { checkBoxes.forEach { checkBox -\u0026gt; checkBox.isChecked = select } updateSelectedCount() } private fun updateSelectedCount() { val selectedCount = checkBoxes.count { it.isChecked } selectedCountText.text = \u0026#34;已选择: $selectedCount 项\u0026#34; submitButton.isEnabled = selectedCount \u0026gt; 0 } private fun submitSelectedOptions() { val selectedOptions = checkBoxes .filter { it.isChecked } .map { it.text.toString() } val message = \u0026#34;已选择: ${selectedOptions.joinToString(\u0026#34;, \u0026#34;)}\u0026#34; Toast.makeText(this, message, Toast.LENGTH_LONG).show() } } RadioButton 单选框 # RadioButton 是单选控件，通常与 RadioGroup 一起使用，确保一组中只能选择一个选项。\n基本属性 # 属性 说明 示例值 android:checked 初始选中状态 true, false android:text 显示文本 \u0026quot;男\u0026quot; android:button 自定义按钮样式 @drawable/custom_radio 基本使用 # \u0026lt;RadioGroup android:id=\u0026#34;@+id/radioGroup\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/radioButton1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;男\u0026#34; android:checked=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/radioButton2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;女\u0026#34; /\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/radioButton3\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;其他\u0026#34; /\u0026gt; \u0026lt;/RadioGroup\u0026gt; Kotlin 代码示例 # class RadioButtonActivity : AppCompatActivity() { private lateinit var radioGroup: RadioGroup private lateinit var submitButton: Button private lateinit var selectedText: TextView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_radio_button) initViews() setupRadioGroup() setupSubmitButton() } private fun initViews() { radioGroup = findViewById(R.id.radioGroup) submitButton = findViewById(R.id.submitButton) selectedText = findViewById(R.id.selectedText) } private fun setupRadioGroup() { radioGroup.setOnCheckedChangeListener { _, checkedId -\u0026gt; val selectedRadioButton = findViewById\u0026lt;RadioButton\u0026gt;(checkedId) selectedText.text = \u0026#34;已选择: ${selectedRadioButton.text}\u0026#34; } } private fun setupSubmitButton() { submitButton.setOnClickListener { val checkedRadioButtonId = radioGroup.checkedRadioButtonId if (checkedRadioButtonId != -1) { val selectedRadioButton = findViewById\u0026lt;RadioButton\u0026gt;(checkedRadioButtonId) Toast.makeText(this, \u0026#34;提交: ${selectedRadioButton.text}\u0026#34;, Toast.LENGTH_SHORT).show() } else { Toast.makeText(this, \u0026#34;请选择一个选项\u0026#34;, Toast.LENGTH_SHORT).show() } } } // 程序控制选中状态 private fun setRadioButtonChecked(radioButtonId: Int) { radioGroup.check(radioButtonId) } // 获取选中的 RadioButton private fun getSelectedRadioButton(): RadioButton? { val checkedId = radioGroup.checkedRadioButtonId return if (checkedId != -1) findViewById(checkedId) else null } } 动态创建 RadioButton # class DynamicRadioButtonActivity : AppCompatActivity() { private lateinit var radioGroup: RadioGroup private lateinit var addOptionButton: Button private lateinit var submitButton: Button private val options = mutableListOf(\u0026#34;选项1\u0026#34;, \u0026#34;选项2\u0026#34;, \u0026#34;选项3\u0026#34;) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_dynamic_radio_button) initViews() createRadioButtons() setupButtons() } private fun initViews() { radioGroup = findViewById(R.id.radioGroup) addOptionButton = findViewById(R.id.addOptionButton) submitButton = findViewById(R.id.submitButton) } private fun createRadioButtons() { options.forEachIndexed { index, optionText -\u0026gt; val radioButton = RadioButton(this).apply { id = View.generateViewId() text = optionText layoutParams = RadioGroup.LayoutParams( RadioGroup.LayoutParams.WRAP_CONTENT, RadioGroup.LayoutParams.WRAP_CONTENT ) } radioGroup.addView(radioButton) } } private fun setupButtons() { addOptionButton.setOnClickListener { addNewOption() } submitButton.setOnClickListener { submitSelection() } } private fun addNewOption() { val newOptionText = \u0026#34;选项${options.size + 1}\u0026#34; options.add(newOptionText) val radioButton = RadioButton(this).apply { id = View.generateViewId() text = newOptionText layoutParams = RadioGroup.LayoutParams( RadioGroup.LayoutParams.WRAP_CONTENT, RadioGroup.LayoutParams.WRAP_CONTENT ) } radioGroup.addView(radioButton) Toast.makeText(this, \u0026#34;添加了新选项: $newOptionText\u0026#34;, Toast.LENGTH_SHORT).show() } private fun submitSelection() { val checkedId = radioGroup.checkedRadioButtonId if (checkedId != -1) { val selectedRadioButton = findViewById\u0026lt;RadioButton\u0026gt;(checkedId) Toast.makeText(this, \u0026#34;提交: ${selectedRadioButton.text}\u0026#34;, Toast.LENGTH_SHORT).show() } else { Toast.makeText(this, \u0026#34;请选择一个选项\u0026#34;, Toast.LENGTH_SHORT).show() } } } ToggleButton 切换按钮 # ToggleButton 是切换按钮，只有两种状态：开和关。\n基本属性 # 属性 说明 示例值 android:textOn 开启时显示文本 \u0026quot;开启\u0026quot; android:textOff 关闭时显示文本 \u0026quot;关闭\u0026quot; android:checked 初始状态 true, false 基本使用 # \u0026lt;ToggleButton android:id=\u0026#34;@+id/toggleButton\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textOn=\u0026#34;开启\u0026#34; android:textOff=\u0026#34;关闭\u0026#34; android:checked=\u0026#34;false\u0026#34; /\u0026gt; Kotlin 代码示例 # class ToggleButtonActivity : AppCompatActivity() { private lateinit var toggleButton: ToggleButton private lateinit var statusText: TextView private lateinit var actionButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_toggle_button) initViews() setupToggleButton() setupActionButton() } private fun initViews() { toggleButton = findViewById(R.id.toggleButton) statusText = findViewById(R.id.statusText) actionButton = findViewById(R.id.actionButton) } private fun setupToggleButton() { toggleButton.setOnCheckedChangeListener { _, isChecked -\u0026gt; statusText.text = if (isChecked) \u0026#34;状态: 开启\u0026#34; else \u0026#34;状态: 关闭\u0026#34; actionButton.isEnabled = isChecked } // 初始状态 statusText.text = \u0026#34;状态: 关闭\u0026#34; actionButton.isEnabled = false } private fun setupActionButton() { actionButton.setOnClickListener { if (toggleButton.isChecked) { Toast.makeText(this, \u0026#34;执行操作\u0026#34;, Toast.LENGTH_SHORT).show() } } } // 程序控制状态 private fun setToggleState(checked: Boolean) { toggleButton.isChecked = checked } // 获取当前状态 private fun getToggleState(): Boolean { return toggleButton.isChecked } } SeekBar 滑动条 # SeekBar 是滑动条控件，常用于音量控制、进度调节等场景。\n基本属性 # 属性 说明 示例值 android:max 最大值 100 android:progress 当前值 50 android:progressTint 进度条颜色 @color/primary android:thumbTint 滑块颜色 @color/accent 基本使用 # \u0026lt;SeekBar android:id=\u0026#34;@+id/seekBar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:max=\u0026#34;100\u0026#34; android:progress=\u0026#34;50\u0026#34; android:progressTint=\u0026#34;@color/primary\u0026#34; android:thumbTint=\u0026#34;@color/accent\u0026#34; /\u0026gt; Kotlin 代码示例 # class SeekBarActivity : AppCompatActivity() { private lateinit var seekBar: SeekBar private lateinit var progressText: TextView private lateinit var resetButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_seek_bar) initViews() setupSeekBar() setupResetButton() } private fun initViews() { seekBar = findViewById(R.id.seekBar) progressText = findViewById(R.id.progressText) resetButton = findViewById(R.id.resetButton) } private fun setupSeekBar() { seekBar.max = 100 seekBar.progress = 50 seekBar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener { override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) { progressText.text = \u0026#34;进度: $progress%\u0026#34; // 根据进度改变背景色 val backgroundColor = when { progress \u0026lt; 30 -\u0026gt; Color.RED progress \u0026lt; 70 -\u0026gt; Color.YELLOW else -\u0026gt; Color.GREEN } progressText.setTextColor(backgroundColor) } override fun onStartTrackingTouch(seekBar: SeekBar?) { Toast.makeText(this@SeekBarActivity, \u0026#34;开始拖拽\u0026#34;, Toast.LENGTH_SHORT).show() } override fun onStopTrackingTouch(seekBar: SeekBar?) { Toast.makeText(this@SeekBarActivity, \u0026#34;停止拖拽\u0026#34;, Toast.LENGTH_SHORT).show() } }) // 初始显示 progressText.text = \u0026#34;进度: 50%\u0026#34; } private fun setupResetButton() { resetButton.setOnClickListener { seekBar.progress = 0 progressText.text = \u0026#34;进度: 0%\u0026#34; } } // 程序控制进度 private fun setProgress(progress: Int) { seekBar.progress = progress } // 获取当前进度 private fun getProgress(): Int { return seekBar.progress } } 音量控制示例 # class VolumeControlActivity : AppCompatActivity() { private lateinit var volumeSeekBar: SeekBar private lateinit var volumeText: TextView private lateinit var muteButton: Button private var isMuted = false private var previousVolume = 50 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_volume_control) initViews() setupVolumeControl() setupMuteButton() } private fun initViews() { volumeSeekBar = findViewById(R.id.volumeSeekBar) volumeText = findViewById(R.id.volumeText) muteButton = findViewById(R.id.muteButton) } private fun setupVolumeControl() { volumeSeekBar.max = 100 volumeSeekBar.progress = 50 volumeSeekBar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener { override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) { if (!isMuted) { updateVolumeDisplay(progress) } } override fun onStartTrackingTouch(seekBar: SeekBar?) { // 开始拖拽 } override fun onStopTrackingTouch(seekBar: SeekBar?) { // 停止拖拽 } }) updateVolumeDisplay(50) } private fun setupMuteButton() { muteButton.setOnClickListener { toggleMute() } } private fun toggleMute() { if (isMuted) { // 取消静音 volumeSeekBar.progress = previousVolume muteButton.text = \u0026#34;静音\u0026#34; isMuted = false updateVolumeDisplay(previousVolume) } else { // 静音 previousVolume = volumeSeekBar.progress volumeSeekBar.progress = 0 muteButton.text = \u0026#34;取消静音\u0026#34; isMuted = true volumeText.text = \u0026#34;音量: 静音\u0026#34; } } private fun updateVolumeDisplay(volume: Int) { val volumeText = when { volume == 0 -\u0026gt; \u0026#34;音量: 静音\u0026#34; volume \u0026lt; 30 -\u0026gt; \u0026#34;音量: 低 ($volume%)\u0026#34; volume \u0026lt; 70 -\u0026gt; \u0026#34;音量: 中 ($volume%)\u0026#34; else -\u0026gt; \u0026#34;音量: 高 ($volume%)\u0026#34; } this.volumeText.text = volumeText // 模拟音量变化 simulateVolumeChange(volume) } private fun simulateVolumeChange(volume: Int) { // 这里可以添加实际的音量控制逻辑 Log.d(\u0026#34;VolumeControl\u0026#34;, \u0026#34;音量设置为: $volume%\u0026#34;) } } 实际应用场景 # 1. 设置页面 # \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:padding=\u0026#34;16dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;!-- 通知设置 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;通知设置\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/pushNotificationCheckBox\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;推送通知\u0026#34; android:checked=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/emailNotificationCheckBox\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;邮件通知\u0026#34; android:checked=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;!-- 主题设置 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;主题设置\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:layout_marginTop=\u0026#34;32dp\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;RadioGroup android:id=\u0026#34;@+id/themeRadioGroup\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/lightThemeRadio\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;浅色主题\u0026#34; android:checked=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/darkThemeRadio\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;深色主题\u0026#34; /\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/autoThemeRadio\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;跟随系统\u0026#34; /\u0026gt; \u0026lt;/RadioGroup\u0026gt; \u0026lt;!-- 音量设置 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;音量设置\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:layout_marginTop=\u0026#34;32dp\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;SeekBar android:id=\u0026#34;@+id/volumeSeekBar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:max=\u0026#34;100\u0026#34; android:progress=\u0026#34;50\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/volumeText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;音量: 50%\u0026#34; android:layout_marginTop=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/ScrollView\u0026gt; 2. 表单验证 # class FormValidationActivity : AppCompatActivity() { private lateinit var agreementCheckBox: CheckBox private lateinit var genderRadioGroup: RadioGroup private lateinit var submitButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_form_validation) initViews() setupValidation() } private fun initViews() { agreementCheckBox = findViewById(R.id.agreementCheckBox) genderRadioGroup = findViewById(R.id.genderRadioGroup) submitButton = findViewById(R.id.submitButton) } private fun setupValidation() { submitButton.setOnClickListener { if (validateForm()) { submitForm() } } } private fun validateForm(): Boolean { var isValid = true // 验证协议勾选 if (!agreementCheckBox.isChecked) { Toast.makeText(this, \u0026#34;请同意用户协议\u0026#34;, Toast.LENGTH_SHORT).show() isValid = false } // 验证性别选择 if (genderRadioGroup.checkedRadioButtonId == -1) { Toast.makeText(this, \u0026#34;请选择性别\u0026#34;, Toast.LENGTH_SHORT).show() isValid = false } return isValid } private fun submitForm() { val selectedGender = findViewById\u0026lt;RadioButton\u0026gt;(genderRadioGroup.checkedRadioButtonId) val message = \u0026#34;提交成功！\\n性别: ${selectedGender.text}\\n协议: 已同意\u0026#34; Toast.makeText(this, message, Toast.LENGTH_LONG).show() } } 📋 总结 # Android 选择控件提供了丰富的用户交互方式：\nCheckBox：多选场景，支持选中状态监听 RadioButton：单选场景，与 RadioGroup 配合使用 ToggleButton：开关状态，适合设置类功能 SeekBar：数值调节，常用于音量、进度控制 实际应用：设置页面、表单验证、用户偏好等场景 掌握这些选择控件的使用方法对于创建良好的用户交互体验至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/10---checkbox-%E9%80%89%E6%8B%A9%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"详细介绍Android选择控件的使用方法，包括CheckBox、RadioButton、ToggleButton和SeekBar","title":"CheckBox 选择控件","type":"posts"},{"content":" ConstraintLayout 约束布局 # ConstraintLayout 是 Android 2.3+ 引入的布局容器，通过约束关系来定位子控件，能够创建复杂且高效的布局。\nConstraintLayout 基本概念 # 什么是约束布局 # ConstraintLayout 使用约束（Constraint）来定义子控件的位置和大小。每个控件通过约束关系与其他控件或父容器建立联系。\n约束布局的优势 # 扁平化结构：减少布局嵌套，提升性能 灵活定位：支持复杂的约束关系 可视化设计：Android Studio 提供可视化编辑器 响应式布局：自动适配不同屏幕尺寸 约束属性详解 # 1. 对齐约束 # 当前控件的某个方位与另一个参照物的某个方位对齐：\n属性 说明 对应 RelativeLayout app:layout_constraintLeft_toLeftOf 左对齐 alignLeft app:layout_constraintRight_toRightOf 右对齐 alignRight app:layout_constraintTop_toTopOf 上对齐 alignTop app:layout_constraintBottom_toBottomOf 下对齐 alignBottom app:layout_constraintStart_toStartOf 开始对齐 alignStart app:layout_constraintEnd_toEndOf 结束对齐 alignEnd 2. 位置约束 # 当前控件的 A 侧在参照物的 B 侧：\n属性 说明 对应 RelativeLayout app:layout_constraintLeft_toRightOf 在右侧 toRightOf app:layout_constraintRight_toLeftOf 在左侧 toLeftOf app:layout_constraintTop_toBottomOf 在下方 below app:layout_constraintBottom_toTopOf 在上方 above app:layout_constraintStart_toEndOf 在结束侧 toEndOf app:layout_constraintEnd_toStartOf 在开始侧 toStartOf 3. 偏移约束 # 属性 说明 示例值 app:layout_constraintVertical_bias 垂直偏移量 0.5（正中间） app:layout_constraintHorizontal_bias 水平偏移量 0.3（30%位置） 基本使用示例 # 1. 居中布局 # \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/centerText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;居中文本\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 2. 相对定位 # \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;!-- 参照控件 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/referenceText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;参照文本\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; android:layout_marginTop=\u0026#34;32dp\u0026#34; android:layout_marginLeft=\u0026#34;32dp\u0026#34; /\u0026gt; \u0026lt;!-- 相对定位的控件 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/relativeText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;相对定位文本\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/referenceText\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;@id/referenceText\u0026#34; android:layout_marginTop=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 3. 偏移布局 # \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/biasText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;偏移文本\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; app:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; app:layout_constraintHorizontal_bias=\u0026#34;0.3\u0026#34; app:layout_constraintVertical_bias=\u0026#34;0.7\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; Kotlin 代码示例 # 动态创建约束布局 # class ConstraintLayoutActivity : AppCompatActivity() { private lateinit var constraintLayout: ConstraintLayout override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_constraint_layout) initViews() createDynamicLayout() } private fun initViews() { constraintLayout = findViewById(R.id.constraintLayout) } private fun createDynamicLayout() { // 创建标题文本 val titleText = TextView(this).apply { id = View.generateViewId() text = \u0026#34;动态标题\u0026#34; textSize = 20f setTextColor(Color.BLACK) layoutParams = ConstraintLayout.LayoutParams( ConstraintLayout.LayoutParams.WRAP_CONTENT, ConstraintLayout.LayoutParams.WRAP_CONTENT ) } // 创建内容文本 val contentText = TextView(this).apply { id = View.generateViewId() text = \u0026#34;这是动态创建的内容文本\u0026#34; textSize = 16f setTextColor(Color.GRAY) layoutParams = ConstraintLayout.LayoutParams( ConstraintLayout.LayoutParams.WRAP_CONTENT, ConstraintLayout.LayoutParams.WRAP_CONTENT ) } // 创建按钮 val actionButton = Button(this).apply { id = View.generateViewId() text = \u0026#34;操作按钮\u0026#34; layoutParams = ConstraintLayout.LayoutParams( ConstraintLayout.LayoutParams.WRAP_CONTENT, ConstraintLayout.LayoutParams.WRAP_CONTENT ) } // 添加控件到布局 constraintLayout.addView(titleText) constraintLayout.addView(contentText) constraintLayout.addView(actionButton) // 设置约束 setupConstraints(titleText, contentText, actionButton) } private fun setupConstraints( titleText: TextView, contentText: TextView, actionButton: Button ) { val layoutParams = constraintLayout.layoutParams as ConstraintLayout.LayoutParams // 标题文本约束 - 顶部居中 val titleParams = titleText.layoutParams as ConstraintLayout.LayoutParams titleParams.topToTop = ConstraintLayout.LayoutParams.PARENT_ID titleParams.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID titleParams.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID titleParams.topMargin = dpToPx(32) // 内容文本约束 - 在标题下方 val contentParams = contentText.layoutParams as ConstraintLayout.LayoutParams contentParams.topToBottom = titleText.id contentParams.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID contentParams.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID contentParams.topMargin = dpToPx(16) // 按钮约束 - 在内容下方居中 val buttonParams = actionButton.layoutParams as ConstraintLayout.LayoutParams buttonParams.topToBottom = contentText.id buttonParams.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID buttonParams.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID buttonParams.topMargin = dpToPx(24) // 应用约束 titleText.layoutParams = titleParams contentText.layoutParams = contentParams actionButton.layoutParams = buttonParams } private fun dpToPx(dp: Int): Int { return (dp * resources.displayMetrics.density).toInt() } } 复杂约束布局示例 # class ComplexConstraintActivity : AppCompatActivity() { private lateinit var constraintLayout: ConstraintLayout override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_complex_constraint) initViews() createComplexLayout() } private fun initViews() { constraintLayout = findViewById(R.id.constraintLayout) } private fun createComplexLayout() { // 创建头部区域 val headerView = createHeaderView() constraintLayout.addView(headerView) // 创建侧边栏 val sidebarView = createSidebarView() constraintLayout.addView(sidebarView) // 创建主内容区域 val contentView = createContentView() constraintLayout.addView(contentView) // 创建底部区域 val footerView = createFooterView() constraintLayout.addView(footerView) // 设置复杂约束 setupComplexConstraints(headerView, sidebarView, contentView, footerView) } private fun createHeaderView(): View { return LinearLayout(this).apply { id = View.generateViewId() orientation = LinearLayout.HORIZONTAL gravity = Gravity.CENTER_VERTICAL setBackgroundColor(Color.parseColor(\u0026#34;#2196F3\u0026#34;)) layoutParams = ConstraintLayout.LayoutParams( ConstraintLayout.LayoutParams.MATCH_PARENT, dpToPx(56) ) // 添加标题 val titleText = TextView(this@ComplexConstraintActivity).apply { text = \u0026#34;应用标题\u0026#34; setTextColor(Color.WHITE) textSize = 18f layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT ) } addView(titleText) } } private fun createSidebarView(): View { return LinearLayout(this).apply { id = View.generateViewId() orientation = LinearLayout.VERTICAL setBackgroundColor(Color.parseColor(\u0026#34;#F5F5F5\u0026#34;)) layoutParams = ConstraintLayout.LayoutParams( dpToPx(200), ConstraintLayout.LayoutParams.MATCH_CONSTRAINT ) // 添加菜单项 val menuItems = listOf(\u0026#34;首页\u0026#34;, \u0026#34;设置\u0026#34;, \u0026#34;帮助\u0026#34;, \u0026#34;关于\u0026#34;) menuItems.forEach { itemText -\u0026gt; val menuItem = TextView(this@ComplexConstraintActivity).apply { text = itemText textSize = 16f setPadding(dpToPx(16), dpToPx(12), dpToPx(16), dpToPx(12)) setBackgroundColor(Color.TRANSPARENT) layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT ) } addView(menuItem) } } } private fun createContentView(): View { return ScrollView(this).apply { id = View.generateViewId() setBackgroundColor(Color.WHITE) layoutParams = ConstraintLayout.LayoutParams( ConstraintLayout.LayoutParams.MATCH_CONSTRAINT, ConstraintLayout.LayoutParams.MATCH_CONSTRAINT ) // 添加内容 val contentText = TextView(this@ComplexConstraintActivity).apply { text = \u0026#34;这里是主要内容区域\\n\\n\u0026#34; + \u0026#34;ConstraintLayout 提供了强大的约束功能，\\n\u0026#34; + \u0026#34;可以创建复杂的布局结构。\\n\\n\u0026#34; + \u0026#34;通过约束关系，我们可以精确控制\\n\u0026#34; + \u0026#34;每个控件的位置和大小。\u0026#34; textSize = 16f setPadding(dpToPx(16), dpToPx(16), dpToPx(16), dpToPx(16)) layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT ) } addView(contentText) } } private fun createFooterView(): View { return LinearLayout(this).apply { id = View.generateViewId() orientation = LinearLayout.HORIZONTAL gravity = Gravity.CENTER setBackgroundColor(Color.parseColor(\u0026#34;#E0E0E0\u0026#34;)) layoutParams = ConstraintLayout.LayoutParams( ConstraintLayout.LayoutParams.MATCH_PARENT, dpToPx(48) ) val footerText = TextView(this@ComplexConstraintActivity).apply { text = \u0026#34;© 2024 应用名称\u0026#34; textSize = 14f setTextColor(Color.GRAY) layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT ) } addView(footerText) } } private fun setupComplexConstraints( headerView: View, sidebarView: View, contentView: View, footerView: View ) { // 头部约束 val headerParams = headerView.layoutParams as ConstraintLayout.LayoutParams headerParams.topToTop = ConstraintLayout.LayoutParams.PARENT_ID headerParams.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID headerParams.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID // 侧边栏约束 val sidebarParams = sidebarView.layoutParams as ConstraintLayout.LayoutParams sidebarParams.topToBottom = headerView.id sidebarParams.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID sidebarParams.bottomToTop = footerView.id // 主内容约束 val contentParams = contentView.layoutParams as ConstraintLayout.LayoutParams contentParams.topToBottom = headerView.id contentParams.leftToRight = sidebarView.id contentParams.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID contentParams.bottomToTop = footerView.id // 底部约束 val footerParams = footerView.layoutParams as ConstraintLayout.LayoutParams footerParams.bottomToBottom = ConstraintLayout.LayoutParams.PARENT_ID footerParams.leftToLeft = ConstraintLayout.LayoutParams.PARENT_ID footerParams.rightToRight = ConstraintLayout.LayoutParams.PARENT_ID // 应用约束 headerView.layoutParams = headerParams sidebarView.layoutParams = sidebarParams contentView.layoutParams = contentParams footerView.layoutParams = footerParams } private fun dpToPx(dp: Int): Int { return (dp * resources.displayMetrics.density).toInt() } } 实际应用场景 # 1. 登录表单 # \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:padding=\u0026#34;32dp\u0026#34;\u0026gt; \u0026lt;!-- 标题 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/titleText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;用户登录\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; android:layout_marginTop=\u0026#34;64dp\u0026#34; /\u0026gt; \u0026lt;!-- 用户名输入框 --\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/usernameEditText\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入用户名\u0026#34; android:layout_marginTop=\u0026#34;48dp\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/titleText\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;!-- 密码输入框 --\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/passwordEditText\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入密码\u0026#34; android:inputType=\u0026#34;textPassword\u0026#34; android:layout_marginTop=\u0026#34;16dp\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/usernameEditText\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;!-- 登录按钮 --\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/loginButton\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;登录\u0026#34; android:layout_marginTop=\u0026#34;32dp\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/passwordEditText\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;!-- 忘记密码链接 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/forgotPasswordText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;忘记密码？\u0026#34; android:textColor=\u0026#34;@color/primary\u0026#34; android:layout_marginTop=\u0026#34;16dp\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/loginButton\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 2. 响应式卡片布局 # \u0026lt;androidx.constraintlayout.widget.ConstraintLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;8dp\u0026#34; android:background=\u0026#34;@drawable/card_background\u0026#34; android:elevation=\u0026#34;2dp\u0026#34;\u0026gt; \u0026lt;!-- 头像 --\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/avatarImage\u0026#34; android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:src=\u0026#34;@drawable/default_avatar\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; android:layout_margin=\u0026#34;16dp\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;!-- 用户名 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/usernameText\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;用户名\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;@id/avatarImage\u0026#34; app:layout_constraintLeft_toRightOf=\u0026#34;@id/avatarImage\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;!-- 时间 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/timeText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;2小时前\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; android:textColor=\u0026#34;#666666\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/usernameText\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;@id/usernameText\u0026#34; /\u0026gt; \u0026lt;!-- 内容 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/contentText\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;这是卡片的内容文本...\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:layout_marginTop=\u0026#34;8dp\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; app:layout_constraintTop_toBottomOf=\u0026#34;@id/avatarImage\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 性能优化建议 # 1. 减少嵌套层级 # \u0026lt;!-- 不好的做法：多层嵌套 --\u0026gt; \u0026lt;LinearLayout\u0026gt; \u0026lt;LinearLayout\u0026gt; \u0026lt;LinearLayout\u0026gt; \u0026lt;TextView /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 好的做法：使用 ConstraintLayout --\u0026gt; \u0026lt;androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;TextView app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 2. 使用 Guideline # \u0026lt;androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;!-- 垂直参考线 --\u0026gt; \u0026lt;androidx.constraintlayout.widget.Guideline android:id=\u0026#34;@+id/verticalGuideline\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; app:layout_constraintGuide_percent=\u0026#34;0.5\u0026#34; /\u0026gt; \u0026lt;!-- 水平参考线 --\u0026gt; \u0026lt;androidx.constraintlayout.widget.Guideline android:id=\u0026#34;@+id/horizontalGuideline\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; app:layout_constraintGuide_percent=\u0026#34;0.3\u0026#34; /\u0026gt; \u0026lt;!-- 使用参考线定位 --\u0026gt; \u0026lt;TextView app:layout_constraintTop_toTopOf=\u0026#34;@id/horizontalGuideline\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;@id/verticalGuideline\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 3. 使用 Barrier # \u0026lt;androidx.constraintlayout.widget.ConstraintLayout\u0026gt; \u0026lt;!-- 创建屏障 --\u0026gt; \u0026lt;androidx.constraintlayout.widget.Barrier android:id=\u0026#34;@+id/textBarrier\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:barrierDirection=\u0026#34;end\u0026#34; app:constraint_referenced_ids=\u0026#34;text1,text2,text3\u0026#34; /\u0026gt; \u0026lt;!-- 使用屏障定位 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/rightText\u0026#34; app:layout_constraintLeft_toRightOf=\u0026#34;@id/textBarrier\u0026#34; /\u0026gt; \u0026lt;/androidx.constraintlayout.widget.ConstraintLayout\u0026gt; 📋 总结 # ConstraintLayout 是 Android 开发中强大的布局容器：\n约束关系：通过约束属性精确定位控件 扁平化结构：减少布局嵌套，提升性能 响应式设计：自动适配不同屏幕尺寸 可视化编辑：Android Studio 提供可视化编辑器 高级功能：支持 Guideline、Barrier 等高级特性 掌握 ConstraintLayout 的使用方法对于创建复杂且高效的布局至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/09---constraintlayout%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80/","section":"Posts","summary":"详细介绍Android ConstraintLayout约束布局的使用方法、约束属性和实际应用场景","title":"ConstraintLayout 约束布局","type":"posts"},{"content":" Fragment 使用全解析 # Fragment 是 Android 3.0+ 引入的组件，用于构建灵活的用户界面，特别适合平板等大屏幕设备。\nFragment 基本概念 # 什么是 Fragment # Fragment 是 Activity 的一个组成元素，可以理解为\u0026quot;片段\u0026quot;。一个 Activity 可以包含多个 Fragment，每个 Fragment 都有自己的生命周期和用户界面。\nFragment vs Activity # 特性 Fragment Activity 生命周期 依赖 Activity 独立 存在性 不能脱离 Activity 可以独立存在 用途 Activity 的组成元素 屏幕的主体 版本 Android 3.0+ Android 1.0+ 数量 一个 Activity 可有多个 一个应用可有多个 Fragment 生命周期 # 生命周期方法详解 # class MyFragment : Fragment() { override fun onAttach(context: Context) { super.onAttach(context) Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onAttach\u0026#34;) // Fragment 与 Activity 关联 } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onCreate\u0026#34;) // 初始化 Fragment } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onCreateView\u0026#34;) // 创建 Fragment 的视图 return inflater.inflate(R.layout.fragment_my, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onViewCreated\u0026#34;) // 视图创建完成后的初始化 initViews(view) } override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onActivityCreated\u0026#34;) // Activity 的 onCreate 完成后调用 } override fun onStart() { super.onStart() Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onStart\u0026#34;) // Fragment 变为可见 } override fun onResume() { super.onResume() Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onResume\u0026#34;) // Fragment 获得焦点 } override fun onPause() { super.onPause() Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onPause\u0026#34;) // Fragment 失去焦点 } override fun onStop() { super.onStop() Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onStop\u0026#34;) // Fragment 不可见 } override fun onDestroyView() { super.onDestroyView() Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onDestroyView\u0026#34;) // 销毁 Fragment 的视图 } override fun onDestroy() { super.onDestroy() Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onDestroy\u0026#34;) // 销毁 Fragment } override fun onDetach() { super.onDetach() Log.d(\u0026#34;Fragment\u0026#34;, \u0026#34;onDetach\u0026#34;) // Fragment 与 Activity 解除关联 } private fun initViews(view: View) { // 初始化视图控件 val textView = view.findViewById\u0026lt;TextView\u0026gt;(R.id.textView) val button = view.findViewById\u0026lt;Button\u0026gt;(R.id.button) textView.text = \u0026#34;Fragment 内容\u0026#34; button.setOnClickListener { Toast.makeText(context, \u0026#34;Fragment 按钮被点击\u0026#34;, Toast.LENGTH_SHORT).show() } } } 生命周期状态图 # graph TD A[onAttach] --\u003e B[onCreate] B --\u003e C[onCreateView] C --\u003e D[onViewCreated] D --\u003e E[onActivityCreated] E --\u003e F[onStart] F --\u003e G[onResume] G --\u003e H[onPause] H --\u003e I[onStop] I --\u003e J[onDestroyView] J --\u003e K[onDestroy] K --\u003e L[onDetach] H --\u003e G I --\u003e F Fragment 加载方式 # 1. 静态加载 # 在 XML 布局文件中直接声明 Fragment：\n\u0026lt;!-- activity_main.xml --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Activity 内容\u0026#34; android:padding=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/myFragment\u0026#34; android:name=\u0026#34;com.example.MyFragment\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; class MainActivity : AppCompatActivity() { private lateinit var myFragment: MyFragment override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // 获取静态加载的 Fragment myFragment = supportFragmentManager.findFragmentById(R.id.myFragment) as MyFragment } } 2. 动态加载 # 通过代码动态添加 Fragment：\nclass MainActivity : AppCompatActivity() { private lateinit var fragmentContainer: FrameLayout override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() loadFragment() } private fun initViews() { fragmentContainer = findViewById(R.id.fragmentContainer) } private fun loadFragment() { val fragment = MyFragment() supportFragmentManager.beginTransaction() .add(R.id.fragmentContainer, fragment) .commit() } } 3. 动态切换 Fragment # class MainActivity : AppCompatActivity() { private lateinit var fragmentContainer: FrameLayout private lateinit var homeButton: Button private lateinit var profileButton: Button private var currentFragment: Fragment? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupClickListeners() // 默认显示首页 Fragment showFragment(HomeFragment()) } private fun initViews() { fragmentContainer = findViewById(R.id.fragmentContainer) homeButton = findViewById(R.id.homeButton) profileButton = findViewById(R.id.profileButton) } private fun setupClickListeners() { homeButton.setOnClickListener { showFragment(HomeFragment()) } profileButton.setOnClickListener { showFragment(ProfileFragment()) } } private fun showFragment(fragment: Fragment) { if (currentFragment != fragment) { supportFragmentManager.beginTransaction() .replace(R.id.fragmentContainer, fragment) .commit() currentFragment = fragment } } } Fragment 数据传递 # 1. Activity → Fragment 传值 # 使用 setArguments # class MyFragment : Fragment() { companion object { private const val ARG_TITLE = \u0026#34;title\u0026#34; private const val ARG_CONTENT = \u0026#34;content\u0026#34; fun newInstance(title: String, content: String): MyFragment { val fragment = MyFragment() val args = Bundle().apply { putString(ARG_TITLE, title) putString(ARG_CONTENT, content) } fragment.arguments = args return fragment } } private var title: String? = null private var content: String? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) arguments?.let { title = it.getString(ARG_TITLE) content = it.getString(ARG_CONTENT) } } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_my, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) view.findViewById\u0026lt;TextView\u0026gt;(R.id.titleText).text = title view.findViewById\u0026lt;TextView\u0026gt;(R.id.contentText).text = content } } // Activity 中使用 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val fragment = MyFragment.newInstance(\u0026#34;标题\u0026#34;, \u0026#34;内容\u0026#34;) supportFragmentManager.beginTransaction() .add(R.id.fragmentContainer, fragment) .commit() } } 直接调用方法 # class MyFragment : Fragment() { private lateinit var textView: TextView override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_my, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) textView = view.findViewById(R.id.textView) } fun updateContent(newContent: String) { textView.text = newContent } } // Activity 中使用 class MainActivity : AppCompatActivity() { private lateinit var myFragment: MyFragment override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) myFragment = MyFragment() supportFragmentManager.beginTransaction() .add(R.id.fragmentContainer, myFragment) .commit() // 延迟调用，确保 Fragment 已创建 Handler(Looper.getMainLooper()).postDelayed({ myFragment.updateContent(\u0026#34;新的内容\u0026#34;) }, 100) } } 2. Fragment → Activity 传值 # 使用回调接口 # class MyFragment : Fragment() { // 定义回调接口 interface OnFragmentInteractionListener { fun onButtonClicked(message: String) } private var listener: OnFragmentInteractionListener? = null override fun onAttach(context: Context) { super.onAttach(context) listener = context as? OnFragmentInteractionListener } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_my, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) view.findViewById\u0026lt;Button\u0026gt;(R.id.button).setOnClickListener { listener?.onButtonClicked(\u0026#34;来自 Fragment 的消息\u0026#34;) } } override fun onDetach() { super.onDetach() listener = null } } // Activity 中实现接口 class MainActivity : AppCompatActivity(), MyFragment.OnFragmentInteractionListener { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val fragment = MyFragment() supportFragmentManager.beginTransaction() .add(R.id.fragmentContainer, fragment) .commit() } override fun onButtonClicked(message: String) { Toast.makeText(this, message, Toast.LENGTH_SHORT).show() } } 使用 EventBus # // 添加依赖：implementation \u0026#39;org.greenrobot:eventbus:3.3.1\u0026#39; // 定义事件类 data class FragmentMessageEvent(val message: String) class MyFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_my, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) view.findViewById\u0026lt;Button\u0026gt;(R.id.button).setOnClickListener { // 发送事件 EventBus.getDefault().post(FragmentMessageEvent(\u0026#34;来自 Fragment 的消息\u0026#34;)) } } } // Activity 中接收事件 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val fragment = MyFragment() supportFragmentManager.beginTransaction() .add(R.id.fragmentContainer, fragment) .commit() } override fun onStart() { super.onStart() EventBus.getDefault().register(this) } override fun onStop() { super.onStop() EventBus.getDefault().unregister(this) } @Subscribe(threadMode = ThreadMode.MAIN) fun onMessageEvent(event: FragmentMessageEvent) { Toast.makeText(this, event.message, Toast.LENGTH_SHORT).show() } } Fragment 最佳实践 # 1. Fragment 状态保存 # class MyFragment : Fragment() { private lateinit var editText: EditText private var userInput: String = \u0026#34;\u0026#34; override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 恢复保存的状态 savedInstanceState?.let { userInput = it.getString(\u0026#34;userInput\u0026#34;, \u0026#34;\u0026#34;) } } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_my, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) editText = view.findViewById(R.id.editText) editText.setText(userInput) editText.addTextChangedListener(object : TextWatcher { override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {} override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { userInput = s.toString() } override fun afterTextChanged(s: Editable?) {} }) } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) outState.putString(\u0026#34;userInput\u0026#34;, userInput) } } 2. Fragment 通信 # class FragmentCommunicationActivity : AppCompatActivity() { private lateinit var fragmentA: FragmentA private lateinit var fragmentB: FragmentB override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_fragment_communication) initFragments() } private fun initFragments() { fragmentA = FragmentA() fragmentB = FragmentB() supportFragmentManager.beginTransaction() .add(R.id.fragmentAContainer, fragmentA) .add(R.id.fragmentBContainer, fragmentB) .commit() } // Fragment A 调用此方法 fun sendMessageToFragmentB(message: String) { fragmentB.receiveMessage(message) } // Fragment B 调用此方法 fun sendMessageToFragmentA(message: String) { fragmentA.receiveMessage(message) } } class FragmentA : Fragment() { private lateinit var messageText: TextView private lateinit var sendButton: Button override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_a, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) messageText = view.findViewById(R.id.messageText) sendButton = view.findViewById(R.id.sendButton) sendButton.setOnClickListener { (activity as? FragmentCommunicationActivity)?.sendMessageToFragmentB(\u0026#34;来自 Fragment A\u0026#34;) } } fun receiveMessage(message: String) { messageText.text = \u0026#34;收到: $message\u0026#34; } } class FragmentB : Fragment() { private lateinit var messageText: TextView private lateinit var sendButton: Button override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_b, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) messageText = view.findViewById(R.id.messageText) sendButton = view.findViewById(R.id.sendButton) sendButton.setOnClickListener { (activity as? FragmentCommunicationActivity)?.sendMessageToFragmentA(\u0026#34;来自 Fragment B\u0026#34;) } } fun receiveMessage(message: String) { messageText.text = \u0026#34;收到: $message\u0026#34; } } 3. ViewPager2 + Fragment # class ViewPagerFragmentActivity : AppCompatActivity() { private lateinit var viewPager2: ViewPager2 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_view_pager_fragment) initViews() setupViewPager() } private fun initViews() { viewPager2 = findViewById(R.id.viewPager2) } private fun setupViewPager() { val fragments = listOf( HomeFragment(), ProfileFragment(), SettingsFragment() ) val adapter = FragmentAdapter(this, fragments) viewPager2.adapter = adapter } } class FragmentAdapter( fragmentActivity: FragmentActivity, private val fragments: List\u0026lt;Fragment\u0026gt; ) : FragmentStateAdapter(fragmentActivity) { override fun getItemCount(): Int = fragments.size override fun createFragment(position: Int): Fragment = fragments[position] } class HomeFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_home, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) view.findViewById\u0026lt;TextView\u0026gt;(R.id.titleText).text = \u0026#34;首页\u0026#34; } } class ProfileFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_profile, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) view.findViewById\u0026lt;TextView\u0026gt;(R.id.titleText).text = \u0026#34;个人资料\u0026#34; } } class SettingsFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.fragment_settings, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) view.findViewById\u0026lt;TextView\u0026gt;(R.id.titleText).text = \u0026#34;设置\u0026#34; } } 📋 总结 # Fragment 是 Android 开发中的重要组件：\n生命周期管理：理解 Fragment 的完整生命周期 加载方式：静态加载和动态加载两种方式 数据传递：Activity 与 Fragment 之间的数据传递 通信机制：Fragment 之间的通信方法 最佳实践：状态保存、内存管理、性能优化 掌握 Fragment 的使用方法对于构建灵活的用户界面至关重要，特别是在适配不同屏幕尺寸时。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/16---fragment-%E4%BD%BF%E7%94%A8%E5%85%A8%E8%A7%A3%E6%9E%90/","section":"Posts","summary":"详细介绍Android Fragment组件的生命周期、加载方式、数据传递和最佳实践","title":"Fragment 使用全解析","type":"posts"},{"content":" FrameLayout 帧布局 # FrameLayout 是 Android 中最简单的布局容器，所有子控件都从左上角开始层叠排列，后添加的控件会覆盖在先添加的控件之上。\nFrameLayout 基本特性 # 层叠排列 # FrameLayout 中的所有子控件都从左上角（0,0）开始定位，后添加的控件会覆盖在先添加的控件之上。\n重要属性 # 属性 说明 示例值 android:layout_gravity 控制控件在容器中的位置 center, top, bottom android:foreground 设置前景图片 @drawable/foreground_image android:foregroundGravity 前景图片的重力 center, top, bottom 基本使用示例 # 层叠效果示例 # \u0026lt;FrameLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:background=\u0026#34;#F5F5F5\u0026#34;\u0026gt; \u0026lt;!-- 底层 - 蓝色 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;350dp\u0026#34; android:layout_height=\u0026#34;350dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#0000FF\u0026#34; android:text=\u0026#34;底层\u0026#34; android:textColor=\u0026#34;#FFFFFF\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 第二层 - 紫色 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;330dp\u0026#34; android:layout_height=\u0026#34;330dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#9932CC\u0026#34; android:text=\u0026#34;第二层\u0026#34; android:textColor=\u0026#34;#FFFFFF\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 第三层 - 粉色 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#FF1493\u0026#34; android:text=\u0026#34;第三层\u0026#34; android:textColor=\u0026#34;#FFFFFF\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 顶层 - 浅紫色 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;270dp\u0026#34; android:layout_height=\u0026#34;270dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#DA70D6\u0026#34; android:text=\u0026#34;顶层\u0026#34; android:textColor=\u0026#34;#FFFFFF\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; Kotlin 代码示例 # 动态创建层叠效果 # class FrameLayoutActivity : AppCompatActivity() { private lateinit var frameLayout: FrameLayout private lateinit var addLayerButton: Button private lateinit var removeLayerButton: Button private val colors = listOf( \u0026#34;#FF5722\u0026#34;, \u0026#34;#2196F3\u0026#34;, \u0026#34;#4CAF50\u0026#34;, \u0026#34;#FF9800\u0026#34;, \u0026#34;#9C27B0\u0026#34;, \u0026#34;#00BCD4\u0026#34; ) private var layerCount = 0 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_frame_layout) initViews() setupClickListeners() } private fun initViews() { frameLayout = findViewById(R.id.frameLayout) addLayerButton = findViewById(R.id.addLayerButton) removeLayerButton = findViewById(R.id.removeLayerButton) } private fun setupClickListeners() { addLayerButton.setOnClickListener { addLayer() } removeLayerButton.setOnClickListener { removeLayer() } } private fun addLayer() { if (layerCount \u0026lt; colors.size) { val textView = TextView(this).apply { val size = 350 - (layerCount * 20) layoutParams = FrameLayout.LayoutParams( dpToPx(size), dpToPx(size) ).apply { gravity = Gravity.CENTER } background = ColorDrawable(Color.parseColor(colors[layerCount])) text = \u0026#34;第 ${layerCount + 1} 层\u0026#34; setTextColor(Color.WHITE) gravity = Gravity.CENTER textSize = 16f } frameLayout.addView(textView) layerCount++ Toast.makeText(this, \u0026#34;添加了第 $layerCount 层\u0026#34;, Toast.LENGTH_SHORT).show() } else { Toast.makeText(this, \u0026#34;已达到最大层数\u0026#34;, Toast.LENGTH_SHORT).show() } } private fun removeLayer() { if (layerCount \u0026gt; 0) { frameLayout.removeViewAt(frameLayout.childCount - 1) layerCount-- Toast.makeText(this, \u0026#34;移除了第 ${layerCount + 1} 层\u0026#34;, Toast.LENGTH_SHORT).show() } else { Toast.makeText(this, \u0026#34;没有可移除的层\u0026#34;, Toast.LENGTH_SHORT).show() } } private fun dpToPx(dp: Int): Int { return (dp * resources.displayMetrics.density).toInt() } } 图片叠加效果 # class ImageOverlayActivity : AppCompatActivity() { private lateinit var frameLayout: FrameLayout private lateinit var addOverlayButton: Button private lateinit var clearOverlayButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_image_overlay) initViews() setupClickListeners() } private fun initViews() { frameLayout = findViewById(R.id.frameLayout) addOverlayButton = findViewById(R.id.addOverlayButton) clearOverlayButton = findViewById(R.id.clearOverlayButton) } private fun setupClickListeners() { addOverlayButton.setOnClickListener { addImageOverlay() } clearOverlayButton.setOnClickListener { clearOverlays() } } private fun addImageOverlay() { val overlayImage = ImageView(this).apply { layoutParams = FrameLayout.LayoutParams( FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT ) // 设置半透明遮罩 setBackgroundColor(Color.parseColor(\u0026#34;#80000000\u0026#34;)) // 添加点击事件 setOnClickListener { Toast.makeText(this@ImageOverlayActivity, \u0026#34;点击了遮罩层\u0026#34;, Toast.LENGTH_SHORT).show() } } frameLayout.addView(overlayImage) } private fun clearOverlays() { // 移除所有遮罩层（保留背景图片） val childCount = frameLayout.childCount for (i in childCount - 1 downTo 1) { frameLayout.removeViewAt(i) } } } 实际应用场景 # 1. 图片叠加效果 # \u0026lt;FrameLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34;\u0026gt; \u0026lt;!-- 背景图片 --\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:src=\u0026#34;@drawable/background_image\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; /\u0026gt; \u0026lt;!-- 半透明遮罩 --\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#80000000\u0026#34; /\u0026gt; \u0026lt;!-- 文字内容 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;叠加文字\u0026#34; android:textColor=\u0026#34;#FFFFFF\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; 2. 浮动按钮 # \u0026lt;FrameLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;!-- 主内容 --\u0026gt; \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:padding=\u0026#34;16dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;这里是主要内容...\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:lineSpacingMultiplier=\u0026#34;1.5\u0026#34; /\u0026gt; \u0026lt;/ScrollView\u0026gt; \u0026lt;!-- 浮动按钮 --\u0026gt; \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/fab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;bottom|end\u0026#34; android:layout_margin=\u0026#34;16dp\u0026#34; android:src=\u0026#34;@drawable/ic_add\u0026#34; app:backgroundTint=\u0026#34;@color/primary\u0026#34; app:tint=\u0026#34;@color/white\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; 3. 加载遮罩 # class LoadingOverlayActivity : AppCompatActivity() { private lateinit var frameLayout: FrameLayout private lateinit var loadButton: Button private lateinit var loadingView: View override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_loading_overlay) initViews() setupClickListeners() } private fun initViews() { frameLayout = findViewById(R.id.frameLayout) loadButton = findViewById(R.id.loadButton) // 创建加载遮罩 loadingView = createLoadingOverlay() } private fun setupClickListeners() { loadButton.setOnClickListener { showLoading() } } private fun createLoadingOverlay(): View { return LinearLayout(this).apply { layoutParams = FrameLayout.LayoutParams( FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT ) orientation = LinearLayout.VERTICAL gravity = Gravity.CENTER setBackgroundColor(Color.parseColor(\u0026#34;#80000000\u0026#34;)) // 添加进度条 val progressBar = ProgressBar(this@LoadingOverlayActivity).apply { layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT ) } addView(progressBar) // 添加文字 val textView = TextView(this@LoadingOverlayActivity).apply { layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT ).apply { topMargin = dpToPx(16) } text = \u0026#34;正在加载...\u0026#34; setTextColor(Color.WHITE) textSize = 16f } addView(textView) // 初始状态隐藏 visibility = View.GONE } } private fun showLoading() { frameLayout.addView(loadingView) loadingView.visibility = View.VISIBLE // 模拟加载过程 Handler(Looper.getMainLooper()).postDelayed({ hideLoading() }, 3000) } private fun hideLoading() { loadingView.visibility = View.GONE frameLayout.removeView(loadingView) Toast.makeText(this, \u0026#34;加载完成\u0026#34;, Toast.LENGTH_SHORT).show() } private fun dpToPx(dp: Int): Int { return (dp * resources.displayMetrics.density).toInt() } } 4. 卡片叠加效果 # \u0026lt;FrameLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;16dp\u0026#34;\u0026gt; \u0026lt;!-- 卡片背景 --\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_marginTop=\u0026#34;8dp\u0026#34; android:background=\u0026#34;@drawable/card_background\u0026#34; android:elevation=\u0026#34;2dp\u0026#34; /\u0026gt; \u0026lt;!-- 卡片内容 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:gravity=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:src=\u0026#34;@drawable/ic_card\u0026#34; android:layout_marginBottom=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;卡片标题\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:layout_marginBottom=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;卡片描述内容\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;#666666\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/FrameLayout\u0026gt; 性能优化建议 # 1. 避免过度层叠 # // 不好的做法：过多层叠 FrameLayout { ImageView { } // 第1层 View { } // 第2层 TextView { } // 第3层 Button { } // 第4层 ImageView { } // 第5层 // ... 更多层 } // 好的做法：合理使用层叠 FrameLayout { ImageView { } // 背景 LinearLayout { // 内容容器 TextView { } Button { } } } 2. 使用 ViewStub 延迟加载 # \u0026lt;FrameLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;!-- 主要内容 --\u0026gt; \u0026lt;TextView android:text=\u0026#34;主要内容\u0026#34; /\u0026gt; \u0026lt;!-- 延迟加载的内容 --\u0026gt; \u0026lt;ViewStub android:id=\u0026#34;@+id/viewStub\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout=\u0026#34;@layout/delayed_content\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; 3. 合理使用前景 # class OptimizedFrameLayout { fun setupForeground(frameLayout: FrameLayout) { // 使用前景而不是额外的View frameLayout.foreground = ContextCompat.getDrawable( frameLayout.context, R.drawable.foreground_overlay ) frameLayout.foregroundGravity = Gravity.CENTER } } 常见问题解决 # 1. 子控件重叠 # \u0026lt;!-- 错误：没有设置layout_gravity --\u0026gt; \u0026lt;FrameLayout\u0026gt; \u0026lt;TextView android:text=\u0026#34;文本1\u0026#34; /\u0026gt; \u0026lt;TextView android:text=\u0026#34;文本2\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;!-- 正确：设置不同的位置 --\u0026gt; \u0026lt;FrameLayout\u0026gt; \u0026lt;TextView android:layout_gravity=\u0026#34;top|start\u0026#34; android:text=\u0026#34;文本1\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_gravity=\u0026#34;bottom|end\u0026#34; android:text=\u0026#34;文本2\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; 2. 触摸事件穿透 # class TouchEventActivity : AppCompatActivity() { private lateinit var frameLayout: FrameLayout private lateinit var overlayView: View override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_touch_event) initViews() setupTouchEvents() } private fun initViews() { frameLayout = findViewById(R.id.frameLayout) overlayView = findViewById(R.id.overlayView) } private fun setupTouchEvents() { // 设置遮罩层不拦截触摸事件 overlayView.setOnTouchListener { _, _ -\u0026gt; // 返回false，让触摸事件穿透到下层 false } } } 📋 总结 # FrameLayout 是 Android 开发中简单而强大的布局容器：\n层叠特性：所有子控件从左上角开始层叠排列 灵活定位：通过 layout_gravity 控制子控件位置 实际应用：图片叠加、浮动按钮、加载遮罩等场景 性能考虑：避免过度层叠，合理使用前景 触摸处理：注意触摸事件的传递和拦截 掌握 FrameLayout 的使用方法对于创建复杂的层叠效果和特殊布局至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/08---framelayout%E5%B8%A7%E5%B8%83%E5%B1%80/","section":"Posts","summary":"详细介绍Android FrameLayout帧布局的使用方法、层叠效果和实际应用场景","title":"FrameLayout 帧布局","type":"posts"},{"content":" ImageView 图片控件 # ImageView 是 Android 中用于显示图片的控件，支持多种图片格式和显示模式。\nImageView 基本属性 # \u0026lt;ImageView android:id=\u0026#34;@+id/imageView\u0026#34; android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:src=\u0026#34;@drawable/sample_image\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; android:background=\u0026#34;@color/image_background\u0026#34; android:padding=\u0026#34;8dp\u0026#34; android:layout_margin=\u0026#34;16dp\u0026#34; /\u0026gt; 图片资源管理 # 资源文件夹说明 # 文件夹 用途 推荐使用场景 drawable 矢量图、形状、选择器 图标、背景、状态选择器 drawable-hdpi 高密度屏幕图片 150dpi 屏幕 drawable-mdpi 中密度屏幕图片 160dpi 屏幕 drawable-xhdpi 超高密度屏幕图片 240dpi 屏幕 drawable-xxhdpi 超超高密度屏幕图片 320dpi 屏幕 drawable-xxxhdpi 超超超高密度屏幕图片 480dpi 屏幕 mipmap 应用图标 启动图标 基本使用 # \u0026lt;!-- 使用 drawable 资源 --\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/imageView1\u0026#34; android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:src=\u0026#34;@drawable/ic_launcher_foreground\u0026#34; /\u0026gt; \u0026lt;!-- 使用 mipmap 资源 --\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/imageView2\u0026#34; android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:src=\u0026#34;@mipmap/ic_launcher\u0026#34; /\u0026gt; 图片显示模式 (scaleType) # ImageView 提供了多种图片缩放模式：\n1. centerCrop（推荐） # 保持宽高比，裁剪多余部分，填满整个ImageView\n\u0026lt;ImageView android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:src=\u0026#34;@drawable/sample_image\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; /\u0026gt; 2. centerInside # 保持宽高比，完整显示图片，可能有空白区域\n\u0026lt;ImageView android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:src=\u0026#34;@drawable/sample_image\u0026#34; android:scaleType=\u0026#34;centerInside\u0026#34; /\u0026gt; 3. fitCenter # 保持宽高比，居中显示，可能有空白区域\n\u0026lt;ImageView android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:src=\u0026#34;@drawable/sample_image\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; /\u0026gt; 4. fitXY # 拉伸图片填满整个ImageView，可能变形\n\u0026lt;ImageView android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:src=\u0026#34;@drawable/sample_image\u0026#34; android:scaleType=\u0026#34;fitXY\u0026#34; /\u0026gt; 5. matrix # 使用矩阵变换，需要自定义\n\u0026lt;ImageView android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:src=\u0026#34;@drawable/sample_image\u0026#34; android:scaleType=\u0026#34;matrix\u0026#34; /\u0026gt; Kotlin 代码示例 # 基本使用 # class MainActivity : AppCompatActivity() { private lateinit var imageView: ImageView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupImageView() } private fun initViews() { imageView = findViewById(R.id.imageView) } private fun setupImageView() { // 设置图片资源 imageView.setImageResource(R.drawable.sample_image) // 设置缩放模式 imageView.scaleType = ImageView.ScaleType.CENTER_CROP // 设置点击事件 imageView.setOnClickListener { Toast.makeText(this, \u0026#34;图片被点击\u0026#34;, Toast.LENGTH_SHORT).show() } // 设置长按事件 imageView.setOnLongClickListener { showImageOptions() true } } private fun showImageOptions() { val options = arrayOf(\u0026#34;保存图片\u0026#34;, \u0026#34;分享图片\u0026#34;, \u0026#34;设为壁纸\u0026#34;) AlertDialog.Builder(this) .setTitle(\u0026#34;图片操作\u0026#34;) .setItems(options) { _, which -\u0026gt; when (which) { 0 -\u0026gt; saveImage() 1 -\u0026gt; shareImage() 2 -\u0026gt; setAsWallpaper() } } .show() } private fun saveImage() { Toast.makeText(this, \u0026#34;图片已保存\u0026#34;, Toast.LENGTH_SHORT).show() } private fun shareImage() { Toast.makeText(this, \u0026#34;分享图片\u0026#34;, Toast.LENGTH_SHORT).show() } private fun setAsWallpaper() { Toast.makeText(this, \u0026#34;设为壁纸\u0026#34;, Toast.LENGTH_SHORT).show() } } 动态切换图片 # class ImageGalleryActivity : AppCompatActivity() { private lateinit var imageView: ImageView private lateinit var prevButton: Button private lateinit var nextButton: Button private val imageList = listOf( R.drawable.image1, R.drawable.image2, R.drawable.image3, R.drawable.image4 ) private var currentIndex = 0 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_image_gallery) initViews() setupImageGallery() } private fun initViews() { imageView = findViewById(R.id.imageView) prevButton = findViewById(R.id.prevButton) nextButton = findViewById(R.id.nextButton) } private fun setupImageGallery() { // 显示第一张图片 updateImage() // 上一张按钮 prevButton.setOnClickListener { currentIndex = if (currentIndex \u0026gt; 0) currentIndex - 1 else imageList.size - 1 updateImage() } // 下一张按钮 nextButton.setOnClickListener { currentIndex = if (currentIndex \u0026lt; imageList.size - 1) currentIndex + 1 else 0 updateImage() } // 图片点击切换 imageView.setOnClickListener { currentIndex = if (currentIndex \u0026lt; imageList.size - 1) currentIndex + 1 else 0 updateImage() } } private fun updateImage() { imageView.setImageResource(imageList[currentIndex]) // 添加切换动画 val fadeIn = AlphaAnimation(0f, 1f) fadeIn.duration = 300 imageView.startAnimation(fadeIn) } } ImageButton 图片按钮 # ImageButton 继承自 ImageView，专门用于显示图片按钮：\n\u0026lt;ImageButton android:id=\u0026#34;@+id/imageButton\u0026#34; android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:src=\u0026#34;@drawable/ic_add\u0026#34; android:background=\u0026#34;@drawable/image_button_background\u0026#34; android:scaleType=\u0026#34;centerInside\u0026#34; android:contentDescription=\u0026#34;添加按钮\u0026#34; /\u0026gt; private fun setupImageButton() { imageButton.setOnClickListener { Toast.makeText(this, \u0026#34;图片按钮被点击\u0026#34;, Toast.LENGTH_SHORT).show() } // 设置不同状态的图片 val stateListDrawable = StateListDrawable() stateListDrawable.addState(intArrayOf(android.R.attr.state_pressed), ContextCompat.getDrawable(this, R.drawable.ic_add_pressed)) stateListDrawable.addState(intArrayOf(), ContextCompat.getDrawable(this, R.drawable.ic_add_normal)) imageButton.background = stateListDrawable } 图片加载优化 # 使用 Glide 加载网络图片 # // 添加依赖：implementation \u0026#39;com.github.bumptech.glide:glide:4.15.1\u0026#39; class NetworkImageActivity : AppCompatActivity() { private lateinit var imageView: ImageView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_network_image) initViews() loadNetworkImage() } private fun initViews() { imageView = findViewById(R.id.imageView) } private fun loadNetworkImage() { val imageUrl = \u0026#34;https://example.com/image.jpg\u0026#34; Glide.with(this) .load(imageUrl) .placeholder(R.drawable.placeholder) // 占位图 .error(R.drawable.error_image) // 错误图 .centerCrop() .into(imageView) } } 图片缓存管理 # class ImageCacheManager { companion object { private const val CACHE_SIZE = 50 * 1024 * 1024 // 50MB fun setupImageCache(context: Context) { val cacheDir = File(context.cacheDir, \u0026#34;image_cache\u0026#34;) if (!cacheDir.exists()) { cacheDir.mkdirs() } } fun clearImageCache(context: Context) { try { val cacheDir = File(context.cacheDir, \u0026#34;image_cache\u0026#34;) if (cacheDir.exists()) { cacheDir.deleteRecursively() } } catch (e: Exception) { Log.e(\u0026#34;ImageCache\u0026#34;, \u0026#34;清除缓存失败\u0026#34;, e) } } } } 图片处理功能 # 图片旋转 # class ImageRotationActivity : AppCompatActivity() { private lateinit var imageView: ImageView private lateinit var rotateButton: Button private var rotationAngle = 0f override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_image_rotation) initViews() setupImageRotation() } private fun initViews() { imageView = findViewById(R.id.imageView) rotateButton = findViewById(R.id.rotateButton) } private fun setupImageRotation() { rotateButton.setOnClickListener { rotationAngle += 90f rotateImage() } } private fun rotateImage() { val rotation = ObjectAnimator.ofFloat(imageView, \u0026#34;rotation\u0026#34;, imageView.rotation, rotationAngle) rotation.duration = 300 rotation.start() } } 图片缩放 # class ImageZoomActivity : AppCompatActivity() { private lateinit var imageView: ImageView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_image_zoom) initViews() setupImageZoom() } private fun initViews() { imageView = findViewById(R.id.imageView) } private fun setupImageZoom() { // 设置触摸监听器实现缩放 imageView.setOnTouchListener { _, event -\u0026gt; when (event.action) { MotionEvent.ACTION_DOWN -\u0026gt; { // 开始缩放 true } MotionEvent.ACTION_MOVE -\u0026gt; { // 处理缩放 true } MotionEvent.ACTION_UP -\u0026gt; { // 结束缩放 true } else -\u0026gt; false } } } } 图片选择器 # 从相册选择图片 # class ImagePickerActivity : AppCompatActivity() { private lateinit var imageView: ImageView private lateinit var selectButton: Button private val REQUEST_CODE_GALLERY = 1001 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_image_picker) initViews() setupImagePicker() } private fun initViews() { imageView = findViewById(R.id.imageView) selectButton = findViewById(R.id.selectButton) } private fun setupImagePicker() { selectButton.setOnClickListener { openImagePicker() } } private fun openImagePicker() { val intent = Intent(Intent.ACTION_PICK) intent.type = \u0026#34;image/*\u0026#34; startActivityForResult(intent, REQUEST_CODE_GALLERY) } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) if (requestCode == REQUEST_CODE_GALLERY \u0026amp;\u0026amp; resultCode == RESULT_OK) { data?.data?.let { uri -\u0026gt; imageView.setImageURI(uri) } } } } 性能优化建议 # 1. 图片压缩 # class ImageCompression { companion object { fun compressImage(bitmap: Bitmap, quality: Int = 80): Bitmap { val outputStream = ByteArrayOutputStream() bitmap.compress(Bitmap.CompressFormat.JPEG, quality, outputStream) val byteArray = outputStream.toByteArray() return BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size) } fun resizeImage(bitmap: Bitmap, maxWidth: Int, maxHeight: Int): Bitmap { val width = bitmap.width val height = bitmap.height val ratio = min(maxWidth.toFloat() / width, maxHeight.toFloat() / height) val newWidth = (width * ratio).toInt() val newHeight = (height * ratio).toInt() return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true) } } } 2. 内存管理 # class ImageMemoryManager { companion object { fun getOptimalImageSize(context: Context, imageView: ImageView): Pair\u0026lt;Int, Int\u0026gt; { val displayMetrics = context.resources.displayMetrics val screenWidth = displayMetrics.widthPixels val screenHeight = displayMetrics.heightPixels // 根据屏幕尺寸计算最佳图片尺寸 val optimalWidth = screenWidth / 2 val optimalHeight = screenHeight / 3 return Pair(optimalWidth, optimalHeight) } fun recycleBitmap(bitmap: Bitmap?) { bitmap?.let { if (!it.isRecycled) { it.recycle() } } } } } 📋 总结 # ImageView 是 Android 开发中重要的图片显示控件：\n多种缩放模式：centerCrop、centerInside、fitCenter 等 资源管理：合理使用 drawable 和 mipmap 文件夹 性能优化：图片压缩、缓存管理、内存控制 功能扩展：图片选择、旋转、缩放等交互功能 第三方库：使用 Glide、Picasso 等库优化网络图片加载 掌握 ImageView 的使用方法和优化技巧是 Android 开发的重要技能。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/06---imageview%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"详细介绍Android ImageView图片控件的使用方法、属性配置、图片加载和缩放模式","title":"ImageView 图片控件","type":"posts"},{"content":" LinearLayout 线性布局 # LinearLayout 是 Android 中最常用的布局容器，它按照水平或垂直方向依次排列子控件。\nLinearLayout 基本属性 # \u0026lt;LinearLayout android:id=\u0026#34;@+id/linearLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;@color/background_color\u0026#34;\u0026gt; \u0026lt;!-- 子控件 --\u0026gt; \u0026lt;/LinearLayout\u0026gt; 核心属性详解 # 1. orientation（方向） # 控制子控件的排列方向：\n\u0026lt;!-- 垂直排列（默认） --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:text=\u0026#34;第一行\u0026#34; /\u0026gt; \u0026lt;TextView android:text=\u0026#34;第二行\u0026#34; /\u0026gt; \u0026lt;TextView android:text=\u0026#34;第三行\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 水平排列 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:text=\u0026#34;第一列\u0026#34; /\u0026gt; \u0026lt;TextView android:text=\u0026#34;第二列\u0026#34; /\u0026gt; \u0026lt;TextView android:text=\u0026#34;第三列\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 2. layout_weight（权重） # 按比例分配剩余空间：\n\u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;!-- 占1/3空间 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;三分之一\u0026#34; android:background=\u0026#34;#FF5722\u0026#34; /\u0026gt; \u0026lt;!-- 占2/3空间 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;2\u0026#34; android:text=\u0026#34;三分之二\u0026#34; android:background=\u0026#34;#2196F3\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 3. gravity（对齐方式） # 控制子控件在容器中的对齐方式：\n\u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;TextView android:text=\u0026#34;居中对齐\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Kotlin 代码示例 # 动态创建 LinearLayout # class DynamicLinearLayoutActivity : AppCompatActivity() { private lateinit var containerLayout: LinearLayout override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_dynamic_linear_layout) initViews() createDynamicLayout() } private fun initViews() { containerLayout = findViewById(R.id.containerLayout) } private fun createDynamicLayout() { // 创建水平布局 val horizontalLayout = LinearLayout(this).apply { orientation = LinearLayout.HORIZONTAL layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT ) gravity = Gravity.CENTER setPadding(16, 16, 16, 16) } // 添加按钮 repeat(3) { index -\u0026gt; val button = Button(this).apply { text = \u0026#34;按钮 ${index + 1}\u0026#34; layoutParams = LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT ).apply { marginEnd = if (index \u0026lt; 2) 16 else 0 } setOnClickListener { Toast.makeText(this@DynamicLinearLayoutActivity, \u0026#34;按钮 ${index + 1} 被点击\u0026#34;, Toast.LENGTH_SHORT).show() } } horizontalLayout.addView(button) } containerLayout.addView(horizontalLayout) } } 权重分配示例 # class WeightDistributionActivity : AppCompatActivity() { private lateinit var containerLayout: LinearLayout override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_weight_distribution) initViews() setupWeightDistribution() } private fun initViews() { containerLayout = findViewById(R.id.containerLayout) } private fun setupWeightDistribution() { val weights = listOf(1, 2, 3) // 权重比例 1:2:3 weights.forEachIndexed { index, weight -\u0026gt; val textView = TextView(this).apply { text = \u0026#34;权重: $weight\u0026#34; gravity = Gravity.CENTER setTextColor(Color.WHITE) setPadding(16, 16, 16, 16) layoutParams = LinearLayout.LayoutParams( 0, // 宽度设为0，让权重生效 LinearLayout.LayoutParams.MATCH_PARENT ).apply { this.weight = weight.toFloat() } // 设置不同颜色 setBackgroundColor( when (index) { 0 -\u0026gt; Color.parseColor(\u0026#34;#FF5722\u0026#34;) 1 -\u0026gt; Color.parseColor(\u0026#34;#2196F3\u0026#34;) 2 -\u0026gt; Color.parseColor(\u0026#34;#4CAF50\u0026#34;) else -\u0026gt; Color.GRAY } ) } containerLayout.addView(textView) } } } 实际应用场景 # 1. 登录表单布局 # \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:padding=\u0026#34;24dp\u0026#34;\u0026gt; \u0026lt;!-- Logo --\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;120dp\u0026#34; android:layout_height=\u0026#34;120dp\u0026#34; android:src=\u0026#34;@drawable/logo\u0026#34; android:layout_marginBottom=\u0026#34;32dp\u0026#34; /\u0026gt; \u0026lt;!-- 用户名输入框 --\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/usernameEditText\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入用户名\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;@drawable/edit_text_background\u0026#34; /\u0026gt; \u0026lt;!-- 密码输入框 --\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/passwordEditText\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入密码\u0026#34; android:inputType=\u0026#34;textPassword\u0026#34; android:layout_marginBottom=\u0026#34;24dp\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;@drawable/edit_text_background\u0026#34; /\u0026gt; \u0026lt;!-- 登录按钮 --\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/loginButton\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;登录\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;@drawable/button_background\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 2. 底部导航栏 # \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:background=\u0026#34;@color/bottom_nav_background\u0026#34; android:gravity=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;!-- 首页 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:clickable=\u0026#34;true\u0026#34; android:background=\u0026#34;?android:attr/selectableItemBackground\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;24dp\u0026#34; android:layout_height=\u0026#34;24dp\u0026#34; android:src=\u0026#34;@drawable/ic_home\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;首页\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 其他导航项... --\u0026gt; \u0026lt;/LinearLayout\u0026gt; 3. 商品列表项 # \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;?android:attr/selectableItemBackground\u0026#34; android:clickable=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- 商品图片 --\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;80dp\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:src=\u0026#34;@drawable/product_image\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;!-- 商品信息 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;商品名称\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:layout_marginBottom=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;商品描述\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;#666666\u0026#34; android:layout_marginBottom=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;¥99.00\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textColor=\u0026#34;#FF5722\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 操作按钮 --\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;加入购物车\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 嵌套布局示例 # 复杂表单布局 # \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;16dp\u0026#34;\u0026gt; \u0026lt;!-- 个人信息部分 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;个人信息\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34;\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:hint=\u0026#34;姓名\u0026#34; android:layout_marginEnd=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:hint=\u0026#34;年龄\u0026#34; android:inputType=\u0026#34;number\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 联系方式部分 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;联系方式\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;手机号码\u0026#34; android:inputType=\u0026#34;phone\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;邮箱地址\u0026#34; android:inputType=\u0026#34;textEmailAddress\u0026#34; android:layout_marginBottom=\u0026#34;24dp\u0026#34; /\u0026gt; \u0026lt;!-- 提交按钮 --\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;提交\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:padding=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/ScrollView\u0026gt; 性能优化建议 # 1. 避免过度嵌套 # // 不好的做法：过度嵌套 LinearLayout { LinearLayout { LinearLayout { TextView { } } } } // 好的做法：使用ConstraintLayout替代 ConstraintLayout { TextView { } } 2. 使用 ViewStub 延迟加载 # \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;!-- 主要内容 --\u0026gt; \u0026lt;TextView android:text=\u0026#34;主要内容\u0026#34; /\u0026gt; \u0026lt;!-- 延迟加载的内容 --\u0026gt; \u0026lt;ViewStub android:id=\u0026#34;@+id/viewStub\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout=\u0026#34;@layout/delayed_content\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 3. 合理使用权重 # // 避免不必要的权重计算 class OptimizedLinearLayout { fun setupOptimizedLayout() { // 使用固定尺寸而不是权重 val layoutParams = LinearLayout.LayoutParams( resources.getDimensionPixelSize(R.dimen.button_width), LinearLayout.LayoutParams.WRAP_CONTENT ) // 只在必要时使用权重 val weightParams = LinearLayout.LayoutParams( 0, LinearLayout.LayoutParams.MATCH_PARENT ).apply { weight = 1f // 只在需要按比例分配时使用 } } } 常见问题解决 # 1. 权重不生效 # \u0026lt;!-- 错误：设置了具体宽度 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- 正确：宽度设为0dp --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; /\u0026gt; 2. 子控件超出容器 # \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;!-- 使用权重避免超出 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;很长的文本内容...\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 📋 总结 # LinearLayout 是 Android 开发中最基础的布局容器：\n简单易用：按方向排列子控件，逻辑清晰 权重分配：灵活控制空间分配比例 嵌套布局：支持复杂的布局结构 性能考虑：避免过度嵌套，合理使用权重 实际应用：表单、列表、导航等常见场景 掌握 LinearLayout 的使用方法是 Android 布局开发的基础。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/02---linear-layout-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80/","section":"Posts","summary":"详细介绍Android LinearLayout线性布局的使用方法、属性配置和实际应用场景","title":"LinearLayout 线性布局","type":"posts"},{"content":" Menu 菜单组件 # Android 提供了多种菜单组件，用于不同的用户交互场景。本文将详细介绍各种菜单的使用方法。\nOptionMenu 选项菜单 # OptionMenu 是应用的主菜单，通常显示在 ActionBar 或标题栏中，用于放置对应用产生全局影响的操作。\n基本属性 # 属性 说明 示例值 android:id 菜单项ID @+id/menu_item android:title 菜单项标题 \u0026quot;设置\u0026quot; android:icon 菜单项图标 @drawable/ic_settings android:showAsAction 显示方式 always, never, ifRoom 创建菜单资源 # \u0026lt;!-- res/menu/main_menu.xml --\u0026gt; \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_settings\u0026#34; android:title=\u0026#34;设置\u0026#34; android:icon=\u0026#34;@drawable/ic_settings\u0026#34; app:showAsAction=\u0026#34;ifRoom\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_help\u0026#34; android:title=\u0026#34;帮助\u0026#34; android:icon=\u0026#34;@drawable/ic_help\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_about\u0026#34; android:title=\u0026#34;关于\u0026#34; android:icon=\u0026#34;@drawable/ic_info\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; Kotlin 代码示例 # class OptionMenuActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_option_menu) // 设置 ActionBar setSupportActionBar(findViewById(R.id.toolbar)) } override fun onCreateOptionsMenu(menu: Menu?): Boolean { menuInflater.inflate(R.menu.main_menu, menu) return true } override fun onOptionsItemSelected(item: MenuItem): Boolean { return when (item.itemId) { R.id.menu_settings -\u0026gt; { openSettings() true } R.id.menu_help -\u0026gt; { showHelp() true } R.id.menu_about -\u0026gt; { showAbout() true } else -\u0026gt; super.onOptionsItemSelected(item) } } private fun openSettings() { Toast.makeText(this, \u0026#34;打开设置\u0026#34;, Toast.LENGTH_SHORT).show() // 启动设置页面 // startActivity(Intent(this, SettingsActivity::class.java)) } private fun showHelp() { Toast.makeText(this, \u0026#34;显示帮助\u0026#34;, Toast.LENGTH_SHORT).show() // 显示帮助对话框 } private fun showAbout() { Toast.makeText(this, \u0026#34;显示关于\u0026#34;, Toast.LENGTH_SHORT).show() // 显示关于对话框 } } 动态创建菜单 # class DynamicOptionMenuActivity : AppCompatActivity() { private val menuItems = mutableListOf(\u0026#34;菜单项1\u0026#34;, \u0026#34;菜单项2\u0026#34;, \u0026#34;菜单项3\u0026#34;) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_dynamic_option_menu) setSupportActionBar(findViewById(R.id.toolbar)) } override fun onCreateOptionsMenu(menu: Menu?): Boolean { menu?.let { // 动态添加菜单项 menuItems.forEachIndexed { index, title -\u0026gt; it.add(Menu.NONE, index, Menu.NONE, title) } // 添加分隔符 it.add(Menu.NONE, Menu.NONE, Menu.NONE, \u0026#34;分隔符\u0026#34;) .setEnabled(false) // 添加更多菜单项 it.add(Menu.NONE, 999, Menu.NONE, \u0026#34;更多选项\u0026#34;) } return true } override fun onOptionsItemSelected(item: MenuItem): Boolean { return when (item.itemId) { in 0 until menuItems.size -\u0026gt; { Toast.makeText(this, \u0026#34;选择了: ${menuItems[item.itemId]}\u0026#34;, Toast.LENGTH_SHORT).show() true } 999 -\u0026gt; { Toast.makeText(this, \u0026#34;更多选项\u0026#34;, Toast.LENGTH_SHORT).show() true } else -\u0026gt; super.onOptionsItemSelected(item) } } } ContextMenu 上下文菜单 # ContextMenu 是长按某个 View 时弹出的菜单，提供与该 View 相关的操作选项。\n基本使用 # class ContextMenuActivity : AppCompatActivity() { private lateinit var textView: TextView private lateinit var imageView: ImageView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_context_menu) initViews() registerContextMenus() } private fun initViews() { textView = findViewById(R.id.textView) imageView = findViewById(R.id.imageView) } private fun registerContextMenus() { // 注册上下文菜单 registerForContextMenu(textView) registerForContextMenu(imageView) } override fun onCreateContextMenu( menu: ContextMenu?, v: View?, menuInfo: ContextMenu.ContextMenuInfo? ) { super.onCreateContextMenu(menu, v, menuInfo) when (v?.id) { R.id.textView -\u0026gt; { menuInflater.inflate(R.menu.text_context_menu, menu) } R.id.imageView -\u0026gt; { menuInflater.inflate(R.menu.image_context_menu, menu) } } } override fun onContextItemSelected(item: MenuItem): Boolean { return when (item.itemId) { R.id.menu_copy -\u0026gt; { copyText() true } R.id.menu_paste -\u0026gt; { pasteText() true } R.id.menu_share -\u0026gt; { shareContent() true } R.id.menu_delete -\u0026gt; { deleteItem() true } R.id.menu_edit -\u0026gt; { editItem() true } else -\u0026gt; super.onContextItemSelected(item) } } private fun copyText() { Toast.makeText(this, \u0026#34;复制文本\u0026#34;, Toast.LENGTH_SHORT).show() } private fun pasteText() { Toast.makeText(this, \u0026#34;粘贴文本\u0026#34;, Toast.LENGTH_SHORT).show() } private fun shareContent() { Toast.makeText(this, \u0026#34;分享内容\u0026#34;, Toast.LENGTH_SHORT).show() } private fun deleteItem() { Toast.makeText(this, \u0026#34;删除项目\u0026#34;, Toast.LENGTH_SHORT).show() } private fun editItem() { Toast.makeText(this, \u0026#34;编辑项目\u0026#34;, Toast.LENGTH_SHORT).show() } } 上下文菜单资源 # \u0026lt;!-- res/menu/text_context_menu.xml --\u0026gt; \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_copy\u0026#34; android:title=\u0026#34;复制\u0026#34; android:icon=\u0026#34;@drawable/ic_copy\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_paste\u0026#34; android:title=\u0026#34;粘贴\u0026#34; android:icon=\u0026#34;@drawable/ic_paste\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_share\u0026#34; android:title=\u0026#34;分享\u0026#34; android:icon=\u0026#34;@drawable/ic_share\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; \u0026lt;!-- res/menu/image_context_menu.xml --\u0026gt; \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_share\u0026#34; android:title=\u0026#34;分享\u0026#34; android:icon=\u0026#34;@drawable/ic_share\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_delete\u0026#34; android:title=\u0026#34;删除\u0026#34; android:icon=\u0026#34;@drawable/ic_delete\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_edit\u0026#34; android:title=\u0026#34;编辑\u0026#34; android:icon=\u0026#34;@drawable/ic_edit\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; PopupMenu 弹出菜单 # PopupMenu 是模态形式的弹出菜单，通常绑定在某个 View 上，出现在被绑定 View 的下方。\n基本使用 # class PopupMenuActivity : AppCompatActivity() { private lateinit var showMenuButton: Button private lateinit var anchorView: View override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_popup_menu) initViews() setupPopupMenu() } private fun initViews() { showMenuButton = findViewById(R.id.showMenuButton) anchorView = findViewById(R.id.anchorView) } private fun setupPopupMenu() { showMenuButton.setOnClickListener { showPopupMenu(it) } anchorView.setOnClickListener { showPopupMenu(it) } } private fun showPopupMenu(anchor: View) { val popupMenu = PopupMenu(this, anchor) popupMenu.menuInflater.inflate(R.menu.popup_menu, popupMenu.menu) // 设置菜单项点击监听器 popupMenu.setOnMenuItemClickListener { item -\u0026gt; handlePopupMenuItemClick(item) true } // 设置菜单关闭监听器 popupMenu.setOnDismissListener { Toast.makeText(this, \u0026#34;菜单已关闭\u0026#34;, Toast.LENGTH_SHORT).show() } popupMenu.show() } private fun handlePopupMenuItemClick(item: MenuItem): Boolean { return when (item.itemId) { R.id.menu_item1 -\u0026gt; { Toast.makeText(this, \u0026#34;选择了菜单项1\u0026#34;, Toast.LENGTH_SHORT).show() true } R.id.menu_item2 -\u0026gt; { Toast.makeText(this, \u0026#34;选择了菜单项2\u0026#34;, Toast.LENGTH_SHORT).show() true } R.id.menu_item3 -\u0026gt; { Toast.makeText(this, \u0026#34;选择了菜单项3\u0026#34;, Toast.LENGTH_SHORT).show() true } else -\u0026gt; false } } } 动态创建 PopupMenu # class DynamicPopupMenuActivity : AppCompatActivity() { private lateinit var showMenuButton: Button private val menuItems = mutableListOf(\u0026#34;动态菜单1\u0026#34;, \u0026#34;动态菜单2\u0026#34;, \u0026#34;动态菜单3\u0026#34;) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_dynamic_popup_menu) initViews() setupDynamicPopupMenu() } private fun initViews() { showMenuButton = findViewById(R.id.showMenuButton) } private fun setupDynamicPopupMenu() { showMenuButton.setOnClickListener { showDynamicPopupMenu(it) } } private fun showDynamicPopupMenu(anchor: View) { val popupMenu = PopupMenu(this, anchor) // 动态添加菜单项 menuItems.forEachIndexed { index, title -\u0026gt; popupMenu.menu.add(Menu.NONE, index, Menu.NONE, title) } // 添加分隔符 popupMenu.menu.add(Menu.NONE, Menu.NONE, Menu.NONE, \u0026#34;分隔符\u0026#34;) .setEnabled(false) // 添加更多选项 popupMenu.menu.add(Menu.NONE, 999, Menu.NONE, \u0026#34;添加新项\u0026#34;) popupMenu.setOnMenuItemClickListener { item -\u0026gt; when (item.itemId) { in 0 until menuItems.size -\u0026gt; { Toast.makeText(this, \u0026#34;选择了: ${menuItems[item.itemId]}\u0026#34;, Toast.LENGTH_SHORT).show() true } 999 -\u0026gt; { addNewMenuItem() true } else -\u0026gt; false } } popupMenu.show() } private fun addNewMenuItem() { val newItem = \u0026#34;动态菜单${menuItems.size + 1}\u0026#34; menuItems.add(newItem) Toast.makeText(this, \u0026#34;添加了新菜单项: $newItem\u0026#34;, Toast.LENGTH_SHORT).show() } } PopupMenu 资源文件 # \u0026lt;!-- res/menu/popup_menu.xml --\u0026gt; \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_item1\u0026#34; android:title=\u0026#34;菜单项1\u0026#34; android:icon=\u0026#34;@drawable/ic_item1\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_item2\u0026#34; android:title=\u0026#34;菜单项2\u0026#34; android:icon=\u0026#34;@drawable/ic_item2\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_item3\u0026#34; android:title=\u0026#34;菜单项3\u0026#34; android:icon=\u0026#34;@drawable/ic_item3\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; 实际应用场景 # 1. 列表项操作菜单 # class ListItemMenuActivity : AppCompatActivity() { private lateinit var recyclerView: RecyclerView private lateinit var adapter: ItemAdapter override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_list_item_menu) initViews() setupRecyclerView() } private fun initViews() { recyclerView = findViewById(R.id.recyclerView) } private fun setupRecyclerView() { val items = listOf(\u0026#34;项目1\u0026#34;, \u0026#34;项目2\u0026#34;, \u0026#34;项目3\u0026#34;, \u0026#34;项目4\u0026#34;, \u0026#34;项目5\u0026#34;) adapter = ItemAdapter(items) { item, view -\u0026gt; showItemMenu(item, view) } recyclerView.adapter = adapter recyclerView.layoutManager = LinearLayoutManager(this) } private fun showItemMenu(item: String, anchorView: View) { val popupMenu = PopupMenu(this, anchorView) popupMenu.menuInflater.inflate(R.menu.list_item_menu, popupMenu.menu) popupMenu.setOnMenuItemClickListener { menuItem -\u0026gt; when (menuItem.itemId) { R.id.menu_edit -\u0026gt; { editItem(item) true } R.id.menu_delete -\u0026gt; { deleteItem(item) true } R.id.menu_share -\u0026gt; { shareItem(item) true } else -\u0026gt; false } } popupMenu.show() } private fun editItem(item: String) { Toast.makeText(this, \u0026#34;编辑: $item\u0026#34;, Toast.LENGTH_SHORT).show() } private fun deleteItem(item: String) { Toast.makeText(this, \u0026#34;删除: $item\u0026#34;, Toast.LENGTH_SHORT).show() } private fun shareItem(item: String) { Toast.makeText(this, \u0026#34;分享: $item\u0026#34;, Toast.LENGTH_SHORT).show() } } class ItemAdapter( private val items: List\u0026lt;String\u0026gt;, private val onItemClick: (String, View) -\u0026gt; Unit ) : RecyclerView.Adapter\u0026lt;ItemAdapter.ViewHolder\u0026gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder { val view = LayoutInflater.from(parent.context) .inflate(R.layout.item_list, parent, false) return ViewHolder(view) } override fun onBindViewHolder(holder: ViewHolder, position: Int) { holder.bind(items[position]) } override fun getItemCount(): Int = items.size inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { private val textView: TextView = itemView.findViewById(R.id.textView) private val menuButton: Button = itemView.findViewById(R.id.menuButton) fun bind(item: String) { textView.text = item menuButton.setOnClickListener { onItemClick(item, it) } } } } 2. 工具栏菜单 # class ToolbarMenuActivity : AppCompatActivity() { private lateinit var toolbar: Toolbar private lateinit var searchView: SearchView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_toolbar_menu) initViews() setupToolbar() } private fun initViews() { toolbar = findViewById(R.id.toolbar) } private fun setupToolbar() { setSupportActionBar(toolbar) supportActionBar?.setDisplayHomeAsUpEnabled(true) } override fun onCreateOptionsMenu(menu: Menu?): Boolean { menuInflater.inflate(R.menu.toolbar_menu, menu) // 设置搜索视图 val searchItem = menu?.findItem(R.id.menu_search) searchView = searchItem?.actionView as SearchView searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener { override fun onQueryTextSubmit(query: String?): Boolean { performSearch(query) return true } override fun onQueryTextChange(newText: String?): Boolean { // 实时搜索 return true } }) return true } override fun onOptionsItemSelected(item: MenuItem): Boolean { return when (item.itemId) { android.R.id.home -\u0026gt; { onBackPressed() true } R.id.menu_search -\u0026gt; { searchView.isIconified = false true } R.id.menu_filter -\u0026gt; { showFilterDialog() true } R.id.menu_sort -\u0026gt; { showSortDialog() true } else -\u0026gt; super.onOptionsItemSelected(item) } } private fun performSearch(query: String?) { Toast.makeText(this, \u0026#34;搜索: $query\u0026#34;, Toast.LENGTH_SHORT).show() } private fun showFilterDialog() { Toast.makeText(this, \u0026#34;显示筛选对话框\u0026#34;, Toast.LENGTH_SHORT).show() } private fun showSortDialog() { Toast.makeText(this, \u0026#34;显示排序对话框\u0026#34;, Toast.LENGTH_SHORT).show() } } 3. 工具栏菜单资源 # \u0026lt;!-- res/menu/toolbar_menu.xml --\u0026gt; \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_search\u0026#34; android:title=\u0026#34;搜索\u0026#34; android:icon=\u0026#34;@drawable/ic_search\u0026#34; app:actionViewClass=\u0026#34;androidx.appcompat.widget.SearchView\u0026#34; app:showAsAction=\u0026#34;ifRoom\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_filter\u0026#34; android:title=\u0026#34;筛选\u0026#34; android:icon=\u0026#34;@drawable/ic_filter\u0026#34; app:showAsAction=\u0026#34;ifRoom\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_sort\u0026#34; android:title=\u0026#34;排序\u0026#34; android:icon=\u0026#34;@drawable/ic_sort\u0026#34; app:showAsAction=\u0026#34;never\u0026#34; /\u0026gt; \u0026lt;/menu\u0026gt; 菜单最佳实践 # 1. 菜单项分组 # \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;group android:id=\u0026#34;@+id/group_main\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_home\u0026#34; android:title=\u0026#34;首页\u0026#34; android:icon=\u0026#34;@drawable/ic_home\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_profile\u0026#34; android:title=\u0026#34;个人资料\u0026#34; android:icon=\u0026#34;@drawable/ic_profile\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;group android:id=\u0026#34;@+id/group_settings\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_settings\u0026#34; android:title=\u0026#34;设置\u0026#34; android:icon=\u0026#34;@drawable/ic_settings\u0026#34; /\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/menu_help\u0026#34; android:title=\u0026#34;帮助\u0026#34; android:icon=\u0026#34;@drawable/ic_help\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/menu\u0026gt; 2. 菜单项状态管理 # class MenuStateActivity : AppCompatActivity() { private var isEditMode = false override fun onCreateOptionsMenu(menu: Menu?): Boolean { menuInflater.inflate(R.menu.state_menu, menu) updateMenuState(menu) return true } private fun updateMenuState(menu: Menu?) { menu?.let { val editItem = it.findItem(R.id.menu_edit) val saveItem = it.findItem(R.id.menu_save) val cancelItem = it.findItem(R.id.menu_cancel) editItem?.isVisible = !isEditMode saveItem?.isVisible = isEditMode cancelItem?.isVisible = isEditMode } } override fun onOptionsItemSelected(item: MenuItem): Boolean { return when (item.itemId) { R.id.menu_edit -\u0026gt; { enterEditMode() true } R.id.menu_save -\u0026gt; { saveChanges() true } R.id.menu_cancel -\u0026gt; { cancelEdit() true } else -\u0026gt; super.onOptionsItemSelected(item) } } private fun enterEditMode() { isEditMode = true invalidateOptionsMenu() Toast.makeText(this, \u0026#34;进入编辑模式\u0026#34;, Toast.LENGTH_SHORT).show() } private fun saveChanges() { isEditMode = false invalidateOptionsMenu() Toast.makeText(this, \u0026#34;保存更改\u0026#34;, Toast.LENGTH_SHORT).show() } private fun cancelEdit() { isEditMode = false invalidateOptionsMenu() Toast.makeText(this, \u0026#34;取消编辑\u0026#34;, Toast.LENGTH_SHORT).show() } } 📋 总结 # Android Menu 组件提供了丰富的菜单交互方式：\nOptionMenu：主菜单，显示在 ActionBar 中 ContextMenu：上下文菜单，长按触发 PopupMenu：弹出菜单，绑定到特定 View 动态创建：支持程序动态添加菜单项 状态管理：支持菜单项状态切换和分组 掌握这些菜单组件的使用方法对于创建良好的用户交互体验至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/12---menu%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6/","section":"Posts","summary":"详细介绍Android Menu菜单组件的使用方法，包括OptionMenu、ContextMenu和PopupMenu","title":"Menu 菜单组件","type":"posts"},{"content":" PopupWindow 弹窗 # PopupWindow 是 Android 中用于显示浮动窗口的组件，可以在指定位置弹出自定义的视图内容。\nPopupWindow 基本概念 # PopupWindow 是一个可以在当前 Activity 之上显示的浮动窗口，常用于显示菜单、提示信息或自定义内容。\n基本属性 # 属性 说明 示例值 width 弹窗宽度 ViewGroup.LayoutParams.WRAP_CONTENT height 弹窗高度 ViewGroup.LayoutParams.WRAP_CONTENT focusable 是否可获得焦点 true, false outsideTouchable 外部点击是否关闭 true, false animationStyle 动画样式 R.style.PopupAnimation 基本使用示例 # 1. 简单弹窗 # class PopupWindowActivity : AppCompatActivity() { private lateinit var showPopupButton: Button private lateinit var popupWindow: PopupWindow override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_popup_window) initViews() setupPopupWindow() setupClickListeners() } private fun initViews() { showPopupButton = findViewById(R.id.showPopupButton) } private fun setupPopupWindow() { // 创建弹窗内容视图 val popupView = layoutInflater.inflate(R.layout.popup_content, null) // 创建 PopupWindow popupWindow = PopupWindow( popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true ) // 设置弹窗属性 popupWindow.isOutsideTouchable = true popupWindow.isTouchable = true // 设置弹窗内容点击事件 setupPopupContent(popupView) } private fun setupPopupContent(popupView: View) { val item1 = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.item1) val item2 = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.item2) val item3 = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.item3) item1.setOnClickListener { Toast.makeText(this, \u0026#34;点击了选项1\u0026#34;, Toast.LENGTH_SHORT).show() popupWindow.dismiss() } item2.setOnClickListener { Toast.makeText(this, \u0026#34;点击了选项2\u0026#34;, Toast.LENGTH_SHORT).show() popupWindow.dismiss() } item3.setOnClickListener { Toast.makeText(this, \u0026#34;点击了选项3\u0026#34;, Toast.LENGTH_SHORT).show() popupWindow.dismiss() } } private fun setupClickListeners() { showPopupButton.setOnClickListener { showPopupWindow(it) } } private fun showPopupWindow(anchorView: View) { popupWindow.showAsDropDown(anchorView) } } 2. 自定义位置弹窗 # class CustomPositionPopupActivity : AppCompatActivity() { private lateinit var showPopupButton: Button private lateinit var popupWindow: PopupWindow override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_custom_position_popup) initViews() setupPopupWindow() setupClickListeners() } private fun initViews() { showPopupButton = findViewById(R.id.showPopupButton) } private fun setupPopupWindow() { val popupView = layoutInflater.inflate(R.layout.popup_custom_content, null) popupWindow = PopupWindow( popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true ) popupWindow.isOutsideTouchable = true popupWindow.isTouchable = true setupPopupContent(popupView) } private fun setupPopupContent(popupView: View) { val editText = popupView.findViewById\u0026lt;EditText\u0026gt;(R.id.editText) val confirmButton = popupView.findViewById\u0026lt;Button\u0026gt;(R.id.confirmButton) val cancelButton = popupView.findViewById\u0026lt;Button\u0026gt;(R.id.cancelButton) confirmButton.setOnClickListener { val inputText = editText.text.toString() if (inputText.isNotEmpty()) { Toast.makeText(this, \u0026#34;输入内容: $inputText\u0026#34;, Toast.LENGTH_SHORT).show() popupWindow.dismiss() } else { Toast.makeText(this, \u0026#34;请输入内容\u0026#34;, Toast.LENGTH_SHORT).show() } } cancelButton.setOnClickListener { popupWindow.dismiss() } } private fun setupClickListeners() { showPopupButton.setOnClickListener { showPopupAtCustomPosition(it) } } private fun showPopupAtCustomPosition(anchorView: View) { // 获取锚点视图的位置 val location = IntArray(2) anchorView.getLocationOnScreen(location) // 计算弹窗位置（在锚点视图上方） val x = location[0] val y = location[1] - dpToPx(200) // 向上偏移200dp popupWindow.showAtLocation(anchorView, Gravity.NO_GRAVITY, x, y) } private fun dpToPx(dp: Int): Int { return (dp * resources.displayMetrics.density).toInt() } } 3. 带动画的弹窗 # class AnimatedPopupActivity : AppCompatActivity() { private lateinit var showAnimatedPopupButton: Button private lateinit var popupWindow: PopupWindow override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_animated_popup) initViews() setupAnimatedPopupWindow() setupClickListeners() } private fun initViews() { showAnimatedPopupButton = findViewById(R.id.showAnimatedPopupButton) } private fun setupAnimatedPopupWindow() { val popupView = layoutInflater.inflate(R.layout.popup_animated_content, null) popupWindow = PopupWindow( popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true ) popupWindow.isOutsideTouchable = true popupWindow.isTouchable = true // 设置动画样式 popupWindow.animationStyle = R.style.PopupAnimation setupPopupContent(popupView) } private fun setupPopupContent(popupView: View) { val titleText = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.titleText) val contentText = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.contentText) val closeButton = popupView.findViewById\u0026lt;Button\u0026gt;(R.id.closeButton) titleText.text = \u0026#34;动画弹窗\u0026#34; contentText.text = \u0026#34;这是一个带有动画效果的弹窗\u0026#34; closeButton.setOnClickListener { popupWindow.dismiss() } } private fun setupClickListeners() { showAnimatedPopupButton.setOnClickListener { showAnimatedPopup(it) } } private fun showAnimatedPopup(anchorView: View) { popupWindow.showAsDropDown(anchorView, 0, -dpToPx(10)) } private fun dpToPx(dp: Int): Int { return (dp * resources.displayMetrics.density).toInt() } } 弹窗动画 # 1. 创建动画资源 # \u0026lt;!-- res/anim/popup_enter.xml --\u0026gt; \u0026lt;set xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;alpha android:duration=\u0026#34;300\u0026#34; android:fromAlpha=\u0026#34;0.0\u0026#34; android:toAlpha=\u0026#34;1.0\u0026#34; /\u0026gt; \u0026lt;scale android:duration=\u0026#34;300\u0026#34; android:fromXScale=\u0026#34;0.5\u0026#34; android:fromYScale=\u0026#34;0.5\u0026#34; android:pivotX=\u0026#34;50%\u0026#34; android:pivotY=\u0026#34;50%\u0026#34; android:toXScale=\u0026#34;1.0\u0026#34; android:toYScale=\u0026#34;1.0\u0026#34; /\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;!-- res/anim/popup_exit.xml --\u0026gt; \u0026lt;set xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;alpha android:duration=\u0026#34;200\u0026#34; android:fromAlpha=\u0026#34;1.0\u0026#34; android:toAlpha=\u0026#34;0.0\u0026#34; /\u0026gt; \u0026lt;scale android:duration=\u0026#34;200\u0026#34; android:fromXScale=\u0026#34;1.0\u0026#34; android:fromYScale=\u0026#34;1.0\u0026#34; android:pivotX=\u0026#34;50%\u0026#34; android:pivotY=\u0026#34;50%\u0026#34; android:toXScale=\u0026#34;0.5\u0026#34; android:toYScale=\u0026#34;0.5\u0026#34; /\u0026gt; \u0026lt;/set\u0026gt; 2. 创建动画样式 # \u0026lt;!-- res/values/styles.xml --\u0026gt; \u0026lt;style name=\u0026#34;PopupAnimation\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowEnterAnimation\u0026#34;\u0026gt;@anim/popup_enter\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:windowExitAnimation\u0026#34;\u0026gt;@anim/popup_exit\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 3. 使用动画弹窗 # class AnimationPopupActivity : AppCompatActivity() { private lateinit var showAnimationPopupButton: Button private lateinit var popupWindow: PopupWindow override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_animation_popup) initViews() setupAnimationPopupWindow() setupClickListeners() } private fun initViews() { showAnimationPopupButton = findViewById(R.id.showAnimationPopupButton) } private fun setupAnimationPopupWindow() { val popupView = layoutInflater.inflate(R.layout.popup_animation_content, null) popupWindow = PopupWindow( popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true ) popupWindow.isOutsideTouchable = true popupWindow.isTouchable = true popupWindow.animationStyle = R.style.PopupAnimation setupPopupContent(popupView) } private fun setupPopupContent(popupView: View) { val slideButton = popupView.findViewById\u0026lt;Button\u0026gt;(R.id.slideButton) val fadeButton = popupView.findViewById\u0026lt;Button\u0026gt;(R.id.fadeButton) val scaleButton = popupView.findViewById\u0026lt;Button\u0026gt;(R.id.scaleButton) slideButton.setOnClickListener { showSlideAnimation() } fadeButton.setOnClickListener { showFadeAnimation() } scaleButton.setOnClickListener { showScaleAnimation() } } private fun setupClickListeners() { showAnimationPopupButton.setOnClickListener { showAnimationPopup(it) } } private fun showAnimationPopup(anchorView: View) { popupWindow.showAsDropDown(anchorView) } private fun showSlideAnimation() { Toast.makeText(this, \u0026#34;滑动动画\u0026#34;, Toast.LENGTH_SHORT).show() } private fun showFadeAnimation() { Toast.makeText(this, \u0026#34;淡入淡出动画\u0026#34;, Toast.LENGTH_SHORT).show() } private fun showScaleAnimation() { Toast.makeText(this, \u0026#34;缩放动画\u0026#34;, Toast.LENGTH_SHORT).show() } } 实际应用场景 # 1. 长按菜单弹窗 # class LongClickPopupActivity : AppCompatActivity() { private lateinit var longClickView: View private lateinit var popupWindow: PopupWindow override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_long_click_popup) initViews() setupPopupWindow() setupLongClickListener() } private fun initViews() { longClickView = findViewById(R.id.longClickView) } private fun setupPopupWindow() { val popupView = layoutInflater.inflate(R.layout.popup_long_click_menu, null) popupWindow = PopupWindow( popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true ) popupWindow.isOutsideTouchable = true popupWindow.isTouchable = true setupMenuItems(popupView) } private fun setupMenuItems(popupView: View) { val copyItem = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.copyItem) val pasteItem = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.pasteItem) val shareItem = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.shareItem) val deleteItem = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.deleteItem) copyItem.setOnClickListener { Toast.makeText(this, \u0026#34;复制\u0026#34;, Toast.LENGTH_SHORT).show() popupWindow.dismiss() } pasteItem.setOnClickListener { Toast.makeText(this, \u0026#34;粘贴\u0026#34;, Toast.LENGTH_SHORT).show() popupWindow.dismiss() } shareItem.setOnClickListener { Toast.makeText(this, \u0026#34;分享\u0026#34;, Toast.LENGTH_SHORT).show() popupWindow.dismiss() } deleteItem.setOnClickListener { Toast.makeText(this, \u0026#34;删除\u0026#34;, Toast.LENGTH_SHORT).show() popupWindow.dismiss() } } private fun setupLongClickListener() { longClickView.setOnLongClickListener { showPopupAtLongClickPosition(it) true } } private fun showPopupAtLongClickPosition(view: View) { val location = IntArray(2) view.getLocationOnScreen(location) val x = location[0] + view.width / 2 val y = location[1] + view.height / 2 popupWindow.showAtLocation(view, Gravity.NO_GRAVITY, x, y) } } 2. 搜索建议弹窗 # class SearchSuggestionPopupActivity : AppCompatActivity() { private lateinit var searchEditText: EditText private lateinit var popupWindow: PopupWindow private lateinit var suggestionAdapter: ArrayAdapter\u0026lt;String\u0026gt; private val suggestions = listOf( \u0026#34;Android开发\u0026#34;, \u0026#34;Kotlin编程\u0026#34;, \u0026#34;Java基础\u0026#34;, \u0026#34;移动开发\u0026#34;, \u0026#34;UI设计\u0026#34;, \u0026#34;数据库\u0026#34;, \u0026#34;网络编程\u0026#34;, \u0026#34;算法\u0026#34; ) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_search_suggestion_popup) initViews() setupPopupWindow() setupSearchListener() } private fun initViews() { searchEditText = findViewById(R.id.searchEditText) } private fun setupPopupWindow() { val popupView = layoutInflater.inflate(R.layout.popup_search_suggestions, null) val listView = popupView.findViewById\u0026lt;ListView\u0026gt;(R.id.suggestionListView) suggestionAdapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, mutableListOf()) listView.adapter = suggestionAdapter popupWindow = PopupWindow( popupView, ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, true ) popupWindow.isOutsideTouchable = true popupWindow.isTouchable = true listView.setOnItemClickListener { _, _, position, _ -\u0026gt; val selectedSuggestion = suggestionAdapter.getItem(position) searchEditText.setText(selectedSuggestion) popupWindow.dismiss() } } private fun setupSearchListener() { searchEditText.addTextChangedListener(object : TextWatcher { override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {} override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { val query = s.toString() if (query.isNotEmpty()) { showSuggestions(query) } else { popupWindow.dismiss() } } override fun afterTextChanged(s: Editable?) {} }) } private fun showSuggestions(query: String) { val filteredSuggestions = suggestions.filter { it.contains(query, ignoreCase = true) } suggestionAdapter.clear() suggestionAdapter.addAll(filteredSuggestions) suggestionAdapter.notifyDataSetChanged() if (filteredSuggestions.isNotEmpty()) { popupWindow.showAsDropDown(searchEditText) } else { popupWindow.dismiss() } } } 3. 工具提示弹窗 # class TooltipPopupActivity : AppCompatActivity() { private lateinit var showTooltipButton: Button private lateinit var popupWindow: PopupWindow override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_tooltip_popup) initViews() setupTooltipPopupWindow() setupClickListeners() } private fun initViews() { showTooltipButton = findViewById(R.id.showTooltipButton) } private fun setupTooltipPopupWindow() { val popupView = layoutInflater.inflate(R.layout.popup_tooltip, null) popupWindow = PopupWindow( popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true ) popupWindow.isOutsideTouchable = true popupWindow.isTouchable = true val tooltipText = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.tooltipText) tooltipText.text = \u0026#34;这是一个工具提示弹窗，用于显示帮助信息\u0026#34; } private fun setupClickListeners() { showTooltipButton.setOnClickListener { showTooltip(it) } } private fun showTooltip(anchorView: View) { val location = IntArray(2) anchorView.getLocationOnScreen(location) val x = location[0] + anchorView.width / 2 val y = location[1] - dpToPx(10) popupWindow.showAtLocation(anchorView, Gravity.NO_GRAVITY, x, y) // 3秒后自动关闭 Handler(Looper.getMainLooper()).postDelayed({ if (popupWindow.isShowing) { popupWindow.dismiss() } }, 3000) } private fun dpToPx(dp: Int): Int { return (dp * resources.displayMetrics.density).toInt() } } PopupWindow 最佳实践 # 1. 弹窗管理类 # class PopupWindowManager { private var currentPopup: PopupWindow? = null fun showPopup( context: Context, contentView: View, anchorView: View, width: Int = ViewGroup.LayoutParams.WRAP_CONTENT, height: Int = ViewGroup.LayoutParams.WRAP_CONTENT, animationStyle: Int = 0 ) { dismissCurrentPopup() currentPopup = PopupWindow(contentView, width, height, true).apply { isOutsideTouchable = true isTouchable = true if (animationStyle != 0) { this.animationStyle = animationStyle } } currentPopup?.showAsDropDown(anchorView) } fun dismissCurrentPopup() { currentPopup?.dismiss() currentPopup = null } } 2. 弹窗工具类 # object PopupWindowUtils { fun createMenuPopup( context: Context, menuItems: List\u0026lt;String\u0026gt;, onItemClick: (String) -\u0026gt; Unit ): PopupWindow { val popupView = LayoutInflater.from(context).inflate(R.layout.popup_menu, null) val listView = popupView.findViewById\u0026lt;ListView\u0026gt;(R.id.menuListView) val adapter = ArrayAdapter(context, android.R.layout.simple_list_item_1, menuItems) listView.adapter = adapter listView.setOnItemClickListener { _, _, position, _ -\u0026gt; onItemClick(menuItems[position]) } return PopupWindow( popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true ).apply { isOutsideTouchable = true isTouchable = true } } fun createTooltipPopup( context: Context, message: String ): PopupWindow { val popupView = LayoutInflater.from(context).inflate(R.layout.popup_tooltip, null) val textView = popupView.findViewById\u0026lt;TextView\u0026gt;(R.id.tooltipText) textView.text = message return PopupWindow( popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, true ).apply { isOutsideTouchable = true isTouchable = true } } } 📋 总结 # PopupWindow 是 Android 开发中重要的浮动窗口组件：\n基本用法：创建弹窗、设置属性、显示和关闭 位置控制：支持多种显示位置和锚点 动画效果：支持进入和退出动画 实际应用：长按菜单、搜索建议、工具提示等场景 最佳实践：弹窗管理、工具类封装 掌握 PopupWindow 的使用方法对于创建丰富的用户交互体验至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/14---popupwindow-%E5%BC%B9%E7%AA%97/","section":"Posts","summary":"详细介绍Android PopupWindow弹窗的使用方法、动画效果和实际应用场景","title":"PopupWindow 弹窗","type":"posts"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" ProgressBar 进度条控件 # ProgressBar 是 Android 中用于显示进度的控件，支持多种样式和动画效果。\nProgressBar 基本属性 # \u0026lt;ProgressBar android:id=\u0026#34;@+id/progressBar\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; /\u0026gt; ProgressBar 样式类型 # 1. 默认圆形进度条 # \u0026lt;ProgressBar android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; /\u0026gt; 2. 水平进度条 # \u0026lt;ProgressBar android:id=\u0026#34;@+id/horizontalProgressBar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; style=\u0026#34;?android:attr/progressBarStyleHorizontal\u0026#34; android:progress=\u0026#34;30\u0026#34; android:max=\u0026#34;100\u0026#34; android:layout_margin=\u0026#34;16dp\u0026#34; /\u0026gt; 3. 小尺寸进度条 # \u0026lt;ProgressBar android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; style=\u0026#34;?android:attr/progressBarStyleSmall\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; /\u0026gt; 4. 大尺寸进度条 # \u0026lt;ProgressBar android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; style=\u0026#34;?android:attr/progressBarStyleLarge\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; /\u0026gt; Kotlin 代码示例 # 基本使用 # class ProgressBarActivity : AppCompatActivity() { private lateinit var progressBar: ProgressBar private lateinit var horizontalProgressBar: ProgressBar private lateinit var startButton: Button private lateinit var resetButton: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_progress_bar) initViews() setupClickListeners() } private fun initViews() { progressBar = findViewById(R.id.progressBar) horizontalProgressBar = findViewById(R.id.horizontalProgressBar) startButton = findViewById(R.id.startButton) resetButton = findViewById(R.id.resetButton) } private fun setupClickListeners() { startButton.setOnClickListener { startProgress() } resetButton.setOnClickListener { resetProgress() } } private fun startProgress() { // 显示进度条 progressBar.visibility = View.VISIBLE // 模拟进度更新 simulateProgress() } private fun simulateProgress() { val handler = Handler(Looper.getMainLooper()) var progress = 0 val runnable = object : Runnable { override fun run() { progress += 10 horizontalProgressBar.progress = progress if (progress \u0026lt; 100) { handler.postDelayed(this, 200) } else { // 进度完成，隐藏圆形进度条 progressBar.visibility = View.GONE Toast.makeText(this@ProgressBarActivity, \u0026#34;进度完成！\u0026#34;, Toast.LENGTH_SHORT).show() } } } handler.post(runnable) } private fun resetProgress() { horizontalProgressBar.progress = 0 progressBar.visibility = View.GONE } } 自定义进度条 # class CustomProgressBarActivity : AppCompatActivity() { private lateinit var customProgressBar: ProgressBar private lateinit var seekBar: SeekBar private lateinit var progressText: TextView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_custom_progress_bar) initViews() setupSeekBar() } private fun initViews() { customProgressBar = findViewById(R.id.customProgressBar) seekBar = findViewById(R.id.seekBar) progressText = findViewById(R.id.progressText) } private fun setupSeekBar() { seekBar.max = 100 seekBar.progress = 0 seekBar.setOnSeekBarChangeListener(object : SeekBar.OnSeekBarChangeListener { override fun onProgressChanged(seekBar: SeekBar?, progress: Int, fromUser: Boolean) { customProgressBar.progress = progress progressText.text = \u0026#34;进度: $progress%\u0026#34; } override fun onStartTrackingTouch(seekBar: SeekBar?) { // 开始拖拽 } override fun onStopTrackingTouch(seekBar: SeekBar?) { // 停止拖拽 } }) } } 文件下载进度示例 # class DownloadActivity : AppCompatActivity() { private lateinit var downloadProgressBar: ProgressBar private lateinit var downloadButton: Button private lateinit var progressText: TextView private lateinit var statusText: TextView private var isDownloading = false override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_download) initViews() setupClickListeners() } private fun initViews() { downloadProgressBar = findViewById(R.id.downloadProgressBar) downloadButton = findViewById(R.id.downloadButton) progressText = findViewById(R.id.progressText) statusText = findViewById(R.id.statusText) downloadProgressBar.max = 100 downloadProgressBar.progress = 0 } private fun setupClickListeners() { downloadButton.setOnClickListener { if (!isDownloading) { startDownload() } else { cancelDownload() } } } private fun startDownload() { isDownloading = true downloadButton.text = \u0026#34;取消下载\u0026#34; statusText.text = \u0026#34;正在下载...\u0026#34; // 模拟文件下载 simulateFileDownload() } private fun simulateFileDownload() { val handler = Handler(Looper.getMainLooper()) var progress = 0 val runnable = object : Runnable { override fun run() { if (isDownloading \u0026amp;\u0026amp; progress \u0026lt; 100) { progress += 2 downloadProgressBar.progress = progress progressText.text = \u0026#34;下载进度: $progress%\u0026#34; handler.postDelayed(this, 100) } else if (progress \u0026gt;= 100) { downloadComplete() } } } handler.post(runnable) } private fun downloadComplete() { isDownloading = false downloadButton.text = \u0026#34;开始下载\u0026#34; statusText.text = \u0026#34;下载完成！\u0026#34; Toast.makeText(this, \u0026#34;文件下载完成\u0026#34;, Toast.LENGTH_SHORT).show() } private fun cancelDownload() { isDownloading = false downloadButton.text = \u0026#34;开始下载\u0026#34; statusText.text = \u0026#34;下载已取消\u0026#34; downloadProgressBar.progress = 0 progressText.text = \u0026#34;下载进度: 0%\u0026#34; } } 实际应用场景 # 1. 应用启动页面 # \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;@color/primary\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;120dp\u0026#34; android:layout_height=\u0026#34;120dp\u0026#34; android:src=\u0026#34;@drawable/app_logo\u0026#34; android:layout_marginBottom=\u0026#34;32dp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;正在加载...\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textColor=\u0026#34;@color/white\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;ProgressBar android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:indeterminateTint=\u0026#34;@color/white\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 2. 文件上传进度 # class FileUploadActivity : AppCompatActivity() { private lateinit var uploadProgressBar: ProgressBar private lateinit var uploadButton: Button private lateinit var progressText: TextView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_file_upload) initViews() setupUploadButton() } private fun initViews() { uploadProgressBar = findViewById(R.id.uploadProgressBar) uploadButton = findViewById(R.id.uploadButton) progressText = findViewById(R.id.progressText) } private fun setupUploadButton() { uploadButton.setOnClickListener { uploadFile() } } private fun uploadFile() { uploadButton.isEnabled = false uploadButton.text = \u0026#34;上传中...\u0026#34; // 模拟文件上传 simulateFileUpload() } private fun simulateFileUpload() { val handler = Handler(Looper.getMainLooper()) var progress = 0 val runnable = object : Runnable { override fun run() { progress += 5 uploadProgressBar.progress = progress progressText.text = \u0026#34;上传进度: $progress%\u0026#34; if (progress \u0026lt; 100) { handler.postDelayed(this, 300) } else { uploadComplete() } } } handler.post(runnable) } private fun uploadComplete() { uploadButton.isEnabled = true uploadButton.text = \u0026#34;上传文件\u0026#34; Toast.makeText(this, \u0026#34;文件上传成功\u0026#34;, Toast.LENGTH_SHORT).show() } } 3. 数据同步进度 # class DataSyncActivity : AppCompatActivity() { private lateinit var syncProgressBar: ProgressBar private lateinit var syncButton: Button private lateinit var syncStatusText: TextView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_data_sync) initViews() setupSyncButton() } private fun initViews() { syncProgressBar = findViewById(R.id.syncProgressBar) syncButton = findViewById(R.id.syncButton) syncStatusText = findViewById(R.id.syncStatusText) } private fun setupSyncButton() { syncButton.setOnClickListener { startDataSync() } } private fun startDataSync() { syncButton.isEnabled = false syncStatusText.text = \u0026#34;正在同步数据...\u0026#34; // 模拟数据同步 simulateDataSync() } private fun simulateDataSync() { val syncSteps = listOf( \u0026#34;连接服务器\u0026#34; to 20, \u0026#34;下载用户数据\u0026#34; to 40, \u0026#34;同步设置\u0026#34; to 60, \u0026#34;更新缓存\u0026#34; to 80, \u0026#34;完成同步\u0026#34; to 100 ) var currentStep = 0 val handler = Handler(Looper.getMainLooper()) val runnable = object : Runnable { override fun run() { if (currentStep \u0026lt; syncSteps.size) { val (stepName, progress) = syncSteps[currentStep] syncStatusText.text = stepName syncProgressBar.progress = progress currentStep++ handler.postDelayed(this, 1000) } else { syncComplete() } } } handler.post(runnable) } private fun syncComplete() { syncButton.isEnabled = true syncStatusText.text = \u0026#34;数据同步完成\u0026#34; Toast.makeText(this, \u0026#34;数据同步成功\u0026#34;, Toast.LENGTH_SHORT).show() } } 自定义样式 # 自定义进度条样式 # \u0026lt;!-- res/drawable/progress_bar_background.xml --\u0026gt; \u0026lt;shape xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:shape=\u0026#34;rectangle\u0026#34;\u0026gt; \u0026lt;corners android:radius=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;solid android:color=\u0026#34;#E0E0E0\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;!-- res/drawable/progress_bar_progress.xml --\u0026gt; \u0026lt;shape xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:shape=\u0026#34;rectangle\u0026#34;\u0026gt; \u0026lt;corners android:radius=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;solid android:color=\u0026#34;#2196F3\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;ProgressBar android:id=\u0026#34;@+id/customProgressBar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;8dp\u0026#34; style=\u0026#34;?android:attr/progressBarStyleHorizontal\u0026#34; android:progressDrawable=\u0026#34;@drawable/custom_progress_bar\u0026#34; android:max=\u0026#34;100\u0026#34; android:progress=\u0026#34;50\u0026#34; /\u0026gt; 自定义圆形进度条 # \u0026lt;!-- res/drawable/circular_progress.xml --\u0026gt; \u0026lt;shape xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:shape=\u0026#34;ring\u0026#34; android:innerRadiusRatio=\u0026#34;3\u0026#34; android:thicknessRatio=\u0026#34;8\u0026#34; android:useLevel=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;solid android:color=\u0026#34;#2196F3\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; 性能优化建议 # 1. 避免频繁更新 # class OptimizedProgressBar { private var lastUpdateTime = 0L private val UPDATE_INTERVAL = 100L // 100ms更新一次 fun updateProgress(progressBar: ProgressBar, progress: Int) { val currentTime = System.currentTimeMillis() if (currentTime - lastUpdateTime \u0026gt;= UPDATE_INTERVAL) { progressBar.progress = progress lastUpdateTime = currentTime } } } 2. 使用动画平滑过渡 # class SmoothProgressBar { fun animateProgress(progressBar: ProgressBar, targetProgress: Int) { val animator = ObjectAnimator.ofInt(progressBar, \u0026#34;progress\u0026#34;, progressBar.progress, targetProgress) animator.duration = 300 animator.interpolator = DecelerateInterpolator() animator.start() } } 📋 总结 # ProgressBar 是 Android 开发中重要的进度显示控件：\n多种样式：圆形、水平、大小尺寸等不同样式 动态更新：支持程序控制进度更新 实际应用：文件下载、数据同步、应用启动等场景 自定义样式：支持自定义外观和动画效果 性能优化：合理控制更新频率，使用动画平滑过渡 掌握 ProgressBar 的使用方法对于提升用户体验至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/07---progressbar-%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"详细介绍Android ProgressBar进度条控件的使用方法、样式配置和实际应用场景","title":"ProgressBar 进度条控件","type":"posts"},{"content":" RelativeLayout 相对布局 # RelativeLayout 是 Android 中基于相对位置的布局容器，子控件通过相对关系来确定自己的位置。\nRelativeLayout 基本属性 # \u0026lt;RelativeLayout android:id=\u0026#34;@+id/relativeLayout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;@color/background_color\u0026#34;\u0026gt; \u0026lt;!-- 子控件 --\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 相对父容器属性 # 基本对齐属性 # \u0026lt;RelativeLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34;\u0026gt; \u0026lt;!-- 相对于父容器居中 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/centerText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:text=\u0026#34;居中显示\u0026#34; android:background=\u0026#34;#FF5722\u0026#34; android:padding=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;!-- 相对于父容器顶部 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentTop=\u0026#34;true\u0026#34; android:layout_centerHorizontal=\u0026#34;true\u0026#34; android:text=\u0026#34;顶部居中\u0026#34; android:background=\u0026#34;#2196F3\u0026#34; android:padding=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;!-- 相对于父容器底部 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:layout_centerHorizontal=\u0026#34;true\u0026#34; android:text=\u0026#34;底部居中\u0026#34; android:background=\u0026#34;#4CAF50\u0026#34; android:padding=\u0026#34;16dp\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 水平垂直居中 # \u0026lt;RelativeLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34;\u0026gt; \u0026lt;!-- 水平居中 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerHorizontal=\u0026#34;true\u0026#34; android:text=\u0026#34;水平居中\u0026#34; /\u0026gt; \u0026lt;!-- 垂直居中 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerVertical=\u0026#34;true\u0026#34; android:text=\u0026#34;垂直居中\u0026#34; /\u0026gt; \u0026lt;!-- 完全居中 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:text=\u0026#34;完全居中\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 相对同级别控件属性 # 位置关系属性 # \u0026lt;RelativeLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;!-- 参照控件 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/referenceView\u0026#34; android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:text=\u0026#34;参照物\u0026#34; android:background=\u0026#34;#FF5722\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 在参照物左边 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;80dp\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:layout_toLeftOf=\u0026#34;@id/referenceView\u0026#34; android:layout_alignTop=\u0026#34;@id/referenceView\u0026#34; android:text=\u0026#34;左边\u0026#34; android:background=\u0026#34;#2196F3\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 在参照物右边 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;80dp\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:layout_toRightOf=\u0026#34;@id/referenceView\u0026#34; android:layout_alignTop=\u0026#34;@id/referenceView\u0026#34; android:text=\u0026#34;右边\u0026#34; android:background=\u0026#34;#4CAF50\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 在参照物上方 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;80dp\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:layout_above=\u0026#34;@id/referenceView\u0026#34; android:layout_alignLeft=\u0026#34;@id/referenceView\u0026#34; android:text=\u0026#34;上方\u0026#34; android:background=\u0026#34;#FF9800\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 在参照物下方 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;80dp\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:layout_below=\u0026#34;@id/referenceView\u0026#34; android:layout_alignLeft=\u0026#34;@id/referenceView\u0026#34; android:text=\u0026#34;下方\u0026#34; android:background=\u0026#34;#9C27B0\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 对齐关系属性 # \u0026lt;RelativeLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;!-- 基准控件 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/baseView\u0026#34; android:layout_width=\u0026#34;120dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:text=\u0026#34;基准控件\u0026#34; android:background=\u0026#34;#FF5722\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 顶部对齐 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:layout_alignTop=\u0026#34;@id/baseView\u0026#34; android:layout_toLeftOf=\u0026#34;@id/baseView\u0026#34; android:text=\u0026#34;顶部对齐\u0026#34; android:background=\u0026#34;#2196F3\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 底部对齐 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:layout_alignBottom=\u0026#34;@id/baseView\u0026#34; android:layout_toRightOf=\u0026#34;@id/baseView\u0026#34; android:text=\u0026#34;底部对齐\u0026#34; android:background=\u0026#34;#4CAF50\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 左边对齐 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:layout_alignLeft=\u0026#34;@id/baseView\u0026#34; android:layout_above=\u0026#34;@id/baseView\u0026#34; android:text=\u0026#34;左边对齐\u0026#34; android:background=\u0026#34;#FF9800\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;!-- 右边对齐 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:layout_alignRight=\u0026#34;@id/baseView\u0026#34; android:layout_below=\u0026#34;@id/baseView\u0026#34; android:text=\u0026#34;右边对齐\u0026#34; android:background=\u0026#34;#9C27B0\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; Kotlin 代码示例 # 动态创建 RelativeLayout # class DynamicRelativeLayoutActivity : AppCompatActivity() { private lateinit var containerLayout: RelativeLayout override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_dynamic_relative_layout) initViews() createDynamicLayout() } private fun initViews() { containerLayout = findViewById(R.id.containerLayout) } private fun createDynamicLayout() { // 创建中心参照控件 val centerView = TextView(this).apply { id = View.generateViewId() text = \u0026#34;中心参照\u0026#34; gravity = Gravity.CENTER setTextColor(Color.WHITE) setBackgroundColor(Color.parseColor(\u0026#34;#FF5722\u0026#34;)) layoutParams = RelativeLayout.LayoutParams(200, 200).apply { addRule(RelativeLayout.CENTER_IN_PARENT) } } containerLayout.addView(centerView) // 创建围绕中心控件的其他控件 val positions = listOf( Triple(\u0026#34;上方\u0026#34;, RelativeLayout.ABOVE, RelativeLayout.ALIGN_LEFT), Triple(\u0026#34;下方\u0026#34;, RelativeLayout.BELOW, RelativeLayout.ALIGN_RIGHT), Triple(\u0026#34;左边\u0026#34;, RelativeLayout.LEFT_OF, RelativeLayout.ALIGN_TOP), Triple(\u0026#34;右边\u0026#34;, RelativeLayout.RIGHT_OF, RelativeLayout.ALIGN_BOTTOM) ) positions.forEach { (text, positionRule, alignRule) -\u0026gt; val textView = TextView(this).apply { this.text = text gravity = Gravity.CENTER setTextColor(Color.WHITE) setBackgroundColor( when (text) { \u0026#34;上方\u0026#34; -\u0026gt; Color.parseColor(\u0026#34;#2196F3\u0026#34;) \u0026#34;下方\u0026#34; -\u0026gt; Color.parseColor(\u0026#34;#4CAF50\u0026#34;) \u0026#34;左边\u0026#34; -\u0026gt; Color.parseColor(\u0026#34;#FF9800\u0026#34;) \u0026#34;右边\u0026#34; -\u0026gt; Color.parseColor(\u0026#34;#9C27B0\u0026#34;) else -\u0026gt; Color.GRAY } ) layoutParams = RelativeLayout.LayoutParams(150, 100).apply { addRule(positionRule, centerView.id) addRule(alignRule, centerView.id) } } containerLayout.addView(textView) } } } 复杂布局示例 # class ComplexRelativeLayoutActivity : AppCompatActivity() { private lateinit var containerLayout: RelativeLayout override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_complex_relative_layout) initViews() createComplexLayout() } private fun initViews() { containerLayout = findViewById(R.id.containerLayout) } private fun createComplexLayout() { // 创建标题栏 val titleBar = createTitleBar() containerLayout.addView(titleBar) // 创建侧边栏 val sidebar = createSidebar() containerLayout.addView(sidebar) // 创建主内容区 val contentArea = createContentArea() containerLayout.addView(contentArea) // 创建底部栏 val bottomBar = createBottomBar() containerLayout.addView(bottomBar) } private fun createTitleBar(): TextView { return TextView(this).apply { id = View.generateViewId() text = \u0026#34;标题栏\u0026#34; gravity = Gravity.CENTER setTextColor(Color.WHITE) setBackgroundColor(Color.parseColor(\u0026#34;#FF5722\u0026#34;)) layoutParams = RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.MATCH_PARENT, 60 ).apply { addRule(RelativeLayout.ALIGN_PARENT_TOP) } } } private fun createSidebar(): TextView { return TextView(this).apply { id = View.generateViewId() text = \u0026#34;侧边栏\u0026#34; gravity = Gravity.CENTER setTextColor(Color.WHITE) setBackgroundColor(Color.parseColor(\u0026#34;#2196F3\u0026#34;)) layoutParams = RelativeLayout.LayoutParams( 120, RelativeLayout.LayoutParams.MATCH_PARENT ).apply { addRule(RelativeLayout.ALIGN_PARENT_LEFT) addRule(RelativeLayout.BELOW, containerLayout.getChildAt(0).id) addRule(RelativeLayout.ABOVE, containerLayout.getChildAt(3).id) } } } private fun createContentArea(): TextView { return TextView(this).apply { id = View.generateViewId() text = \u0026#34;主内容区\u0026#34; gravity = Gravity.CENTER setTextColor(Color.WHITE) setBackgroundColor(Color.parseColor(\u0026#34;#4CAF50\u0026#34;)) layoutParams = RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT ).apply { addRule(RelativeLayout.RIGHT_OF, containerLayout.getChildAt(1).id) addRule(RelativeLayout.BELOW, containerLayout.getChildAt(0).id) addRule(RelativeLayout.ABOVE, containerLayout.getChildAt(3).id) } } } private fun createBottomBar(): TextView { return TextView(this).apply { id = View.generateViewId() text = \u0026#34;底部栏\u0026#34; gravity = Gravity.CENTER setTextColor(Color.WHITE) setBackgroundColor(Color.parseColor(\u0026#34;#FF9800\u0026#34;)) layoutParams = RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.MATCH_PARENT, 60 ).apply { addRule(RelativeLayout.ALIGN_PARENT_BOTTOM) } } } } 实际应用场景 # 1. 用户信息卡片 # \u0026lt;RelativeLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;120dp\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;@drawable/card_background\u0026#34; android:layout_margin=\u0026#34;8dp\u0026#34;\u0026gt; \u0026lt;!-- 头像 --\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/avatarImageView\u0026#34; android:layout_width=\u0026#34;80dp\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:layout_alignParentLeft=\u0026#34;true\u0026#34; android:layout_centerVertical=\u0026#34;true\u0026#34; android:src=\u0026#34;@drawable/default_avatar\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; /\u0026gt; \u0026lt;!-- 用户名 --\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/usernameTextView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_toRightOf=\u0026#34;@id/avatarImageView\u0026#34; android:layout_alignTop=\u0026#34;@id/avatarImageView\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:text=\u0026#34;用户名\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; /\u0026gt; \u0026lt;!-- 在线状态 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_toRightOf=\u0026#34;@id/avatarImageView\u0026#34; android:layout_below=\u0026#34;@id/usernameTextView\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; android:text=\u0026#34;在线\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;#4CAF50\u0026#34; /\u0026gt; \u0026lt;!-- 最后登录时间 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_toRightOf=\u0026#34;@id/avatarImageView\u0026#34; android:layout_below=\u0026#34;@id/usernameTextView\u0026#34; android:layout_marginStart=\u0026#34;16dp\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:text=\u0026#34;2分钟前\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; android:textColor=\u0026#34;#999999\u0026#34; /\u0026gt; \u0026lt;!-- 操作按钮 --\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:text=\u0026#34;私聊\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; android:padding=\u0026#34;8dp\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 2. 聊天消息布局 # \u0026lt;RelativeLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;12dp\u0026#34;\u0026gt; \u0026lt;!-- 发送的消息 --\u0026gt; \u0026lt;RelativeLayout android:id=\u0026#34;@+id/sentMessageLayout\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:layout_marginStart=\u0026#34;80dp\u0026#34; android:background=\u0026#34;@drawable/sent_message_background\u0026#34; android:padding=\u0026#34;12dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;这是一条发送的消息\u0026#34; android:textColor=\u0026#34;#FFFFFF\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_below=\u0026#34;@id/sentMessageLayout\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; android:text=\u0026#34;10:30\u0026#34; android:textSize=\u0026#34;10sp\u0026#34; android:textColor=\u0026#34;#999999\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; \u0026lt;!-- 接收的消息 --\u0026gt; \u0026lt;RelativeLayout android:id=\u0026#34;@+id/receivedMessageLayout\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentLeft=\u0026#34;true\u0026#34; android:layout_marginEnd=\u0026#34;80dp\u0026#34; android:background=\u0026#34;@drawable/received_message_background\u0026#34; android:padding=\u0026#34;12dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;这是一条接收的消息\u0026#34; android:textColor=\u0026#34;#333333\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_below=\u0026#34;@id/receivedMessageLayout\u0026#34; android:layout_alignParentLeft=\u0026#34;true\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; android:text=\u0026#34;10:29\u0026#34; android:textSize=\u0026#34;10sp\u0026#34; android:textColor=\u0026#34;#999999\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 3. 浮动操作按钮 # \u0026lt;RelativeLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;!-- 主内容 --\u0026gt; \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:padding=\u0026#34;16dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;这里是主要内容...\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:lineSpacingMultiplier=\u0026#34;1.5\u0026#34; /\u0026gt; \u0026lt;/ScrollView\u0026gt; \u0026lt;!-- 浮动操作按钮 --\u0026gt; \u0026lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=\u0026#34;@+id/fab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:layout_margin=\u0026#34;16dp\u0026#34; android:src=\u0026#34;@drawable/ic_add\u0026#34; app:backgroundTint=\u0026#34;@color/primary\u0026#34; app:tint=\u0026#34;@color/white\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 性能优化建议 # 1. 避免过度嵌套 # // 不好的做法：过度嵌套RelativeLayout RelativeLayout { RelativeLayout { RelativeLayout { TextView { } } } } // 好的做法：使用ConstraintLayout替代 ConstraintLayout { TextView { } } 2. 合理使用规则 # class OptimizedRelativeLayout { fun setupOptimizedLayout() { // 优先使用简单的对齐规则 val layoutParams = RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT ).apply { // 使用简单的规则 addRule(RelativeLayout.CENTER_IN_PARENT) } // 避免复杂的规则组合 val complexParams = RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT ).apply { // 避免过多规则组合 addRule(RelativeLayout.BELOW, R.id.view1) addRule(RelativeLayout.RIGHT_OF, R.id.view2) addRule(RelativeLayout.ALIGN_TOP, R.id.view3) // ... 更多规则 } } } 3. 使用 ViewStub 延迟加载 # \u0026lt;RelativeLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;!-- 主要内容 --\u0026gt; \u0026lt;TextView android:text=\u0026#34;主要内容\u0026#34; /\u0026gt; \u0026lt;!-- 延迟加载的内容 --\u0026gt; \u0026lt;ViewStub android:id=\u0026#34;@+id/viewStub\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:layout=\u0026#34;@layout/delayed_content\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 常见问题解决 # 1. 控件重叠 # \u0026lt;!-- 错误：没有正确设置相对关系 --\u0026gt; \u0026lt;RelativeLayout\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text1\u0026#34; android:text=\u0026#34;文本1\u0026#34; /\u0026gt; \u0026lt;TextView android:text=\u0026#34;文本2\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; \u0026lt;!-- 正确：设置相对关系 --\u0026gt; \u0026lt;RelativeLayout\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text1\u0026#34; android:text=\u0026#34;文本1\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_below=\u0026#34;@id/text1\u0026#34; android:text=\u0026#34;文本2\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 2. 规则冲突 # // 避免规则冲突 val layoutParams = RelativeLayout.LayoutParams( RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT ).apply { // 不要同时设置冲突的规则 // addRule(RelativeLayout.ALIGN_PARENT_LEFT) // addRule(RelativeLayout.ALIGN_PARENT_RIGHT) // 使用不冲突的规则 addRule(RelativeLayout.CENTER_HORIZONTAL) } 📋 总结 # RelativeLayout 是 Android 开发中重要的布局容器：\n相对定位：基于控件间的相对关系确定位置 灵活布局：支持复杂的布局需求 性能考虑：避免过度嵌套和复杂规则 实际应用：卡片布局、聊天界面、浮动按钮等 现代替代：ConstraintLayout 提供更好的性能 掌握 RelativeLayout 的使用方法有助于理解 Android 布局系统，但在现代开发中建议优先使用 ConstraintLayout。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/03---relativelayout-%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80/","section":"Posts","summary":"详细介绍Android RelativeLayout相对布局的使用方法、属性配置和实际应用场景","title":"RelativeLayout 相对布局","type":"posts"},{"content":" SimpleAdapter 列表单一元素 # SimpleAdapter 是 Android 中用于显示复杂列表项的适配器，可以将 Map 数据映射到布局中的多个控件上。\nSimpleAdapter 基本概念 # SimpleAdapter 用于显示包含多个字段的列表项，每个列表项可以包含多个文本、图片等控件。它通过 Map 数据结构来存储每个列表项的数据。\n构造方法 # SimpleAdapter(Context context, List\u0026lt;? extends Map\u0026lt;String, ?\u0026gt;\u0026gt; data, int resource, String[] from, int[] to) 参数 说明 示例 context 环境上下文 this data 数据源（Map列表） listOf(map1, map2) resource 布局资源ID R.layout.list_item from Map中的键名数组 arrayOf(\u0026quot;title\u0026quot;, \u0026quot;subtitle\u0026quot;) to 布局中控件的ID数组 arrayOf(R.id.title, R.id.subtitle) 基本使用示例 # 1. 简单列表项 # class SimpleAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: SimpleAdapter private val dataList = mutableListOf\u0026lt;Map\u0026lt;String, Any\u0026gt;\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_simple_adapter) initViews() setupData() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupData() { dataList.addAll(listOf( mapOf( \u0026#34;title\u0026#34; to \u0026#34;Android开发\u0026#34;, \u0026#34;subtitle\u0026#34; to \u0026#34;移动应用开发技术\u0026#34;, \u0026#34;icon\u0026#34; to android.R.drawable.ic_menu_info_details ), mapOf( \u0026#34;title\u0026#34; to \u0026#34;Kotlin编程\u0026#34;, \u0026#34;subtitle\u0026#34; to \u0026#34;现代编程语言\u0026#34;, \u0026#34;icon\u0026#34; to android.R.drawable.ic_menu_edit ), mapOf( \u0026#34;title\u0026#34; to \u0026#34;Java基础\u0026#34;, \u0026#34;subtitle\u0026#34; to \u0026#34;面向对象编程\u0026#34;, \u0026#34;icon\u0026#34; to android.R.drawable.ic_menu_help ), mapOf( \u0026#34;title\u0026#34; to \u0026#34;UI设计\u0026#34;, \u0026#34;subtitle\u0026#34; to \u0026#34;用户界面设计\u0026#34;, \u0026#34;icon\u0026#34; to android.R.drawable.ic_menu_gallery ) )) } private fun setupAdapter() { adapter = SimpleAdapter( this, dataList, R.layout.simple_list_item, arrayOf(\u0026#34;title\u0026#34;, \u0026#34;subtitle\u0026#34;, \u0026#34;icon\u0026#34;), arrayOf(R.id.titleText, R.id.subtitleText, R.id.iconImage) ) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val item = dataList[position] val title = item[\u0026#34;title\u0026#34;] as String Toast.makeText(this, \u0026#34;选择了: $title\u0026#34;, Toast.LENGTH_SHORT).show() } listView.onItemLongClickListener = AdapterView.OnItemLongClickListener { _, _, position, _ -\u0026gt; showItemOptions(position) true } } private fun showItemOptions(position: Int) { val item = dataList[position] val title = item[\u0026#34;title\u0026#34;] as String AlertDialog.Builder(this) .setTitle(\u0026#34;操作选项\u0026#34;) .setMessage(\u0026#34;对 \u0026#39;$title\u0026#39; 执行什么操作？\u0026#34;) .setPositiveButton(\u0026#34;编辑\u0026#34;) { _, _ -\u0026gt; editItem(position) } .setNegativeButton(\u0026#34;删除\u0026#34;) { _, _ -\u0026gt; removeItem(position) } .setNeutralButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } private fun editItem(position: Int) { val item = dataList[position] val currentTitle = item[\u0026#34;title\u0026#34;] as String val currentSubtitle = item[\u0026#34;subtitle\u0026#34;] as String val editText = EditText(this).apply { setText(currentTitle) } AlertDialog.Builder(this) .setTitle(\u0026#34;编辑标题\u0026#34;) .setView(editText) .setPositiveButton(\u0026#34;确定\u0026#34;) { _, _ -\u0026gt; val newTitle = editText.text.toString() if (newTitle.isNotEmpty()) { dataList[position] = mapOf( \u0026#34;title\u0026#34; to newTitle, \u0026#34;subtitle\u0026#34; to currentSubtitle, \u0026#34;icon\u0026#34; to item[\u0026#34;icon\u0026#34;]!! ) adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已更新\u0026#34;, Toast.LENGTH_SHORT).show() } } .setNegativeButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } private fun removeItem(position: Int) { dataList.removeAt(position) adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已删除\u0026#34;, Toast.LENGTH_SHORT).show() } } 2. 自定义布局文件 # \u0026lt;!-- res/layout/simple_list_item.xml --\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;?android:attr/selectableItemBackground\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iconImage\u0026#34; android:layout_width=\u0026#34;48dp\u0026#34; android:layout_height=\u0026#34;48dp\u0026#34; android:src=\u0026#34;@drawable/ic_default\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/titleText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:textColor=\u0026#34;@android:color/black\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/subtitleText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;@android:color/darker_gray\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/arrowImage\u0026#34; android:layout_width=\u0026#34;24dp\u0026#34; android:layout_height=\u0026#34;24dp\u0026#34; android:src=\u0026#34;@drawable/ic_arrow_right\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 3. 复杂列表项 # class ComplexSimpleAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: SimpleAdapter private val dataList = mutableListOf\u0026lt;Map\u0026lt;String, Any\u0026gt;\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_complex_simple_adapter) initViews() setupComplexData() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupComplexData() { dataList.addAll(listOf( mapOf( \u0026#34;name\u0026#34; to \u0026#34;张三\u0026#34;, \u0026#34;phone\u0026#34; to \u0026#34;13800138000\u0026#34;, \u0026#34;email\u0026#34; to \u0026#34;zhangsan@example.com\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_myplaces, \u0026#34;status\u0026#34; to \u0026#34;在线\u0026#34;, \u0026#34;lastMessage\u0026#34; to \u0026#34;你好，最近怎么样？\u0026#34; ), mapOf( \u0026#34;name\u0026#34; to \u0026#34;李四\u0026#34;, \u0026#34;phone\u0026#34; to \u0026#34;13800138001\u0026#34;, \u0026#34;email\u0026#34; to \u0026#34;lisi@example.com\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_camera, \u0026#34;status\u0026#34; to \u0026#34;离线\u0026#34;, \u0026#34;lastMessage\u0026#34; to \u0026#34;明天见面吧\u0026#34; ), mapOf( \u0026#34;name\u0026#34; to \u0026#34;王五\u0026#34;, \u0026#34;phone\u0026#34; to \u0026#34;13800138002\u0026#34;, \u0026#34;email\u0026#34; to \u0026#34;wangwu@example.com\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_send, \u0026#34;status\u0026#34; to \u0026#34;在线\u0026#34;, \u0026#34;lastMessage\u0026#34; to \u0026#34;好的，没问题\u0026#34; ), mapOf( \u0026#34;name\u0026#34; to \u0026#34;赵六\u0026#34;, \u0026#34;phone\u0026#34; to \u0026#34;13800138003\u0026#34;, \u0026#34;email\u0026#34; to \u0026#34;zhaoliu@example.com\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_share, \u0026#34;status\u0026#34; to \u0026#34;忙碌\u0026#34;, \u0026#34;lastMessage\u0026#34; to \u0026#34;稍后回复\u0026#34; ) )) } private fun setupAdapter() { adapter = SimpleAdapter( this, dataList, R.layout.complex_list_item, arrayOf(\u0026#34;name\u0026#34;, \u0026#34;phone\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;avatar\u0026#34;, \u0026#34;status\u0026#34;, \u0026#34;lastMessage\u0026#34;), arrayOf(R.id.nameText, R.id.phoneText, R.id.emailText, R.id.avatarImage, R.id.statusText, R.id.lastMessageText) ) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val item = dataList[position] val name = item[\u0026#34;name\u0026#34;] as String val phone = item[\u0026#34;phone\u0026#34;] as String showContactDetail(name, phone) } } private fun showContactDetail(name: String, phone: String) { AlertDialog.Builder(this) .setTitle(\u0026#34;联系人详情\u0026#34;) .setMessage(\u0026#34;姓名: $name\\n电话: $phone\u0026#34;) .setPositiveButton(\u0026#34;确定\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } } 4. 复杂布局文件 # \u0026lt;!-- res/layout/complex_list_item.xml --\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;?android:attr/selectableItemBackground\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/avatarImage\u0026#34; android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:src=\u0026#34;@drawable/ic_default_avatar\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; android:background=\u0026#34;@drawable/circle_background\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/nameText\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:textColor=\u0026#34;@android:color/black\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/statusText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; android:textColor=\u0026#34;@android:color/holo_green_dark\u0026#34; android:background=\u0026#34;@drawable/status_background\u0026#34; android:padding=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/phoneText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;@android:color/darker_gray\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/emailText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; android:textColor=\u0026#34;@android:color/darker_gray\u0026#34; android:layout_marginTop=\u0026#34;2dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/lastMessageText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;@android:color/black\u0026#34; android:layout_marginTop=\u0026#34;8dp\u0026#34; android:maxLines=\u0026#34;2\u0026#34; android:ellipsize=\u0026#34;end\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 高级用法示例 # 1. 动态数据更新 # class DynamicSimpleAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: SimpleAdapter private lateinit var addButton: Button private lateinit var refreshButton: Button private val dataList = mutableListOf\u0026lt;Map\u0026lt;String, Any\u0026gt;\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_dynamic_simple_adapter) initViews() setupInitialData() setupAdapter() setupListView() setupButtons() } private fun initViews() { listView = findViewById(R.id.listView) addButton = findViewById(R.id.addButton) refreshButton = findViewById(R.id.refreshButton) } private fun setupInitialData() { dataList.addAll(listOf( mapOf( \u0026#34;title\u0026#34; to \u0026#34;初始项目1\u0026#34;, \u0026#34;subtitle\u0026#34; to \u0026#34;这是初始数据\u0026#34;, \u0026#34;icon\u0026#34; to android.R.drawable.ic_menu_info_details, \u0026#34;timestamp\u0026#34; to System.currentTimeMillis() ), mapOf( \u0026#34;title\u0026#34; to \u0026#34;初始项目2\u0026#34;, \u0026#34;subtitle\u0026#34; to \u0026#34;这也是初始数据\u0026#34;, \u0026#34;icon\u0026#34; to android.R.drawable.ic_menu_edit, \u0026#34;timestamp\u0026#34; to System.currentTimeMillis() ) )) } private fun setupAdapter() { adapter = SimpleAdapter( this, dataList, R.layout.dynamic_list_item, arrayOf(\u0026#34;title\u0026#34;, \u0026#34;subtitle\u0026#34;, \u0026#34;icon\u0026#34;, \u0026#34;timestamp\u0026#34;), arrayOf(R.id.titleText, R.id.subtitleText, R.id.iconImage, R.id.timestampText) ) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val item = dataList[position] val title = item[\u0026#34;title\u0026#34;] as String Toast.makeText(this, \u0026#34;选择了: $title\u0026#34;, Toast.LENGTH_SHORT).show() } } private fun setupButtons() { addButton.setOnClickListener { addNewItem() } refreshButton.setOnClickListener { refreshData() } } private fun addNewItem() { val editText = EditText(this).apply { hint = \u0026#34;请输入新项目标题\u0026#34; } AlertDialog.Builder(this) .setTitle(\u0026#34;添加新项目\u0026#34;) .setView(editText) .setPositiveButton(\u0026#34;添加\u0026#34;) { _, _ -\u0026gt; val newTitle = editText.text.toString() if (newTitle.isNotEmpty()) { val newItem = mapOf( \u0026#34;title\u0026#34; to newTitle, \u0026#34;subtitle\u0026#34; to \u0026#34;新添加的项目\u0026#34;, \u0026#34;icon\u0026#34; to android.R.drawable.ic_menu_add, \u0026#34;timestamp\u0026#34; to System.currentTimeMillis() ) dataList.add(newItem) adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;已添加: $newTitle\u0026#34;, Toast.LENGTH_SHORT).show() } } .setNegativeButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } private fun refreshData() { dataList.clear() setupInitialData() // 添加一些随机数据 repeat(3) { index -\u0026gt; val randomItem = mapOf( \u0026#34;title\u0026#34; to \u0026#34;刷新项目${index + 1}\u0026#34;, \u0026#34;subtitle\u0026#34; to \u0026#34;这是刷新后的数据\u0026#34;, \u0026#34;icon\u0026#34; to android.R.drawable.ic_menu_refresh, \u0026#34;timestamp\u0026#34; to System.currentTimeMillis() ) dataList.add(randomItem) } adapter.notifyDataSetChanged() Toast.makeText(this, \u0026#34;数据已刷新\u0026#34;, Toast.LENGTH_SHORT).show() } } 2. 自定义数据转换 # class CustomSimpleAdapterActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: SimpleAdapter private val dataList = mutableListOf\u0026lt;Map\u0026lt;String, Any\u0026gt;\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_custom_simple_adapter) initViews() setupCustomData() setupCustomAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupCustomData() { dataList.addAll(listOf( mapOf( \u0026#34;name\u0026#34; to \u0026#34;张三\u0026#34;, \u0026#34;age\u0026#34; to 25, \u0026#34;salary\u0026#34; to 8000.0, \u0026#34;department\u0026#34; to \u0026#34;技术部\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_myplaces ), mapOf( \u0026#34;name\u0026#34; to \u0026#34;李四\u0026#34;, \u0026#34;age\u0026#34; to 30, \u0026#34;salary\u0026#34; to 12000.0, \u0026#34;department\u0026#34; to \u0026#34;产品部\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_camera ), mapOf( \u0026#34;name\u0026#34; to \u0026#34;王五\u0026#34;, \u0026#34;age\u0026#34; to 28, \u0026#34;salary\u0026#34; to 10000.0, \u0026#34;department\u0026#34; to \u0026#34;设计部\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_send ) )) } private fun setupCustomAdapter() { adapter = object : SimpleAdapter( this, dataList, R.layout.custom_list_item, arrayOf(\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;salary\u0026#34;, \u0026#34;department\u0026#34;, \u0026#34;avatar\u0026#34;), arrayOf(R.id.nameText, R.id.ageText, R.id.salaryText, R.id.departmentText, R.id.avatarImage) ) { override fun setViewText(TextView v: TextView, String text: String) { when (v.id) { R.id.ageText -\u0026gt; { v.text = \u0026#34;年龄: $text 岁\u0026#34; } R.id.salaryText -\u0026gt; { v.text = \u0026#34;薪资: ¥$text\u0026#34; } R.id.departmentText -\u0026gt; { v.text = \u0026#34;部门: $text\u0026#34; } else -\u0026gt; { super.setViewText(v, text) } } } override fun setViewImage(ImageView v: ImageView, Int value: Int) { v.setImageResource(value) } } } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val item = dataList[position] val name = item[\u0026#34;name\u0026#34;] as String val age = item[\u0026#34;age\u0026#34;] as Int val salary = item[\u0026#34;salary\u0026#34;] as Double val department = item[\u0026#34;department\u0026#34;] as String showEmployeeDetail(name, age, salary, department) } } private fun showEmployeeDetail(name: String, age: Int, salary: Double, department: String) { AlertDialog.Builder(this) .setTitle(\u0026#34;员工详情\u0026#34;) .setMessage(\u0026#34;姓名: $name\\n年龄: $age\\n薪资: ¥$salary\\n部门: $department\u0026#34;) .setPositiveButton(\u0026#34;确定\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } } 实际应用场景 # 1. 联系人列表 # class ContactListActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: SimpleAdapter private val contactList = mutableListOf\u0026lt;Map\u0026lt;String, Any\u0026gt;\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_contact_list) initViews() loadContacts() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun loadContacts() { contactList.addAll(listOf( mapOf( \u0026#34;name\u0026#34; to \u0026#34;张三\u0026#34;, \u0026#34;phone\u0026#34; to \u0026#34;13800138000\u0026#34;, \u0026#34;email\u0026#34; to \u0026#34;zhangsan@example.com\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_myplaces, \u0026#34;isOnline\u0026#34; to true ), mapOf( \u0026#34;name\u0026#34; to \u0026#34;李四\u0026#34;, \u0026#34;phone\u0026#34; to \u0026#34;13800138001\u0026#34;, \u0026#34;email\u0026#34; to \u0026#34;lisi@example.com\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_camera, \u0026#34;isOnline\u0026#34; to false ), mapOf( \u0026#34;name\u0026#34; to \u0026#34;王五\u0026#34;, \u0026#34;phone\u0026#34; to \u0026#34;13800138002\u0026#34;, \u0026#34;email\u0026#34; to \u0026#34;wangwu@example.com\u0026#34;, \u0026#34;avatar\u0026#34; to android.R.drawable.ic_menu_send, \u0026#34;isOnline\u0026#34; to true ) )) } private fun setupAdapter() { adapter = SimpleAdapter( this, contactList, R.layout.contact_list_item, arrayOf(\u0026#34;name\u0026#34;, \u0026#34;phone\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;avatar\u0026#34;, \u0026#34;isOnline\u0026#34;), arrayOf(R.id.nameText, R.id.phoneText, R.id.emailText, R.id.avatarImage, R.id.statusIndicator) ) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val contact = contactList[position] val name = contact[\u0026#34;name\u0026#34;] as String val phone = contact[\u0026#34;phone\u0026#34;] as String callContact(name, phone) } } private fun callContact(name: String, phone: String) { AlertDialog.Builder(this) .setTitle(\u0026#34;拨打电话\u0026#34;) .setMessage(\u0026#34;是否拨打 $name 的电话: $phone\u0026#34;) .setPositiveButton(\u0026#34;拨打\u0026#34;) { _, _ -\u0026gt; Toast.makeText(this, \u0026#34;正在拨打 $phone\u0026#34;, Toast.LENGTH_SHORT).show() } .setNegativeButton(\u0026#34;取消\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } } SimpleAdapter 最佳实践 # 1. 数据模型类 # data class ListItem( val title: String, val subtitle: String, val icon: Int, val timestamp: Long = System.currentTimeMillis() ) { fun toMap(): Map\u0026lt;String, Any\u0026gt; { return mapOf( \u0026#34;title\u0026#34; to title, \u0026#34;subtitle\u0026#34; to subtitle, \u0026#34;icon\u0026#34; to icon, \u0026#34;timestamp\u0026#34; to timestamp ) } } object ListItemMapper { fun fromMap(map: Map\u0026lt;String, Any\u0026gt;): ListItem { return ListItem( title = map[\u0026#34;title\u0026#34;] as String, subtitle = map[\u0026#34;subtitle\u0026#34;] as String, icon = map[\u0026#34;icon\u0026#34;] as Int, timestamp = map[\u0026#34;timestamp\u0026#34;] as Long ) } } 2. 适配器工具类 # object SimpleAdapterUtils { fun createSimpleAdapter( context: Context, data: List\u0026lt;Map\u0026lt;String, Any\u0026gt;\u0026gt;, layoutRes: Int, fromKeys: Array\u0026lt;String\u0026gt;, toIds: IntArray ): SimpleAdapter { return SimpleAdapter(context, data, layoutRes, fromKeys, toIds) } fun createContactAdapter( context: Context, contacts: List\u0026lt;Map\u0026lt;String, Any\u0026gt;\u0026gt; ): SimpleAdapter { return SimpleAdapter( context, contacts, R.layout.contact_list_item, arrayOf(\u0026#34;name\u0026#34;, \u0026#34;phone\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;avatar\u0026#34;), arrayOf(R.id.nameText, R.id.phoneText, R.id.emailText, R.id.avatarImage) ) } fun createMessageAdapter( context: Context, messages: List\u0026lt;Map\u0026lt;String, Any\u0026gt;\u0026gt; ): SimpleAdapter { return SimpleAdapter( context, messages, R.layout.message_list_item, arrayOf(\u0026#34;sender\u0026#34;, \u0026#34;content\u0026#34;, \u0026#34;time\u0026#34;, \u0026#34;avatar\u0026#34;), arrayOf(R.id.senderText, R.id.contentText, R.id.timeText, R.id.avatarImage) ) } } 📋 总结 # SimpleAdapter 是 Android 开发中用于复杂列表项的适配器：\n基本用法：Map数据映射到多个控件 数据绑定：支持文本、图片等多种数据类型 自定义转换：支持自定义数据转换逻辑 实际应用：联系人列表、消息列表、员工列表等场景 最佳实践：数据模型类、工具类封装 掌握 SimpleAdapter 的使用方法对于创建复杂的列表界面至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/17---simpleadapter-%E5%88%97%E8%A1%A8%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/","section":"Posts","summary":"详细介绍Android SimpleAdapter的使用方法、数据映射和实际应用场景","title":"SimpleAdapter 列表单一元素","type":"posts"},{"content":"","date":"24 October 2025","externalUrl":null,"permalink":"/","section":"TsanChing Kim's Blog","summary":"","title":"TsanChing Kim's Blog","type":"page"},{"content":" UI 基础控件 View # View 是 Android UI 的基础组件，所有的 UI 控件都继承自 View 类。View 提供了基本的绘制和事件处理功能。\nView 分类 # 文本显示类 # TextView：显示文本内容 Button：可点击的按钮 EditText：文本输入框 图片显示类 # ImageView：显示图片 ImageButton：图片按钮 进度显示类 # ProgressBar：进度条 SeekBar：可拖拽的进度条 选择类 # CheckBox：复选框 RadioButton：单选按钮 Switch：开关 📚 TextView 文本显示控件 # TextView 是 Android 中最基础的文本显示控件，类似于 Swing 中的 JLabel。\n基本属性 # \u0026lt;TextView android:id=\u0026#34;@+id/textView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Hello World!\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textColor=\u0026#34;#333333\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:padding=\u0026#34;16dp\u0026#34; /\u0026gt; 常用属性说明 # 属性 说明 示例值 textSize 设置字体大小 16sp, 20dp textColor 设置文字颜色 #333333, @color/primary gravity 设置文字对齐方式 center, left, right lineSpacingMultiplier 设置行间距倍数 1.2 maxLines 设置最大行数 3 ellipsize 设置省略号位置 end, start, middle 长文本处理 # 滚动显示 # 当文本内容超过屏幕高度时，使用 ScrollView 包装：\n\u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/long_text\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:lineSpacingMultiplier=\u0026#34;1.2\u0026#34; /\u0026gt; \u0026lt;/ScrollView\u0026gt; 跑马灯效果 # 实现文字滚动显示：\n\u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;这是一段很长的文字，会以跑马灯的形式滚动显示\u0026#34; android:singleLine=\u0026#34;true\u0026#34; android:ellipsize=\u0026#34;marquee\u0026#34; android:marqueeRepeatLimit=\u0026#34;marquee_forever\u0026#34; android:focusable=\u0026#34;true\u0026#34; android:focusableInTouchMode=\u0026#34;true\u0026#34; /\u0026gt; Kotlin 代码示例 # class MainActivity : AppCompatActivity() { private lateinit var textView: TextView override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupTextView() } private fun initViews() { textView = findViewById(R.id.textView) } private fun setupTextView() { // 设置文本内容 textView.text = \u0026#34;Hello Kotlin!\u0026#34; // 设置文字颜色 textView.setTextColor(ContextCompat.getColor(this, R.color.primary)) // 设置文字大小 textView.textSize = 18f // 设置点击事件 textView.setOnClickListener { Toast.makeText(this, \u0026#34;TextView被点击了\u0026#34;, Toast.LENGTH_SHORT).show() } // 动态设置跑马灯效果 textView.isSelected = true } } 📝 EditText 文本输入控件 # EditText 继承自 TextView，用于接收用户输入的文本。\n基本属性 # \u0026lt;EditText android:id=\u0026#34;@+id/editText\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入用户名\u0026#34; android:inputType=\u0026#34;text\u0026#34; android:maxLength=\u0026#34;20\u0026#34; android:background=\u0026#34;@drawable/edit_text_background\u0026#34; android:padding=\u0026#34;12dp\u0026#34; /\u0026gt; 输入类型 (inputType) # 类型 说明 键盘类型 text 普通文本 标准键盘 textPassword 密码输入 数字键盘 number 正整数 数字键盘 numberSigned 整数（含负数） 数字键盘 numberDecimal 小数 数字键盘 phone 电话号码 电话键盘 email 邮箱地址 邮箱键盘 textMultiLine 多行文本 标准键盘 常用属性 # 属性 说明 示例值 hint 提示文字 \u0026quot;请输入用户名\u0026quot; maxLength 最大输入长度 20 minLines 最小行数 3 maxLines 最大行数 5 lines 固定行数 3 Kotlin 代码示例 # class MainActivity : AppCompatActivity() { private lateinit var editText: EditText private lateinit var button: Button override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupEditText() } private fun initViews() { editText = findViewById(R.id.editText) button = findViewById(R.id.button) } private fun setupEditText() { // 设置输入监听 editText.addTextChangedListener(object : TextWatcher { override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) { // 文本改变前的回调 } override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { // 文本改变时的回调 val inputText = s.toString() button.isEnabled = inputText.isNotEmpty() } override fun afterTextChanged(s: Editable?) { // 文本改变后的回调 } }) // 设置焦点变化监听 editText.onFocusChangeListener = View.OnFocusChangeListener { _, hasFocus -\u0026gt; if (hasFocus) { // 获得焦点时的处理 editText.setBackgroundResource(R.drawable.edit_text_focused) } else { // 失去焦点时的处理 editText.setBackgroundResource(R.drawable.edit_text_normal) } } // 获取输入内容 button.setOnClickListener { val inputText = editText.text.toString() if (inputText.isNotEmpty()) { Toast.makeText(this, \u0026#34;输入内容：$inputText\u0026#34;, Toast.LENGTH_SHORT).show() } else { Toast.makeText(this, \u0026#34;请输入内容\u0026#34;, Toast.LENGTH_SHORT).show() } } } // 验证输入内容 private fun validateInput(): Boolean { val inputText = editText.text.toString() return inputText.length \u0026gt;= 3 \u0026amp;\u0026amp; inputText.length \u0026lt;= 20 } } 🎨 样式和主题 # 自定义样式 # 在 res/values/styles.xml 中定义：\n\u0026lt;style name=\u0026#34;CustomTextViewStyle\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:textSize\u0026#34;\u0026gt;16sp\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:textColor\u0026#34;\u0026gt;#333333\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:background\u0026#34;\u0026gt;@drawable/text_view_background\u0026lt;/item\u0026gt; \u0026lt;item name=\u0026#34;android:padding\u0026#34;\u0026gt;12dp\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt; 应用样式 # \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; style=\u0026#34;@style/CustomTextViewStyle\u0026#34; android:text=\u0026#34;应用自定义样式\u0026#34; /\u0026gt; 📱 响应式设计 # 不同屏幕尺寸适配 # \u0026lt;!-- 小屏幕 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:minWidth=\u0026#34;120dp\u0026#34; /\u0026gt; \u0026lt;!-- 大屏幕 --\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:minWidth=\u0026#34;200dp\u0026#34; /\u0026gt; 🔧 实用技巧 # 1. 动态设置文本 # // 使用字符串资源 textView.text = getString(R.string.welcome_message, userName) // 使用格式化字符串 textView.text = String.format(\u0026#34;欢迎 %s，今天是 %s\u0026#34;, userName, currentDate) 2. 文本选择 # // 设置文本可选择 textView.setTextIsSelectable(true) // 选中指定范围的文本 textView.setSelection(0, 5) 3. 链接处理 # // 设置HTML内容 textView.text = Html.fromHtml(\u0026#34;\u0026lt;a href=\u0026#39;https://www.example.com\u0026#39;\u0026gt;点击访问\u0026lt;/a\u0026gt;\u0026#34;) textView.movementMethod = LinkMovementMethod.getInstance() 📋 总结 # TextView 和 EditText 是 Android 开发中最常用的基础控件：\nTextView：用于显示文本内容，支持多种样式和效果 EditText：用于接收用户输入，支持多种输入类型和验证 样式定制：通过样式和主题实现统一的视觉效果 响应式设计：适配不同屏幕尺寸和密度 掌握这些基础控件的使用方法是 Android 开发的重要基础。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/04---ui%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6-view/","section":"Posts","summary":"详细介绍Android UI基础控件View的分类、TextView和EditText的使用方法及属性配置","title":"UI基础控件 View","type":"posts"},{"content":" ViewHolder 视图保持器 # ViewHolder 是 Android 开发中用于优化 ListView 和 RecyclerView 性能的重要设计模式，通过缓存视图引用避免重复的 findViewById 操作。\nViewHolder 基本概念 # ViewHolder 模式是 Android 开发中的性能优化技术，主要用于列表控件（ListView、RecyclerView）中。当用户滑动列表时，系统会复用已创建的视图，ViewHolder 帮助缓存这些视图的引用，避免重复查找控件。\n性能问题 # 当滑动到 ListView 中的某个元素时，会将其加载出来，而滑到别的元素后重新滑动到已经加载过的元素时，会进行重新加载。每次重新加载都会调用 findViewById() 方法，这是一个昂贵的操作。\nViewHolder 实现原理 # 1. 基本实现步骤 # class ViewHolderActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: ViewHolderAdapter private val dataList = mutableListOf\u0026lt;String\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_viewholder) initViews() setupData() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupData() { dataList.addAll(listOf( \u0026#34;项目1\u0026#34;, \u0026#34;项目2\u0026#34;, \u0026#34;项目3\u0026#34;, \u0026#34;项目4\u0026#34;, \u0026#34;项目5\u0026#34;, \u0026#34;项目6\u0026#34;, \u0026#34;项目7\u0026#34;, \u0026#34;项目8\u0026#34;, \u0026#34;项目9\u0026#34;, \u0026#34;项目10\u0026#34; )) } private fun setupAdapter() { adapter = ViewHolderAdapter(this, dataList) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val item = dataList[position] Toast.makeText(this, \u0026#34;选择了: $item\u0026#34;, Toast.LENGTH_SHORT).show() } } } class ViewHolderAdapter( private val context: Context, private val dataList: MutableList\u0026lt;String\u0026gt; ) : BaseAdapter() { override fun getCount(): Int = dataList.size override fun getItem(position: Int): String = dataList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view: View val holder: ViewHolder // 1. 判断 convertView 是否为 null if (convertView == null) { // 2. 创建新的视图 view = LayoutInflater.from(context).inflate(R.layout.viewholder_item, parent, false) // 3. 创建 ViewHolder 实例 holder = ViewHolder(view) // 4. 将 ViewHolder 绑定到视图 view.tag = holder } else { // 5. 复用已存在的视图 view = convertView // 6. 从视图标签中获取 ViewHolder holder = view.tag as ViewHolder } // 7. 绑定数据到视图 val item = dataList[position] holder.titleText.text = item holder.subtitleText.text = \u0026#34;这是第 ${position + 1} 个项目\u0026#34; return view } // ViewHolder 类定义 private class ViewHolder(view: View) { val titleText: TextView = view.findViewById(R.id.titleText) val subtitleText: TextView = view.findViewById(R.id.subtitleText) val iconImage: ImageView = view.findViewById(R.id.iconImage) } } 2. 布局文件 # \u0026lt;!-- res/layout/viewholder_item.xml --\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;16dp\u0026#34; android:background=\u0026#34;?android:attr/selectableItemBackground\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iconImage\u0026#34; android:layout_width=\u0026#34;48dp\u0026#34; android:layout_height=\u0026#34;48dp\u0026#34; android:src=\u0026#34;@drawable/ic_default\u0026#34; android:layout_marginEnd=\u0026#34;16dp\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/titleText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:textColor=\u0026#34;@android:color/black\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/subtitleText\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;@android:color/darker_gray\u0026#34; android:layout_marginTop=\u0026#34;4dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/arrowImage\u0026#34; android:layout_width=\u0026#34;24dp\u0026#34; android:layout_height=\u0026#34;24dp\u0026#34; android:src=\u0026#34;@drawable/ic_arrow_right\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 高级用法示例 # 1. 复杂数据模型ViewHolder # class ComplexViewHolderActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: ComplexViewHolderAdapter private val dataList = mutableListOf\u0026lt;ContactItem\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_complex_viewholder) initViews() setupData() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupData() { dataList.addAll(listOf( ContactItem(\u0026#34;张三\u0026#34;, \u0026#34;13800138000\u0026#34;, \u0026#34;zhangsan@example.com\u0026#34;, true), ContactItem(\u0026#34;李四\u0026#34;, \u0026#34;13800138001\u0026#34;, \u0026#34;lisi@example.com\u0026#34;, false), ContactItem(\u0026#34;王五\u0026#34;, \u0026#34;13800138002\u0026#34;, \u0026#34;wangwu@example.com\u0026#34;, true), ContactItem(\u0026#34;赵六\u0026#34;, \u0026#34;13800138003\u0026#34;, \u0026#34;zhaoliu@example.com\u0026#34;, false), ContactItem(\u0026#34;钱七\u0026#34;, \u0026#34;13800138004\u0026#34;, \u0026#34;qianqi@example.com\u0026#34;, true) )) } private fun setupAdapter() { adapter = ComplexViewHolderAdapter(this, dataList) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val contact = dataList[position] showContactDetail(contact) } } private fun showContactDetail(contact: ContactItem) { AlertDialog.Builder(this) .setTitle(\u0026#34;联系人详情\u0026#34;) .setMessage(\u0026#34;姓名: ${contact.name}\\n电话: ${contact.phone}\\n邮箱: ${contact.email}\\n状态: ${if (contact.isOnline) \u0026#34;在线\u0026#34; else \u0026#34;离线\u0026#34;}\u0026#34;) .setPositiveButton(\u0026#34;确定\u0026#34;) { _, _ -\u0026gt; // 什么都不做 } .show() } } data class ContactItem( val name: String, val phone: String, val email: String, val isOnline: Boolean ) class ComplexViewHolderAdapter( private val context: Context, private val dataList: MutableList\u0026lt;ContactItem\u0026gt; ) : BaseAdapter() { override fun getCount(): Int = dataList.size override fun getItem(position: Int): ContactItem = dataList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view: View val holder: ContactViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.contact_item, parent, false) holder = ContactViewHolder(view) view.tag = holder } else { view = convertView holder = view.tag as ContactViewHolder } val contact = dataList[position] // 绑定数据 holder.nameText.text = contact.name holder.phoneText.text = contact.phone holder.emailText.text = contact.email // 设置在线状态 if (contact.isOnline) { holder.statusIndicator.setBackgroundColor(ContextCompat.getColor(context, R.color.online_color)) holder.statusText.text = \u0026#34;在线\u0026#34; holder.statusText.setTextColor(ContextCompat.getColor(context, R.color.online_color)) } else { holder.statusIndicator.setBackgroundColor(ContextCompat.getColor(context, R.color.offline_color)) holder.statusText.text = \u0026#34;离线\u0026#34; holder.statusText.setTextColor(ContextCompat.getColor(context, R.color.offline_color)) } // 设置头像 holder.avatarImage.setImageResource( when (position % 4) { 0 -\u0026gt; android.R.drawable.ic_menu_myplaces 1 -\u0026gt; android.R.drawable.ic_menu_camera 2 -\u0026gt; android.R.drawable.ic_menu_send else -\u0026gt; android.R.drawable.ic_menu_share } ) return view } private class ContactViewHolder(view: View) { val container: LinearLayout = view.findViewById(R.id.container) val avatarImage: ImageView = view.findViewById(R.id.avatarImage) val nameText: TextView = view.findViewById(R.id.nameText) val phoneText: TextView = view.findViewById(R.id.phoneText) val emailText: TextView = view.findViewById(R.id.emailText) val statusIndicator: View = view.findViewById(R.id.statusIndicator) val statusText: TextView = view.findViewById(R.id.statusText) } } 2. 多类型ViewHolder # class MultiTypeViewHolderActivity : AppCompatActivity() { private lateinit var listView: ListView private lateinit var adapter: MultiTypeViewHolderAdapter private val dataList = mutableListOf\u0026lt;Any\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_multi_type_viewholder) initViews() setupData() setupAdapter() setupListView() } private fun initViews() { listView = findViewById(R.id.listView) } private fun setupData() { dataList.addAll(listOf( HeaderItem(\u0026#34;联系人\u0026#34;), ContactItem(\u0026#34;张三\u0026#34;, \u0026#34;13800138000\u0026#34;, \u0026#34;zhangsan@example.com\u0026#34;, true), ContactItem(\u0026#34;李四\u0026#34;, \u0026#34;13800138001\u0026#34;, \u0026#34;lisi@example.com\u0026#34;, false), HeaderItem(\u0026#34;群组\u0026#34;), GroupItem(\u0026#34;工作群\u0026#34;, \u0026#34;5人\u0026#34;, \u0026#34;最新消息：明天开会\u0026#34;), GroupItem(\u0026#34;朋友群\u0026#34;, \u0026#34;8人\u0026#34;, \u0026#34;最新消息：周末聚餐\u0026#34;) )) } private fun setupAdapter() { adapter = MultiTypeViewHolderAdapter(this, dataList) } private fun setupListView() { listView.adapter = adapter listView.onItemClickListener = AdapterView.OnItemClickListener { _, _, position, _ -\u0026gt; val item = dataList[position] when (item) { is ContactItem -\u0026gt; Toast.makeText(this, \u0026#34;联系人: ${item.name}\u0026#34;, Toast.LENGTH_SHORT).show() is GroupItem -\u0026gt; Toast.makeText(this, \u0026#34;群组: ${item.name}\u0026#34;, Toast.LENGTH_SHORT).show() else -\u0026gt; Toast.makeText(this, \u0026#34;点击了标题\u0026#34;, Toast.LENGTH_SHORT).show() } } } } data class HeaderItem(val title: String) data class GroupItem(val name: String, val memberCount: String, val lastMessage: String) class MultiTypeViewHolderAdapter( private val context: Context, private val dataList: MutableList\u0026lt;Any\u0026gt; ) : BaseAdapter() { companion object { private const val TYPE_HEADER = 0 private const val TYPE_CONTACT = 1 private const val TYPE_GROUP = 2 } override fun getCount(): Int = dataList.size override fun getItem(position: Int): Any = dataList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getViewTypeCount(): Int = 3 override fun getItemViewType(position: Int): Int { return when (dataList[position]) { is HeaderItem -\u0026gt; TYPE_HEADER is ContactItem -\u0026gt; TYPE_CONTACT is GroupItem -\u0026gt; TYPE_GROUP else -\u0026gt; TYPE_HEADER } } override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val item = dataList[position] val viewType = getItemViewType(position) when (viewType) { TYPE_HEADER -\u0026gt; { val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.header_item, parent, false) val holder = view.tag as? HeaderViewHolder ?: HeaderViewHolder(view).also { view.tag = it } val header = item as HeaderItem holder.titleText.text = header.title return view } TYPE_CONTACT -\u0026gt; { val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.contact_item, parent, false) val holder = view.tag as? ContactViewHolder ?: ContactViewHolder(view).also { view.tag = it } val contact = item as ContactItem holder.nameText.text = contact.name holder.phoneText.text = contact.phone holder.emailText.text = contact.email return view } TYPE_GROUP -\u0026gt; { val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.group_item, parent, false) val holder = view.tag as? GroupViewHolder ?: GroupViewHolder(view).also { view.tag = it } val group = item as GroupItem holder.nameText.text = group.name holder.memberCountText.text = group.memberCount holder.lastMessageText.text = group.lastMessage return view } else -\u0026gt; return convertView ?: View(context) } } private class HeaderViewHolder(view: View) { val titleText: TextView = view.findViewById(R.id.titleText) } private class ContactViewHolder(view: View) { val nameText: TextView = view.findViewById(R.id.nameText) val phoneText: TextView = view.findViewById(R.id.phoneText) val emailText: TextView = view.findViewById(R.id.emailText) } private class GroupViewHolder(view: View) { val nameText: TextView = view.findViewById(R.id.nameText) val memberCountText: TextView = view.findViewById(R.id.memberCountText) val lastMessageText: TextView = view.findViewById(R.id.lastMessageText) } } ViewHolder 性能优化 # 1. 性能对比 # // 不使用 ViewHolder（性能较差） class BadAdapter(private val context: Context, private val dataList: List\u0026lt;String\u0026gt;) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view = convertView ?: LayoutInflater.from(context).inflate(R.layout.item_layout, parent, false) // 每次都调用 findViewById（性能开销大） val titleText = view.findViewById\u0026lt;TextView\u0026gt;(R.id.titleText) val subtitleText = view.findViewById\u0026lt;TextView\u0026gt;(R.id.subtitleText) val iconImage = view.findViewById\u0026lt;ImageView\u0026gt;(R.id.iconImage) titleText.text = dataList[position] subtitleText.text = \u0026#34;副标题\u0026#34; return view } } // 使用 ViewHolder（性能优化） class GoodAdapter(private val context: Context, private val dataList: List\u0026lt;String\u0026gt;) : BaseAdapter() { override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view: View val holder: ViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.item_layout, parent, false) holder = ViewHolder(view) view.tag = holder } else { view = convertView holder = view.tag as ViewHolder } // 直接使用缓存的引用（性能优化） holder.titleText.text = dataList[position] holder.subtitleText.text = \u0026#34;副标题\u0026#34; return view } private class ViewHolder(view: View) { val titleText: TextView = view.findViewById(R.id.titleText) val subtitleText: TextView = view.findViewById(R.id.subtitleText) val iconImage: ImageView = view.findViewById(R.id.iconImage) } } 2. 性能测试 # class ViewHolderPerformanceTest : AppCompatActivity() { private lateinit var listView: ListView private lateinit var performanceButton: Button private val dataList = mutableListOf\u0026lt;String\u0026gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_viewholder_performance_test) initViews() setupData() setupListView() setupPerformanceTest() } private fun initViews() { listView = findViewById(R.id.listView) performanceButton = findViewById(R.id.performanceButton) } private fun setupData() { // 生成大量测试数据 repeat(1000) { index -\u0026gt; dataList.add(\u0026#34;测试项目 $index\u0026#34;) } } private fun setupListView() { listView.adapter = OptimizedViewHolderAdapter(this, dataList) } private fun setupPerformanceTest() { performanceButton.setOnClickListener { testPerformance() } } private fun testPerformance() { val startTime = System.currentTimeMillis() // 模拟快速滚动 listView.smoothScrollToPosition(dataList.size - 1) listView.post { val endTime = System.currentTimeMillis() val duration = endTime - startTime Toast.makeText(this, \u0026#34;滚动耗时: ${duration}ms\u0026#34;, Toast.LENGTH_SHORT).show() } } } class OptimizedViewHolderAdapter( private val context: Context, private val dataList: List\u0026lt;String\u0026gt; ) : BaseAdapter() { override fun getCount(): Int = dataList.size override fun getItem(position: Int): String = dataList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view: View val holder: OptimizedViewHolder if (convertView == null) { view = LayoutInflater.from(context).inflate(R.layout.optimized_item, parent, false) holder = OptimizedViewHolder(view) view.tag = holder } else { view = convertView holder = view.tag as OptimizedViewHolder } val item = dataList[position] holder.titleText.text = item holder.subtitleText.text = \u0026#34;位置: $position\u0026#34; // 根据位置设置不同的背景色 when (position % 3) { 0 -\u0026gt; holder.container.setBackgroundColor(ContextCompat.getColor(context, R.color.colorPrimary)) 1 -\u0026gt; holder.container.setBackgroundColor(ContextCompat.getColor(context, R.color.colorAccent)) 2 -\u0026gt; holder.container.setBackgroundColor(ContextCompat.getColor(context, R.color.colorSecondary)) } return view } private class OptimizedViewHolder(view: View) { val container: LinearLayout = view.findViewById(R.id.container) val titleText: TextView = view.findViewById(R.id.titleText) val subtitleText: TextView = view.findViewById(R.id.subtitleText) } } ViewHolder 最佳实践 # 1. 抽象ViewHolder基类 # abstract class BaseViewHolder { abstract fun bindData(data: Any) } class ContactViewHolder(view: View) : BaseViewHolder() { val nameText: TextView = view.findViewById(R.id.nameText) val phoneText: TextView = view.findViewById(R.id.phoneText) val emailText: TextView = view.findViewById(R.id.emailText) override fun bindData(data: Any) { if (data is ContactItem) { nameText.text = data.name phoneText.text = data.phone emailText.text = data.email } } } 2. ViewHolder工具类 # object ViewHolderUtils { fun \u0026lt;T\u0026gt; createViewHolder(view: View, bindView: (View, T) -\u0026gt; Unit): (T) -\u0026gt; Unit { return { data -\u0026gt; bindView(view, data) } } fun createContactViewHolder(view: View): (ContactItem) -\u0026gt; Unit { val nameText = view.findViewById\u0026lt;TextView\u0026gt;(R.id.nameText) val phoneText = view.findViewById\u0026lt;TextView\u0026gt;(R.id.phoneText) val emailText = view.findViewById\u0026lt;TextView\u0026gt;(R.id.emailText) return { contact -\u0026gt; nameText.text = contact.name phoneText.text = contact.phone emailText.text = contact.email } } } 3. 通用ViewHolder适配器 # class GenericViewHolderAdapter\u0026lt;T\u0026gt;( private val context: Context, private val dataList: List\u0026lt;T\u0026gt;, private val layoutRes: Int, private val bindViewHolder: (View, T, Int) -\u0026gt; Unit ) : BaseAdapter() { override fun getCount(): Int = dataList.size override fun getItem(position: Int): T = dataList[position] override fun getItemId(position: Int): Long = position.toLong() override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View { val view = convertView ?: LayoutInflater.from(context).inflate(layoutRes, parent, false) bindViewHolder(view, dataList[position], position) return view } } 📋 总结 # ViewHolder 是 Android 开发中重要的性能优化技术：\n性能优化：避免重复的 findViewById 操作 视图复用：通过 convertView 复用已创建的视图 内存优化：减少不必要的对象创建 多类型支持：支持不同类型的列表项 最佳实践：抽象基类、工具类封装、通用适配器 掌握 ViewHolder 模式对于创建高性能的列表界面至关重要。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/19---viewholder-%E8%A7%86%E5%9B%BE%E4%BF%9D%E6%8C%81%E5%99%A8/","section":"Posts","summary":"详细介绍Android ViewHolder模式的使用方法、性能优化原理和最佳实践","title":"ViewHolder 视图保持器","type":"posts"},{"content":" ViewPager2 滑动切换视图 # ViewPager2 是 Android 中用于实现页面滑动切换的重要组件，它支持水平滑动、垂直滑动，并且提供了丰富的自定义选项。\n应用场景 # 1. 引导界面 # 应用首次启动时的功能介绍 新功能引导页面 用户操作指引 2. 相册多图片预览 # 图片浏览器的滑动切换 相册中的图片轮播 媒体文件的连续播放 3. 多Tab页面 # App主界面的Tab切换 分类页面的滑动浏览 内容分页展示 4. 广告播放 # Banner广告轮播 产品展示轮播 新闻资讯轮播 ViewPager2 的优势 # 相比传统的 ViewPager，ViewPager2 具有以下优势：\n基于 RecyclerView：性能更好，内存占用更少 支持垂直滑动：可以垂直方向滑动 Fragment 支持：原生支持 Fragment 更好的生命周期管理：自动处理 Fragment 生命周期 RTL 支持：支持从右到左的语言 引入方式 # 1. 添加依赖 # 在 build.gradle (Module: app) 中添加：\ndependencies { implementation \u0026#39;androidx.viewpager2:viewpager2:1.0.0\u0026#39; } 2. 版本说明 # ViewPager2: 最新版本，推荐使用 ViewPager: 旧版本，已不推荐 Support Library: 已废弃，建议迁移到 AndroidX 使用步骤 # 步骤1：布局文件中添加 ViewPager2 # \u0026lt;!-- activity_main.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;androidx.viewpager2.widget.ViewPager2 android:id=\u0026#34;@+id/viewPager2\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- 指示器 --\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/indicatorLayout\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_marginTop=\u0026#34;16dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 步骤2：创建页面布局 # \u0026lt;!-- item_page.xml --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:padding=\u0026#34;16dp\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/imageView\u0026#34; android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_marginBottom=\u0026#34;16dp\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:textStyle=\u0026#34;bold\u0026#34; android:textColor=\u0026#34;#333333\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/descriptionTextView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;8dp\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;#666666\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 步骤3：创建适配器 # class ViewPagerAdapter(private val pageList: List\u0026lt;PageData\u0026gt;) : RecyclerView.Adapter\u0026lt;ViewPagerAdapter.ViewHolder\u0026gt;() { override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder { val view = LayoutInflater.from(parent.context) .inflate(R.layout.item_page, parent, false) return ViewHolder(view) } override fun onBindViewHolder(holder: ViewHolder, position: Int) { val pageData = pageList[position] holder.imageView.setImageResource(pageData.imageRes) holder.textView.text = pageData.title holder.descriptionTextView.text = pageData.description } override fun getItemCount(): Int = pageList.size class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { val imageView: ImageView = itemView.findViewById(R.id.imageView) val textView: TextView = itemView.findViewById(R.id.textView) val descriptionTextView: TextView = itemView.findViewById(R.id.descriptionTextView) } } 步骤4：数据模型 # data class PageData( val imageRes: Int, val title: String, val description: String ) 步骤5：在 Activity 中使用 # class MainActivity : AppCompatActivity() { private lateinit var viewPager2: ViewPager2 private lateinit var indicatorLayout: LinearLayout private lateinit var adapter: ViewPagerAdapter override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initViews() setupViewPager() setupIndicators() } private fun initViews() { viewPager2 = findViewById(R.id.viewPager2) indicatorLayout = findViewById(R.id.indicatorLayout) } private fun setupViewPager() { // 准备数据 val pageList = listOf( PageData(R.drawable.image1, \u0026#34;欢迎使用\u0026#34;, \u0026#34;这是第一个页面\u0026#34;), PageData(R.drawable.image2, \u0026#34;功能介绍\u0026#34;, \u0026#34;这是第二个页面\u0026#34;), PageData(R.drawable.image3, \u0026#34;开始使用\u0026#34;, \u0026#34;这是第三个页面\u0026#34;) ) // 设置适配器 adapter = ViewPagerAdapter(pageList) viewPager2.adapter = adapter // 设置页面变化监听 viewPager2.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() { override fun onPageSelected(position: Int) { super.onPageSelected(position) updateIndicators(position) } }) } private fun setupIndicators() { // 创建指示器 repeat(adapter.itemCount) { i -\u0026gt; val indicator = View(this).apply { setBackgroundResource(R.drawable.indicator_unselected) layoutParams = LinearLayout.LayoutParams( dpToPx(8), dpToPx(8) ).apply { setMargins(dpToPx(4), 0, dpToPx(4), 0) } } indicatorLayout.addView(indicator) } // 设置第一个指示器为选中状态 updateIndicators(0) } private fun updateIndicators(position: Int) { repeat(indicatorLayout.childCount) { i -\u0026gt; val indicator = indicatorLayout.getChildAt(i) indicator.setBackgroundResource( if (i == position) R.drawable.indicator_selected else R.drawable.indicator_unselected ) } } private fun dpToPx(dp: Int): Int { return (dp * resources.displayMetrics.density).toInt() } } 高级功能 # 1. 垂直滑动 # // 设置垂直滑动 viewPager2.orientation = ViewPager2.ORIENTATION_VERTICAL 2. 禁用滑动 # // 禁用用户滑动 viewPager2.isUserInputEnabled = false 3. 预加载页面 # // 设置预加载页面数量 viewPager2.offscreenPageLimit = 2 4. Fragment 支持 # class FragmentAdapter(fragmentActivity: FragmentActivity) : FragmentStateAdapter(fragmentActivity) { override fun createFragment(position: Int): Fragment { // 根据位置返回对应的 Fragment return PageFragment.newInstance(position) } override fun getItemCount(): Int = 3 // 页面数量 } 注意事项 # 内存管理：ViewPager2 会自动回收不可见的页面，但仍需注意图片等资源的释放 生命周期：Fragment 的生命周期会被 ViewPager2 自动管理 性能优化：对于大量页面，建议使用 FragmentStateAdapter 而不是 RecyclerView.Adapter 滑动冲突：如果页面内部有滑动组件，需要注意滑动冲突的处理 总结 # ViewPager2 是 Android 开发中实现页面滑动切换的最佳选择，它提供了丰富的功能和良好的性能。通过合理使用 ViewPager2，可以创建出流畅的用户体验和美观的界面效果。\n","date":"24 October 2025","externalUrl":null,"permalink":"/posts/android/20---viewpager-%E6%BB%91%E5%8A%A8%E5%88%87%E6%8D%A2%E8%A7%86%E5%9B%BE/","section":"Posts","summary":"详细介绍了ViewPager2的作用、应用场景、引入方式等","title":"ViewPager 滑动切换视图","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]