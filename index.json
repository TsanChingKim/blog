[{"content":" Activity 活动组件 # 什么是Activity # 什么是activity？app中的每一个页面都是activity\nActivity启动的简单流程： Activity与Layout之间的关系\nActivity之间的跳转 # 在跳转触发的监听器中创建一个Intent并调用startActivity()方法将该Intent传入其中\nActivity之间的跳转是一种栈的数据结构\nStandard # 这也是系统标准的运行模式\n![[ea4d203a90a53056afd2d9704d45e2b3_MD5.png]]\nSingleTop # 顶部复用模式 如果顶部还有用户打开的 Activity 就不会创建新的 Activity ![[4efc467113246a3a5c6406ee3ff0ec71_MD5.png]]\nSingleTask # 如果顶部没有当前用户打开的Activity则会先清除顶部的 Activity 直到找到该Activity ![[7a9c1d7341c3db700ae5d829baa499b9_MD5.png]]\nSingleInstance # 将某个操作模式单独放入到一个栈中 ![[c66414ac7266fe9523803f4572e68202_MD5.png]]\nActivity 启动方式 # 显式启动 # 使用Intent方法传入要启动的 Activity\n隐式启动 # 通过Intent的action、category、data等属性来启动Activity\nstartActivityForResult # 可以使用requestCode进行打开的Activity的分辨\nActivity 生命周期 # ![[3ef71fe678c5084426406babcc0c36c7_MD5.png]]\n单个Activity的生命周期 # --- title: 基础操作会引发的生命周期变化 --- graph TD subgraph 再次启动 G(onCreate) --\u003e H(onStart) H --\u003e I(onResume) end subgraph 正常退出 D(onPause) --\u003e E(onStop) E --\u003e F(onDestroy) end subgraph 正常进入 A(onCreate) --\u003e B(onStart) B --\u003e C(onResume) end 已经处于前台的 Activity，点击主页按钮离开当前 Activity # graph TD subgraph 回到 Activity C(onRestart) --\u003e D(onStart) D --\u003e E(onResume) end subgraph 单击主页按钮离开页面 A(onPause) --\u003e B(onStop) end Activity不可操作（如息屏、打开了其他Activity）而应用被强行杀死了 # graph TD subgraph 重新回到Activity C(onCreate) --\u003e D(onStart) D --\u003e E(onResume) end subgraph 不可操作并被kill A(onPause) --\u003e B(onStop) end [!error] 注意 普通对话框对生命周期没有任何影响，如果有个Activity伪装成对话框模式，那么当他启动时，之前的Activity:onPause，\u0026ldquo;对话框\u0026quot;消失后，回调onResume\nActivity之间信息传递 # 传递简单内容 # 通过putExtra来进行放入操作，通过getXXXExtra来获取内容\n传递对象 # 通过putExtra来传递序列化之后的对象，通过getSerializableExtra()方法来获取对象\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/11-activity%E6%B4%BB%E5%8A%A8%E7%BB%84%E4%BB%B6/","section":"Posts","summary":"","title":"Activity活动组件","type":"posts"},{"content":" 定义 # 消息提示机制，长用于向用户传递信息，提示或警告用户的行为。通用的方法有：\nsetTitle setMesssage create show 实现步骤 # 先实例化一个AlertDialog.Builder类型的对象其参数为环境上下文 使用builder.setTitle()方法来设置提示消息的title 使用builder.setMessage()方法来设置消息提示的内容 使用builder.setPositiveButton()方法来设置单机确认时的动作 使用builder.setNegativeButton()方法来设置点击取消时的动作 使用builder.create()来创建Dialog对象 最后使用dialog.show()来展示对话框 自定义对话框 # 步骤 # 设置布局 设置Style 自定义Dialog 显示 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/13-alertdialog/","section":"Posts","summary":"","title":"AlertDialog对话框","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E5%9F%BA%E7%A1%80/","section":"Categories","summary":"","title":"Android基础","type":"categories"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E5%AF%B9%E8%AF%9D%E6%A1%86/","section":"Categories","summary":"","title":"Android对话框","type":"categories"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E5%B8%83%E5%B1%80/","section":"Categories","summary":"","title":"Android布局","type":"categories"},{"content":" Android开发方式 # Android UI的开发方式有两种：\njava代码开发 xml文件开发 前者要创建布局对象，并定义布局内容，然后定义布局的属性（宽、高、背景等等） 再将内容设置为该布局\n后者只需要添加xml标签，并且添加定义xml标签的属性即可实现页面的编写\n\\[!faq\\] 我们在开发过程中需要使用哪种方式开发？ 建议使用后者开发，java代码开发的方式需要编写很多代码，包括对象创建，属性赋值，页面赋值等等等等，但是xml并不需要这么多的开发步骤，而是直接在布局文件中编写代码\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/01-android%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F/","section":"Posts","summary":"","title":"Android开发方式","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E6%8E%A7%E4%BB%B6/","section":"Categories","summary":"","title":"Android控件","type":"categories"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E7%BB%84%E4%BB%B6/","section":"Categories","summary":"","title":"Android组件","type":"categories"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E9%80%82%E9%85%8D%E5%99%A8/","section":"Categories","summary":"","title":"Android适配器","type":"categories"},{"content":" 定义 # 数组适配器，只能用来显示单一的文本。构造方法：\nArrayAdapter(Context context,int resource,int textviewId,List\u0026lt;T\u0026gt;objects) context：环境上下文 resource：要放置的view的id textviewId：文本需要放在布局中对应id文本控件的位置 objects：数据源 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/15-arrayadapter/","section":"Posts","summary":"","title":"ArrayAdapter数组适配器","type":"posts"},{"content":"和SimpleAdapter的区别是，可以调整某个想要调整的元素的内容\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/18-baseadapter/","section":"Posts","summary":"","title":"BaseAdapter基础适配器","type":"posts"},{"content":" Button 按钮控件 # button注册点击时间的方法：\n自定义内部类 匿名内部类 当前Activity去实现事件接口 在布局文件中添加点击事件属性 1.使用自定义内部类实现单机事件 # class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 设置当前显示的视图的xml文件的文件名 setContentView(R.layout.acitivity_main) // 根据控件id获取控件 val btn: Button = findViewById(R.id.btn1) // 获取单击事件监听器对象 val myOnClickListener = MyOnClickListener() // 设置改控件的单击事件监听器为上述获取的监听器对象 btn.setOnClickListener(myOnClickListener) } class MyOnClickListener : View.OnClickListener { override fun onClick(v: View?) { println(\u0026#34;11111111111\u0026#34;) } } } 2.使用匿名内部类实现单击事件 # class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 设置当前显示的视图的xml文件的文件名 setContentView(R.layout.acitivity_main) // 根据控件id获取控件 val btn: Button = findViewById(R.id.btn1) // 设置改控件的单击事件监听器为匿名内部类 btn.setOnClickListener(object : OnClickListener { override fun onClick(v: View?) { println(\u0026#34;这是使用匿名内部类实现的单机事件监听器\u0026#34;) } }) } } 3.使用本类实现单击事件 # class MainActivity : ComponentActivity(), OnClickListener { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 设置当前显示的视图的xml文件的文件名 setContentView(R.layout.acitivity_main) // 根据控件id获取控件 val btn: Button = findViewById(R.id.btn1) // 获取单击事件监听器对象 val myOnClickListener = MyOnClickListener() // 设置改控件的单击事件监听器为本类 btn.setOnClickListener(this) } override fun onClick(v: View?) { Log.e(\u0026#34;TAG\u0026#34;,\u0026#34;本类实现单击事件\u0026#34;) } } 4.使用XML绑定函数作为单击事件 # \u0026lt;Button android:id=\u0026#34;@+id/btn1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:layout_marginTop=\u0026#34;30dp\u0026#34; android:text=\u0026#34;Register\u0026#34; android:onClick=\u0026#34;myOnClick\u0026#34; /\u0026gt; fun myOnClick(v: View?){ Log.e(\u0026#34;TAG\u0026#34;,\u0026#34;这是被onClick属性绑定的单击事件\u0026#34;) } ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/05-button%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"","title":"Button按钮控件","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" ConstraintLayout 约束布局 # 当前控件的某个方位和另一个参照物的某个方位对齐\napp:layout_constraintLeft_toleftOf： 相当于RelativeLayout的alignLeft属性 app:layout_constraintRight_toRightOf： 相当于RelativeLayout的alignRight属性 app:layout_constraintTop_toTopOf：相当于RelativeLayout的alignTop属性 app:layout_constraintBottom_toBottomOf：相当于RelativeLayout的alignBottom属性 app:layout_constraintStart_toStartOf：同Left_toLeft0f app:layout_constraintEnd_toEndOf：同Right_toRight0f 当前控件的A侧会在参照物的B侧\napp:layout_constraintLeft_toRightOf： 相当于RelativeLayout的toRight0\napp:layout_constraintRight_toleftOf：相当于RelativeLayout的toLeft0f\napp:layout_constraintTop_toBottomOf： 相当于RelativeLayout的below\napp:layout_constraintBottom_toTopOf： 相当于RelativeLayout的above\napp:layout_constraintStart_toEndOf： 同Left_toRightof\napp:layout_constraintEnd_toStartOf： 同Right_toleftof\napp:layout_constraintVertical_bias=\u0026quot;0.443\u0026quot;：垂直偏移量，0.5在正中间\napp:layout_constraintHorizontal_bias=\u0026quot;0.443\u0026quot;：水平偏移量，0.5在正中间\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/09-constraintlayout%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80/","section":"Posts","summary":"","title":"ConstraintLayout约束布局","type":"posts"},{"content":" Fragment 概念 # 概念 # 为了给Pad等更大的屏幕提供公开的UI支持\nFragment VS Activity # Fragment 是到 Android 3.0+ 以后 一个Activity可以运行多个Fragment Fragment 不能脱离 Activity 而存在 Activity 是屏幕的主题，而Fragment 是 Activity 的一个组成元素 Fragment 生命周期 # Fragment 加载方式 # 静态加载 # 创建 Fragment，调用onCreate方法 在xml中创建fragment后使用android:name指定fragment1的名称 动态加载 # 动态切换实例 # Fragment 的传值问题 # Activity \u0026ndash;\u0026gt; Fragment传值 # setArgument # 其他 # Fragment \u0026ndash;\u0026gt; Activity传值 # Callback # ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/16-fragment%E4%BD%BF%E7%94%A8%E5%85%A8%E8%A7%A3%E6%9E%90/","section":"Posts","summary":"","title":"Fragment使用全解析","type":"posts"},{"content":" FrameLayout 帧布局 # 在该容器下，所有的控件都是从最底部开始层叠排列的\n重要属性：\nandroid:layout_gravity：控制控件所在的位置 android:layout_gravity：控件的前景 android:layout_gravity：前景重力 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;350dp\u0026#34; android:layout_height=\u0026#34;350dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#0000FF\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;330dp\u0026#34; android:layout_height=\u0026#34;330dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#9932CC\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#FF1493\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;270dp\u0026#34; android:layout_height=\u0026#34;270dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#DA70D6\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;240dp\u0026#34; android:layout_height=\u0026#34;240dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#00BFFF\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#191970\u0026#34;/\u0026gt; \u0026lt;/FrameLayout\u0026gt; 最终效果为： ![[1d62d03826b12e324c72ade5639ea696_MD5.png]]\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/08-framelayout%E5%B8%A7%E5%B8%83%E5%B1%80/","section":"Posts","summary":"","title":"FrameLayout帧布局","type":"posts"},{"content":" ImageView 图片控件 # 用来显示和控制图像的空间，可以对它进行放大、缩小、旋转等操作。\n项目中有两个文件夹：mipmap 和 drawable\ndrawable：高清图片文件夹 mipmap：普通图片存放 一般都存放至mipmap \u0026lt;ImageView android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@mipmap/ic_launcher_round\u0026#34; android:layout_marginTop=\u0026#34;30dp\u0026#34; /\u0026gt; src：用来指定前景图片资源 前景图片的特点：不管大小如何变化，图片会始终保持其原有的比例 background：使用图片作为背景 背景图片的特点：不管大小如何变化，图片会随着大小变化，不会维持其大小 \u0026lt;ImageButton android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:src=\u0026#34;@mipmap/ic_launcher_round\u0026#34;/\u0026gt; ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/06-imageview%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"","title":"ImageView图片控件","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/linearlayout/","section":"Tags","summary":"","title":"LinearLayout","type":"tags"},{"content":" 定义 # 长按时，在长按位置弹出的气泡框\n步骤 # 创建PopupWindow对象实例 设置背景，注册时间监听器和添加动画 显示PopupWindow setOutsideTouchable(true)设置能响应外部的点击事件 setTouchable(true)设置弹窗能响应点击事件 弹窗动画 # 创建动画资源 创建一个style应用动画资源 对当前弹窗的动画风格设置为第二步的资源索引 动画类型 # alpha rotate scale set translate ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/14-popupwindow/","section":"Posts","summary":"","title":"PopupWindow弹出窗口","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" ProgressBar 进度条控件 # \u0026lt;ProgressBar android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; 如果只是这三行代码，只会是一个旋转的加载图标\n\u0026lt;ProgressBar android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; style=\u0026#34;?android:attr/progressBarStyleHorizontal\u0026#34; android:progress=\u0026#34;30\u0026#34; android:max=\u0026#34;100\u0026#34;/\u0026gt; style：设置风格 progress：当前进度 max：总进度 在业务中需要根据它的id获取该控件并修改其进度\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/07-progressbar%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"","title":"ProgressBar进度条控件","type":"posts"},{"content":"当创建了一个列表时，列表中的每个元素的布局都是一样的 每个列表元素的名字都是一样的所以可以用Adapter来映射他们的对应关系\nSimpleAdapter adapter = SimpleAdapter(this,data,R.layout.xxx,from,to) this：环境上下文 data：数据源 R.layout.xxx：SimpleAdapter所对应的Activity from：展示的数据的名称 to：展示的数据的控件的id ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/17-simpleadapter/","section":"Posts","summary":"","title":"SimpleAdapter简单适配器","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/","section":"TsanChing Kim's Blog","summary":"","title":"TsanChing Kim's Blog","type":"page"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/ui/","section":"Tags","summary":"","title":"UI","type":"tags"},{"content":" UI 基础控件 View # 分类 # 处理文本内容的View（TextView） 被点击的View（Button） 处理图片内容的VIew（ImageView） 接收用户信息输入的View（EditView） 进度条类的View（ProgressBar） 📚TextView # flowchart TB A(\"View\") --\u003e B(\"TextView\") B --\u003e C(\"Button\") B --\u003e D(\"EditText\") TextView 类似于Swing中的JLable，对长文本进行显示处理。支持Html，内容有样式链接效果\ntextSize：设置字体大小 textColor：设置颜色 lineSpacingMultiplier：设置行倍距 ScrollView：让页面变成滚动布局（当文本内容过多时，需要滚动页面来查看所有文本） singleLine：当设置为true时整个长文本只会显示1行并在最后显示省略号表示后面有省略的文本 长文本跑马灯实现：\nfocusable：当设置为true时可以获取焦点 focusableInTouchMode：当设置为true时即为设置在触摸时获取焦点 marqueeRepeatLimit：设置跑马灯时长 📓EditText # inputType：输入内容的类型 textPassword：密码 number：只能输入正整数 numberSigned：只能输入整数 numberDecimal：只能输入小数 maxLength：限制输入的最大长度 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/04-ui%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6-view/","section":"Posts","summary":"","title":"UI基础控件 View","type":"posts"},{"content":"当滑动到list中的某个元素时，会将其加载出来，而滑到别的元素后重新滑动到已经加载过得的元素时，会进行重新加载，\n利用进入RecycleBin获取已经加载过的控件 # 使用ViewHolder进行列表优化 # 自定义一个类，叫做ViewHolder 将需要保存的视图声明为公开的属性 什么适合保存？当view为null时，完成对ViewHolder的实例化工作，并为各个空间属性赋值 什么时候用？什么时候都要用（性能提升是在view不为null时体现的） 怎么用？当view控件为null时，完成了ViewHolder及内部空间属性初始化工作后，调用一句代码 view.setTag(holder) 可是当view不为空时，holder = view.getTag() ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/19-viewholder/","section":"Posts","summary":"","title":"ViewHolder模式优化","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/xml/","section":"Tags","summary":"","title":"XML","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/%E5%B8%83%E5%B1%80/","section":"Tags","summary":"","title":"布局","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F/","section":"Tags","summary":"","title":"开发方式","type":"tags"},{"content":" 相对布局 (RelativeLayout) # 属性 # 相对父容器 # 以下属性默认都是false，只有手动设置为true时才会生效\nlayout_centerInParent：相对于父容器居中（水平且垂直） layout_alignParentLeft：相对于父容器左对齐 layout_alignParentRight：相对于父容器右对齐 layout_alignParentTop：相对于父容器顶部对齐 layout_alignParentBottom：相对于父容器底部对齐 layout_centerHorizontal：相对整个屏幕水平居中 layout_centerVertical：相对整个屏幕垂直居中 相对同级别容器 # 在参照物的某边： # 以下属性默认都是false，只有手动设置为true时才会生效\nlayout_toLeftOf：相对某个同级别容器，对齐在其左边边框线上 layout_toRightOf：相对某个同级别容器，对齐在其右边边框上 layout_above：对齐某个同级别容器的上边线 layout_below：对齐某个同级别容器的下边线 和参照物的某边对线对齐： # layout_alignTop：和参照物的顶部边线对齐 layout_alignBottom：和参照物的底部边线对齐 layout_alignLeft：和参照物的左边线对齐 layout_alignRight：和参照物的右边线对齐 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/03-%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80/","section":"Posts","summary":"","title":"相对布局 (RelativeLayout)","type":"posts"},{"content":" 线性布局 (LinearLayout) # 分类 # 线性布局(LinearLayout) 相对布局 帧布局 表格布局（TableLayout） 网格布局（GridLayout） 容器中的所有元素都是按照从上到下或从左到右依次排列的\n使用 # 在layout文件夹下创建layout类型的文件 除了定义文件名之外，还要定义Root Element 该值是指定根元素的布局\n属性 # orientation：容器的方向 vertical：垂直的 horizontal：水平的 layout_weight：权重（为容器中的元素提供的属性） 作用：按比例划分空间 重要条件：需要将layout_width写成0 layout_width：容器的宽度 20dp：自定义宽度 match_parent：和父容器的宽度保持一致 wrap_content：包裹内容，即内容多宽，容器就多宽 layout_height：容器的高度 20dp：自定义高度 match_parent：和父容器的高度保持一致 wrap_content：包裹内容，即内容多高，容器就多高 layout_gravity：容器的重力即容器会往哪一边靠 top：顶部对齐 bottom：底部对齐 center：居中对齐 left：左对齐 right：右对齐 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/02-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80/","section":"Posts","summary":"","title":"线性布局 (LinearLayout)","type":"posts"},{"content":" 菜单组件 # OptionMenu 选项菜单 # 选项菜单是一个应用主菜单，用于放置对应用产生全局影响的操作\nonCreateOptionsMenu()：将menu赋值到页面当中 onOptionItemSelected()：当选择菜单项时做的操作 xml属性：\nshowAsAction always：直接在标题栏显示 never：不显示 ifRoom：有空间就显示 ContextMenu 上下文菜单 # 在长按时弹出的一个菜单\n首先进行上下文菜单的注册：registerForContextMenu(View控件对象) 在类中创建上下文：onCreateContextMenu() 选中时的处理：onContextItemSelected() 在长按触发器时，在顶部会出现一个菜单来进行操作\nPopupMenu 弹出菜单 # 一个模态形式展示的弹出风格的菜单，绑在View上，一般出现在被绑定的View的下方\n步骤 # 实例化PopupMenu对象 加载菜单资源：利用MenuInflater 将R.menu.xx对应的菜单资源加载到弹出式菜单中 为PopupMenu设置点击监听器 menu.show()展示这个菜单 Menu的创建方式 # Java方式定义 # XML方式定义 # 总结 # [!info] 经验分享 xml定义Menu的优势：清晰地菜单结构，将菜单内容与应用的逻辑代码分离，资源适配更容易\nMenu显示：onCreateOptionsMenu()方法必须返回true，onOptionItemSelected()方法返回true且调用父类的默认实现\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/12-%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6/","section":"Posts","summary":"","title":"菜单组件","type":"posts"},{"content":" 选择控件 # CheckBox 复选框 # CheckBox是系统封装的复选控件，两种状态选中及未选中 setChecked() isChecked()。监听状态变化：setOnCheckedChangeListener\nRadioButton 单选框 # 单选控件，可以和RadioGroup一起使用，只能选择一个\n和CheckBox的区别：\n通过点击无法变为未选中 一组 RadioButton，只能同时选中一个 在大部分UI框架中默认都以圆形表示 ToggleButton 切换按钮 # 切换程序中的状态。该控件只有两种状态，一种是开一种是关\nandroid:textOn android:textOff setChecked(boolean) setOnCheckedChangeListener SeekBar 滑动条 # 使用场景：如音乐播放器等\n简单使用与时间监听：\nsetProgress setOnSeekBarChangeListener ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/10-%E9%80%89%E6%8B%A9%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"","title":"选择控件","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]