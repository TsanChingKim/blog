[{"content":" Activity 活动组件 # 什么是Activity # 什么是activity？app中的每一个页面都是activity\nActivity启动的简单流程： Activity与Layout之间的关系\nActivity之间的跳转 # 在跳转触发的监听器中创建一个Intent并调用startActivity()方法将该Intent传入其中\nActivity之间的跳转是一种栈的数据结构\nStandard # 这也是系统标准的运行模式\nSingleTop # 顶部复用模式 如果顶部还有用户打开的 Activity 就不会创建新的 Activity SingleTask # 如果顶部没有当前用户打开的Activity则会先清除顶部的 Activity 直到找到该Activity SingleInstance # 将某个操作模式单独放入到一个栈中 Activity 启动方式 # 显式启动 # 使用Intent方法传入要启动的 Activity\n隐式启动 # 通过Intent的action、category、data等属性来启动Activity\nstartActivityForResult # 可以使用requestCode进行打开的Activity的分辨\nActivity 生命周期 # 单个Activity的生命周期 # --- title: 基础操作会引发的生命周期变化 --- graph TD subgraph 再次启动 G(onCreate) --\u003e H(onStart) H --\u003e I(onResume) end subgraph 正常退出 D(onPause) --\u003e E(onStop) E --\u003e F(onDestroy) end subgraph 正常进入 A(onCreate) --\u003e B(onStart) B --\u003e C(onResume) end 已经处于前台的 Activity，点击主页按钮离开当前 Activity # graph TD subgraph 回到 Activity C(onRestart) --\u003e D(onStart) D --\u003e E(onResume) end subgraph 单击主页按钮离开页面 A(onPause) --\u003e B(onStop) end Activity不可操作（如息屏、打开了其他Activity）而应用被强行杀死了 # graph TD subgraph 重新回到Activity C(onCreate) --\u003e D(onStart) D --\u003e E(onResume) end subgraph 不可操作并被kill A(onPause) --\u003e B(onStop) end [!error] 注意 普通对话框对生命周期没有任何影响，如果有个Activity伪装成对话框模式，那么当他启动时，之前的Activity:onPause，\u0026ldquo;对话框\u0026quot;消失后，回调onResume\nActivity之间信息传递 # 传递简单内容 # 通过putExtra来进行放入操作，通过getXXXExtra来获取内容\n传递对象 # 通过putExtra来传递序列化之后的对象，通过getSerializableExtra()方法来获取对象\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/11-activity%E6%B4%BB%E5%8A%A8%E7%BB%84%E4%BB%B6/","section":"Posts","summary":"","title":"Activity活动组件","type":"posts"},{"content":" 定义 # 消息提示机制，长用于向用户传递信息，提示或警告用户的行为。通用的方法有：\nsetTitle setMesssage create show 实现步骤 # 先实例化一个AlertDialog.Builder类型的对象其参数为环境上下文 使用builder.setTitle()方法来设置提示消息的title 使用builder.setMessage()方法来设置消息提示的内容 使用builder.setPositiveButton()方法来设置单机确认时的动作 使用builder.setNegativeButton()方法来设置点击取消时的动作 使用builder.create()来创建Dialog对象 最后使用dialog.show()来展示对话框 自定义对话框 # 步骤 # 设置布局 设置Style 自定义Dialog 显示 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/13-alertdialog/","section":"Posts","summary":"","title":"AlertDialog对话框","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E5%9F%BA%E7%A1%80/","section":"Categories","summary":"","title":"Android基础","type":"categories"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E5%AF%B9%E8%AF%9D%E6%A1%86/","section":"Categories","summary":"","title":"Android对话框","type":"categories"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E5%B8%83%E5%B1%80/","section":"Categories","summary":"","title":"Android布局","type":"categories"},{"content":" Android开发方式 # Android UI的开发方式有两种：\njava代码开发 xml文件开发 前者要创建布局对象，并定义布局内容，然后定义布局的属性（宽、高、背景等等） 再将内容设置为该布局\n后者只需要添加xml标签，并且添加定义xml标签的属性即可实现页面的编写\n\\[!faq\\] 我们在开发过程中需要使用哪种方式开发？ 建议使用后者开发，java代码开发的方式需要编写很多代码，包括对象创建，属性赋值，页面赋值等等等等，但是xml并不需要这么多的开发步骤，而是直接在布局文件中编写代码\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/01-android%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F/","section":"Posts","summary":"","title":"Android开发方式","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E6%8E%A7%E4%BB%B6/","section":"Categories","summary":"","title":"Android控件","type":"categories"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E7%BB%84%E4%BB%B6/","section":"Categories","summary":"","title":"Android组件","type":"categories"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/android%E9%80%82%E9%85%8D%E5%99%A8/","section":"Categories","summary":"","title":"Android适配器","type":"categories"},{"content":" 定义 # 数组适配器，只能用来显示单一的文本。构造方法：\nArrayAdapter(Context context,int resource,int textviewId,List\u0026lt;T\u0026gt;objects) context：环境上下文 resource：要放置的view的id textviewId：文本需要放在布局中对应id文本控件的位置 objects：数据源 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/15-arrayadapter/","section":"Posts","summary":"","title":"ArrayAdapter数组适配器","type":"posts"},{"content":"和SimpleAdapter的区别是，可以调整某个想要调整的元素的内容\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/18-baseadapter/","section":"Posts","summary":"","title":"BaseAdapter基础适配器","type":"posts"},{"content":" Button 按钮控件 # button注册点击时间的方法：\n自定义内部类 匿名内部类 当前Activity去实现事件接口 在布局文件中添加点击事件属性 1.使用自定义内部类实现单机事件 # class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 设置当前显示的视图的xml文件的文件名 setContentView(R.layout.acitivity_main) // 根据控件id获取控件 val btn: Button = findViewById(R.id.btn1) // 获取单击事件监听器对象 val myOnClickListener = MyOnClickListener() // 设置改控件的单击事件监听器为上述获取的监听器对象 btn.setOnClickListener(myOnClickListener) } class MyOnClickListener : View.OnClickListener { override fun onClick(v: View?) { println(\u0026#34;11111111111\u0026#34;) } } } 2.使用匿名内部类实现单击事件 # class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 设置当前显示的视图的xml文件的文件名 setContentView(R.layout.acitivity_main) // 根据控件id获取控件 val btn: Button = findViewById(R.id.btn1) // 设置改控件的单击事件监听器为匿名内部类 btn.setOnClickListener(object : OnClickListener { override fun onClick(v: View?) { println(\u0026#34;这是使用匿名内部类实现的单机事件监听器\u0026#34;) } }) } } 3.使用本类实现单击事件 # class MainActivity : ComponentActivity(), OnClickListener { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 设置当前显示的视图的xml文件的文件名 setContentView(R.layout.acitivity_main) // 根据控件id获取控件 val btn: Button = findViewById(R.id.btn1) // 获取单击事件监听器对象 val myOnClickListener = MyOnClickListener() // 设置改控件的单击事件监听器为本类 btn.setOnClickListener(this) } override fun onClick(v: View?) { Log.e(\u0026#34;TAG\u0026#34;,\u0026#34;本类实现单击事件\u0026#34;) } } 4.使用XML绑定函数作为单击事件 # \u0026lt;Button android:id=\u0026#34;@+id/btn1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:layout_marginTop=\u0026#34;30dp\u0026#34; android:text=\u0026#34;Register\u0026#34; android:onClick=\u0026#34;myOnClick\u0026#34; /\u0026gt; fun myOnClick(v: View?){ Log.e(\u0026#34;TAG\u0026#34;,\u0026#34;这是被onClick属性绑定的单击事件\u0026#34;) } ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/05-button%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"","title":"Button按钮控件","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" ConstraintLayout 约束布局 # 当前控件的某个方位和另一个参照物的某个方位对齐\napp:layout_constraintLeft_toleftOf： 相当于RelativeLayout的alignLeft属性 app:layout_constraintRight_toRightOf： 相当于RelativeLayout的alignRight属性 app:layout_constraintTop_toTopOf：相当于RelativeLayout的alignTop属性 app:layout_constraintBottom_toBottomOf：相当于RelativeLayout的alignBottom属性 app:layout_constraintStart_toStartOf：同Left_toLeft0f app:layout_constraintEnd_toEndOf：同Right_toRight0f 当前控件的A侧会在参照物的B侧\napp:layout_constraintLeft_toRightOf： 相当于RelativeLayout的toRight0\napp:layout_constraintRight_toleftOf：相当于RelativeLayout的toLeft0f\napp:layout_constraintTop_toBottomOf： 相当于RelativeLayout的below\napp:layout_constraintBottom_toTopOf： 相当于RelativeLayout的above\napp:layout_constraintStart_toEndOf： 同Left_toRightof\napp:layout_constraintEnd_toStartOf： 同Right_toleftof\napp:layout_constraintVertical_bias=\u0026quot;0.443\u0026quot;：垂直偏移量，0.5在正中间\napp:layout_constraintHorizontal_bias=\u0026quot;0.443\u0026quot;：水平偏移量，0.5在正中间\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/09-constraintlayout%E7%BA%A6%E6%9D%9F%E5%B8%83%E5%B1%80/","section":"Posts","summary":"","title":"ConstraintLayout约束布局","type":"posts"},{"content":" Fragment 概念 # 概念 # 为了给Pad等更大的屏幕提供公开的UI支持\nFragment VS Activity # Fragment 是到 Android 3.0+ 以后 一个Activity可以运行多个Fragment Fragment 不能脱离 Activity 而存在 Activity 是屏幕的主题，而Fragment 是 Activity 的一个组成元素 Fragment 生命周期 # Fragment 加载方式 # 静态加载 # 创建 Fragment，调用onCreate方法 在xml中创建fragment后使用android:name指定fragment1的名称 动态加载 # 动态切换实例 # Fragment 的传值问题 # Activity \u0026ndash;\u0026gt; Fragment传值 # setArgument # 其他 # Fragment \u0026ndash;\u0026gt; Activity传值 # Callback # ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/16-fragment%E4%BD%BF%E7%94%A8%E5%85%A8%E8%A7%A3%E6%9E%90/","section":"Posts","summary":"","title":"Fragment使用全解析","type":"posts"},{"content":" FrameLayout 帧布局 # 在该容器下，所有的控件都是从最底部开始层叠排列的\n重要属性：\nandroid:layout_gravity：控制控件所在的位置 android:layout_gravity：控件的前景 android:layout_gravity：前景重力 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;350dp\u0026#34; android:layout_height=\u0026#34;350dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#0000FF\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;330dp\u0026#34; android:layout_height=\u0026#34;330dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#9932CC\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#FF1493\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;270dp\u0026#34; android:layout_height=\u0026#34;270dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#DA70D6\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;240dp\u0026#34; android:layout_height=\u0026#34;240dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#00BFFF\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:background=\u0026#34;#191970\u0026#34;/\u0026gt; \u0026lt;/FrameLayout\u0026gt; 最终效果为： ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/08-framelayout%E5%B8%A7%E5%B8%83%E5%B1%80/","section":"Posts","summary":"","title":"FrameLayout帧布局","type":"posts"},{"content":" ImageView 图片控件 # 用来显示和控制图像的空间，可以对它进行放大、缩小、旋转等操作。\n项目中有两个文件夹：mipmap 和 drawable\ndrawable：高清图片文件夹 mipmap：普通图片存放 一般都存放至mipmap \u0026lt;ImageView android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@mipmap/ic_launcher_round\u0026#34; android:layout_marginTop=\u0026#34;30dp\u0026#34; /\u0026gt; src：用来指定前景图片资源 前景图片的特点：不管大小如何变化，图片会始终保持其原有的比例 background：使用图片作为背景 背景图片的特点：不管大小如何变化，图片会随着大小变化，不会维持其大小 \u0026lt;ImageButton android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:src=\u0026#34;@mipmap/ic_launcher_round\u0026#34;/\u0026gt; ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/06-imageview%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"","title":"ImageView图片控件","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/linearlayout/","section":"Tags","summary":"","title":"LinearLayout","type":"tags"},{"content":" 定义 # 长按时，在长按位置弹出的气泡框\n步骤 # 创建PopupWindow对象实例 设置背景，注册时间监听器和添加动画 显示PopupWindow setOutsideTouchable(true)设置能响应外部的点击事件 setTouchable(true)设置弹窗能响应点击事件 弹窗动画 # 创建动画资源 创建一个style应用动画资源 对当前弹窗的动画风格设置为第二步的资源索引 动画类型 # alpha rotate scale set translate ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/14-popupwindow/","section":"Posts","summary":"","title":"PopupWindow弹出窗口","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" ProgressBar 进度条控件 # \u0026lt;ProgressBar android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; 如果只是这三行代码，只会是一个旋转的加载图标\n\u0026lt;ProgressBar android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; style=\u0026#34;?android:attr/progressBarStyleHorizontal\u0026#34; android:progress=\u0026#34;30\u0026#34; android:max=\u0026#34;100\u0026#34;/\u0026gt; style：设置风格 progress：当前进度 max：总进度 在业务中需要根据它的id获取该控件并修改其进度\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/07-progressbar%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"","title":"ProgressBar进度条控件","type":"posts"},{"content":"当创建了一个列表时，列表中的每个元素的布局都是一样的 每个列表元素的名字都是一样的所以可以用Adapter来映射他们的对应关系\nSimpleAdapter adapter = SimpleAdapter(this,data,R.layout.xxx,from,to) this：环境上下文 data：数据源 R.layout.xxx：SimpleAdapter所对应的Activity from：展示的数据的名称 to：展示的数据的控件的id ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/17-simpleadapter/","section":"Posts","summary":"","title":"SimpleAdapter简单适配器","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/","section":"TsanChing Kim's Blog","summary":"","title":"TsanChing Kim's Blog","type":"page"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/ui/","section":"Tags","summary":"","title":"UI","type":"tags"},{"content":" UI 基础控件 View # 分类 # 处理文本内容的View（TextView） 被点击的View（Button） 处理图片内容的VIew（ImageView） 接收用户信息输入的View（EditView） 进度条类的View（ProgressBar） 📚TextView # flowchart TB A(\"View\") --\u003e B(\"TextView\") B --\u003e C(\"Button\") B --\u003e D(\"EditText\") TextView 类似于Swing中的JLable，对长文本进行显示处理。支持Html，内容有样式链接效果\ntextSize：设置字体大小 textColor：设置颜色 lineSpacingMultiplier：设置行倍距 ScrollView：让页面变成滚动布局（当文本内容过多时，需要滚动页面来查看所有文本） singleLine：当设置为true时整个长文本只会显示1行并在最后显示省略号表示后面有省略的文本 长文本跑马灯实现：\nfocusable：当设置为true时可以获取焦点 focusableInTouchMode：当设置为true时即为设置在触摸时获取焦点 marqueeRepeatLimit：设置跑马灯时长 📓EditText # inputType：输入内容的类型 textPassword：密码 number：只能输入正整数 numberSigned：只能输入整数 numberDecimal：只能输入小数 maxLength：限制输入的最大长度 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/04-ui%E5%9F%BA%E7%A1%80%E6%8E%A7%E4%BB%B6-view/","section":"Posts","summary":"","title":"UI基础控件 View","type":"posts"},{"content":"当滑动到list中的某个元素时，会将其加载出来，而滑到别的元素后重新滑动到已经加载过得的元素时，会进行重新加载，\n利用进入RecycleBin获取已经加载过的控件 # 使用ViewHolder进行列表优化 # 自定义一个类，叫做ViewHolder 将需要保存的视图声明为公开的属性 什么适合保存？当view为null时，完成对ViewHolder的实例化工作，并为各个空间属性赋值 什么时候用？什么时候都要用（性能提升是在view不为null时体现的） 怎么用？当view控件为null时，完成了ViewHolder及内部空间属性初始化工作后，调用一句代码 view.setTag(holder) 可是当view不为空时，holder = view.getTag() ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/19-viewholder/","section":"Posts","summary":"","title":"ViewHolder模式优化","type":"posts"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/xml/","section":"Tags","summary":"","title":"XML","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/%E5%B8%83%E5%B1%80/","section":"Tags","summary":"","title":"布局","type":"tags"},{"content":"","date":"22 October 2025","externalUrl":null,"permalink":"/tags/%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F/","section":"Tags","summary":"","title":"开发方式","type":"tags"},{"content":" 相对布局 (RelativeLayout) # 属性 # 相对父容器 # 以下属性默认都是false，只有手动设置为true时才会生效\nlayout_centerInParent：相对于父容器居中（水平且垂直） layout_alignParentLeft：相对于父容器左对齐 layout_alignParentRight：相对于父容器右对齐 layout_alignParentTop：相对于父容器顶部对齐 layout_alignParentBottom：相对于父容器底部对齐 layout_centerHorizontal：相对整个屏幕水平居中 layout_centerVertical：相对整个屏幕垂直居中 相对同级别容器 # 在参照物的某边： # 以下属性默认都是false，只有手动设置为true时才会生效\nlayout_toLeftOf：相对某个同级别容器，对齐在其左边边框线上 layout_toRightOf：相对某个同级别容器，对齐在其右边边框上 layout_above：对齐某个同级别容器的上边线 layout_below：对齐某个同级别容器的下边线 和参照物的某边对线对齐： # layout_alignTop：和参照物的顶部边线对齐 layout_alignBottom：和参照物的底部边线对齐 layout_alignLeft：和参照物的左边线对齐 layout_alignRight：和参照物的右边线对齐 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/03-%E7%9B%B8%E5%AF%B9%E5%B8%83%E5%B1%80/","section":"Posts","summary":"","title":"相对布局 (RelativeLayout)","type":"posts"},{"content":" 线性布局 (LinearLayout) # 分类 # 线性布局(LinearLayout) 相对布局 帧布局 表格布局（TableLayout） 网格布局（GridLayout） 容器中的所有元素都是按照从上到下或从左到右依次排列的\n使用 # 在layout文件夹下创建layout类型的文件 除了定义文件名之外，还要定义Root Element 该值是指定根元素的布局\n属性 # orientation：容器的方向 vertical：垂直的 horizontal：水平的 layout_weight：权重（为容器中的元素提供的属性） 作用：按比例划分空间 重要条件：需要将layout_width写成0 layout_width：容器的宽度 20dp：自定义宽度 match_parent：和父容器的宽度保持一致 wrap_content：包裹内容，即内容多宽，容器就多宽 layout_height：容器的高度 20dp：自定义高度 match_parent：和父容器的高度保持一致 wrap_content：包裹内容，即内容多高，容器就多高 layout_gravity：容器的重力即容器会往哪一边靠 top：顶部对齐 bottom：底部对齐 center：居中对齐 left：左对齐 right：右对齐 ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/02-%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80/","section":"Posts","summary":"","title":"线性布局 (LinearLayout)","type":"posts"},{"content":" 菜单组件 # OptionMenu 选项菜单 # 选项菜单是一个应用主菜单，用于放置对应用产生全局影响的操作\nonCreateOptionsMenu()：将menu赋值到页面当中 onOptionItemSelected()：当选择菜单项时做的操作 xml属性：\nshowAsAction always：直接在标题栏显示 never：不显示 ifRoom：有空间就显示 ContextMenu 上下文菜单 # 在长按时弹出的一个菜单\n首先进行上下文菜单的注册：registerForContextMenu(View控件对象) 在类中创建上下文：onCreateContextMenu() 选中时的处理：onContextItemSelected() 在长按触发器时，在顶部会出现一个菜单来进行操作\nPopupMenu 弹出菜单 # 一个模态形式展示的弹出风格的菜单，绑在View上，一般出现在被绑定的View的下方\n步骤 # 实例化PopupMenu对象 加载菜单资源：利用MenuInflater 将R.menu.xx对应的菜单资源加载到弹出式菜单中 为PopupMenu设置点击监听器 menu.show()展示这个菜单 Menu的创建方式 # Java方式定义 # XML方式定义 # 总结 # [!info] 经验分享 xml定义Menu的优势：清晰地菜单结构，将菜单内容与应用的逻辑代码分离，资源适配更容易\nMenu显示：onCreateOptionsMenu()方法必须返回true，onOptionItemSelected()方法返回true且调用父类的默认实现\n","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/12-%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6/","section":"Posts","summary":"","title":"菜单组件","type":"posts"},{"content":" 选择控件 # CheckBox 复选框 # CheckBox是系统封装的复选控件，两种状态选中及未选中 setChecked() isChecked()。监听状态变化：setOnCheckedChangeListener\nRadioButton 单选框 # 单选控件，可以和RadioGroup一起使用，只能选择一个\n和CheckBox的区别：\n通过点击无法变为未选中 一组 RadioButton，只能同时选中一个 在大部分UI框架中默认都以圆形表示 ToggleButton 切换按钮 # 切换程序中的状态。该控件只有两种状态，一种是开一种是关\nandroid:textOn android:textOff setChecked(boolean) setOnCheckedChangeListener SeekBar 滑动条 # 使用场景：如音乐播放器等\n简单使用与时间监听：\nsetProgress setOnSeekBarChangeListener ","date":"22 October 2025","externalUrl":null,"permalink":"/posts/android/10-%E9%80%89%E6%8B%A9%E6%8E%A7%E4%BB%B6/","section":"Posts","summary":"","title":"选择控件","type":"posts"},{"content":" 设备管理页面逻辑模型图 # 实体关系图 (ERD) # erDiagram SCHOOL { int school_id PK string school_name string address datetime created_at datetime updated_at } GRADE { int grade_id PK int school_id FK string grade_name int grade_level datetime created_at datetime updated_at } CLASS { int class_id PK int grade_id FK string class_name string classroom_location datetime created_at datetime updated_at } DEVICE { int device_id PK int class_id FK string device_number string installation_location string device_type string status datetime last_online_time datetime created_at datetime updated_at } USER { int user_id PK string username string password string role datetime created_at datetime updated_at } SCHOOL ||--o{ GRADE : \u0026#34;has\u0026#34; GRADE ||--o{ CLASS : \u0026#34;contains\u0026#34; CLASS ||--o{ DEVICE : \u0026#34;installs\u0026#34; USER ||--o{ SCHOOL : \u0026#34;manages\u0026#34; 页面功能流程图 # flowchart TD A[设备管理页面] --\u0026gt; B[搜索筛选区域] A --\u0026gt; C[操作按钮区域] A --\u0026gt; D[数据表格区域] B --\u0026gt; B1[学校选择] B --\u0026gt; B2[年级输入] B --\u0026gt; B3[班级输入] B --\u0026gt; B4[状态选择] B --\u0026gt; B5[查询按钮] B --\u0026gt; B6[重置按钮] C --\u0026gt; C1[新增设备] C --\u0026gt; C2[批量删除] D --\u0026gt; D1[复选框列] D --\u0026gt; D2[序号列] D --\u0026gt; D3[学校名称列] D --\u0026gt; D4[年级列] D --\u0026gt; D5[班级列] D --\u0026gt; D6[设备安装位置列] D --\u0026gt; D7[设备编号列] D --\u0026gt; D8[状态列] D --\u0026gt; D9[操作列] D9 --\u0026gt; D9A[编辑按钮] D9 --\u0026gt; D9B[更多操作] D9B --\u0026gt; D9B1[删除] D9B --\u0026gt; D9B2[查看详情] D9B --\u0026gt; D9B3[设备配置] 数据状态流转图 # stateDiagram-v2 [*] --\u0026gt; 离线 离线 --\u0026gt; 在线 : 设备上线 在线 --\u0026gt; 离线 : 设备下线 在线 --\u0026gt; 维护中 : 开始维护 维护中 --\u0026gt; 在线 : 维护完成 离线 --\u0026gt; 故障 : 检测到故障 故障 --\u0026gt; 离线 : 故障修复 故障 --\u0026gt; 报废 : 无法修复 维护中 --\u0026gt; 报废 : 维护失败 在线 --\u0026gt; 报废 : 设备老化 报废 --\u0026gt; [*] 页面交互时序图 # sequenceDiagram participant U as 用户 participant P as 页面 participant A as API接口 participant D as 数据库 U-\u0026gt;\u0026gt;P: 打开设备管理页面 P-\u0026gt;\u0026gt;A: 请求设备列表 A-\u0026gt;\u0026gt;D: 查询设备数据 D--\u0026gt;\u0026gt;A: 返回设备列表 A--\u0026gt;\u0026gt;P: 返回设备数据 P--\u0026gt;\u0026gt;U: 显示设备列表 U-\u0026gt;\u0026gt;P: 点击筛选条件 P-\u0026gt;\u0026gt;A: 发送筛选请求 A-\u0026gt;\u0026gt;D: 执行筛选查询 D--\u0026gt;\u0026gt;A: 返回筛选结果 A--\u0026gt;\u0026gt;P: 返回筛选数据 P--\u0026gt;\u0026gt;U: 更新表格显示 U-\u0026gt;\u0026gt;P: 点击新增按钮 P--\u0026gt;\u0026gt;U: 打开新增设备弹窗 U-\u0026gt;\u0026gt;P: 填写设备信息并提交 P-\u0026gt;\u0026gt;A: 发送新增请求 A-\u0026gt;\u0026gt;D: 插入设备数据 D--\u0026gt;\u0026gt;A: 返回插入结果 A--\u0026gt;\u0026gt;P: 返回操作结果 P--\u0026gt;\u0026gt;U: 显示操作结果并刷新列表 核心业务逻辑 # 1. 数据层级关系 # 学校 → 年级 → 班级 → 设备 每个层级都有明确的父子关系 设备必须归属于某个具体的班级 2. 筛选逻辑 # 支持按学校、年级、班级、状态进行筛选 筛选条件可以组合使用 支持重置所有筛选条件 3. 设备状态管理 # 在线: 设备正常运行 离线: 设备断开连接 维护中: 设备正在维护 故障: 设备出现故障 报废: 设备已报废 4. 操作权限 # 查看: 所有用户都可以查看设备列表 新增: 管理员可以新增设备 编辑: 管理员可以编辑设备信息 删除: 管理员可以删除设备（单个或批量） 5. 数据验证规则 # 设备编号必须唯一 安装位置不能为空 设备必须关联到有效的班级 状态变更需要记录时间戳 业务线概念数据模型 # 1.1 设备新增业务线 # flowchart LR A[登录] --\u0026gt; B[点击新增设备] B --\u0026gt; C[打开新增设备弹窗] C --\u0026gt; D[选择学校名称] D --\u0026gt; E[选择年级] E --\u0026gt; F[选择班级] F --\u0026gt; G[输入NVR] G --\u0026gt; H[输入安装位置] H --\u0026gt; I[选择设备类型] I --\u0026gt; J[输入用户名] J --\u0026gt; K[输入密码] K --\u0026gt; L{信息验证} L --\u0026gt;|验证通过| M[点击确定] L --\u0026gt;|验证失败| N[显示错误信息] N --\u0026gt; D M --\u0026gt; O{保存成功?} O --\u0026gt;|成功| P[显示成功信息] O --\u0026gt;|失败| Q[显示失败信息] P --\u0026gt; R[关闭弹窗] Q --\u0026gt; D R --\u0026gt; S[刷新设备列表] S --\u0026gt; T[注销] C --\u0026gt; U[点击取消] U --\u0026gt; V[关闭弹窗] V --\u0026gt; W[返回设备列表] W --\u0026gt; T 1.2 设备查询业务线 # flowchart LR A[登录] --\u0026gt; B[设置筛选条件] B --\u0026gt; C[学校选择] C --\u0026gt; D[年级输入] D --\u0026gt; E[班级输入] E --\u0026gt; F[状态选择] F --\u0026gt; G[执行查询] G --\u0026gt; H{查询成功?} H --\u0026gt;|成功| I[显示设备列表] H --\u0026gt;|失败| J[显示错误信息] I --\u0026gt; K[用户操作] J --\u0026gt; B K --\u0026gt; L{选择操作} L --\u0026gt;|编辑| M[编辑设备] L --\u0026gt;|删除| N[删除设备] L --\u0026gt;|重置| B M --\u0026gt; O[注销] N --\u0026gt; O 1.3 设备编辑业务线 # flowchart LR A[登录] --\u0026gt; B[选择设备] B --\u0026gt; C[点击编辑] C --\u0026gt; D[加载设备信息] D --\u0026gt; E{加载成功?} E --\u0026gt;|成功| F[显示编辑表单] E --\u0026gt;|失败| G[显示错误信息] F --\u0026gt; H[修改设备信息] G --\u0026gt; B H --\u0026gt; I{信息验证} I --\u0026gt;|验证通过| J[保存修改] I --\u0026gt;|验证失败| K[显示验证错误] J --\u0026gt; L{保存成功?} K --\u0026gt; H L --\u0026gt;|成功| M[显示成功信息] L --\u0026gt;|失败| N[显示失败信息] M --\u0026gt; O[刷新设备列表] N --\u0026gt; H O --\u0026gt; P[注销] 1.4 设备批量删除业务线 # flowchart LR A[登录] --\u0026gt; B[选择多个设备] B --\u0026gt; C[点击批量删除] C --\u0026gt; D[显示确认对话框] D --\u0026gt; E{用户确认?} E --\u0026gt;|确认| F[执行批量删除] E --\u0026gt;|取消| G[返回设备列表] F --\u0026gt; H{删除成功?} G --\u0026gt; I[注销] H --\u0026gt;|成功| J[显示删除成功] H --\u0026gt;|失败| K[显示删除失败] J --\u0026gt; L[刷新设备列表] K --\u0026gt; M[显示失败详情] L --\u0026gt; N[注销] M --\u0026gt; N 1.5 设备状态监控业务线 # flowchart LR A[登录] --\u0026gt; B[查看设备列表] B --\u0026gt; C[设备状态检查] C --\u0026gt; D{设备在线?} D --\u0026gt;|在线| E[更新在线状态] D --\u0026gt;|离线| F[更新离线状态] E --\u0026gt; G[记录在线时间] F --\u0026gt; H[记录离线时间] G --\u0026gt; I[刷新状态显示] H --\u0026gt; I I --\u0026gt; J[定时检查] J --\u0026gt; C C --\u0026gt; K[注销] 1.6 设备维护管理业务线 # flowchart LR A[登录] --\u0026gt; B[选择故障设备] B --\u0026gt; C[点击维护操作] C --\u0026gt; D[填写维护信息] D --\u0026gt; E[设置维护状态] E --\u0026gt; F{信息完整?} F --\u0026gt;|完整| G[保存维护记录] F --\u0026gt;|不完整| H[显示提示信息] G --\u0026gt; I{保存成功?} H --\u0026gt; D I --\u0026gt;|成功| J[更新设备状态] I --\u0026gt;|失败| K[显示保存失败] J --\u0026gt; L[发送维护通知] K --\u0026gt; D L --\u0026gt; M[记录维护日志] M --\u0026gt; N[刷新设备列表] N --\u0026gt; O[注销] 业务规则说明 # 设备新增规则 # 学校名称: 必选，从下拉列表中选择 年级: 必选，从下拉列表中选择 班级: 必选，从下拉列表中选择 NVR: 必填，输入NVR设备信息 安装位置: 必填，输入设备具体安装位置 设备类型: 必选，从下拉列表中选择 用户名: 必填，输入设备登录用户名 密码: 必填，输入设备登录密码 所有字段都有红色星号标识为必填项 验证失败时显示具体错误信息 支持取消操作，关闭弹窗返回列表 设备查询规则 # 支持多条件组合查询 查询结果按设备编号排序 分页显示，每页最多20条记录 支持导出查询结果 设备编辑规则 # 只能编辑非报废状态的设备 设备编号修改需要重新验证唯一性 状态变更需要记录操作人和操作时间 重要字段修改需要二次确认 批量删除规则 # 只能删除非在线状态的设备 删除前需要用户确认 删除操作不可逆 记录删除日志 状态监控规则 # 每5分钟检查一次设备状态 离线超过30分钟的设备标记为异常 状态变更实时推送给管理员 异常设备自动发送告警通知 维护管理规则 # 维护状态需要填写维护原因 维护完成后需要填写维护结果 维护记录永久保存 维护费用需要记录 技术实现建议 # 前端技术栈 # 框架: Vue.js / React UI组件: Element UI / Ant Design 状态管理: Vuex / Redux HTTP客户端: Axios 后端技术栈 # 框架: Spring Boot 数据库: MySQL ORM: MyBatis / JPA 缓存: Redis 数据库设计要点 # 建立合适的索引提高查询性能 使用外键约束保证数据完整性 添加软删除字段支持数据恢复 记录操作日志便于审计追踪 ","externalUrl":null,"permalink":"/posts/android/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E9%80%BB%E8%BE%91%E6%A8%A1%E5%9E%8B%E5%9B%BE/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]